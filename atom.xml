<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Chemistry]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-07-04T02:32:18.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Jason Yuan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[347 Top K Frequent Elements]]></title>
    <link href="http://yoursite.com/2016/07/03/347-Top-K-Frequent-Elements/"/>
    <id>http://yoursite.com/2016/07/03/347-Top-K-Frequent-Elements/</id>
    <published>2016-07-03T19:31:15.000Z</published>
    <updated>2016-07-04T02:32:18.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个数组，返回其出现次数最多的k个元素，时间复杂度优于O(nlogn)</p>
</blockquote>
<p><strong>样例</strong><br>给出[1,1,1,2,2,3] 和 k = 2, 返回 [1,2]</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>首先使用hash table统计元素的频率</li>
<li>建立一个长度为k的最小堆，因为堆顶最小，每次和堆顶元素作比较，大于堆顶就踢出堆顶元素并把当前元素加入堆中</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> map:</span><br><span class="line">                map[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                map[num] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        minHeap = Queue.PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> key, count <span class="keyword">in</span> map.items():</span><br><span class="line">            <span class="keyword">if</span> minHeap.qsize() &lt; k:</span><br><span class="line">                minHeap.put((count, key))</span><br><span class="line">            <span class="keyword">elif</span> minHeap.queue[<span class="number">0</span>] &lt; (count, key):</span><br><span class="line">                minHeap.get()</span><br><span class="line">                minHeap.put((count, key))</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> minHeap.queue]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个数组，返回其出现次数最多的k个元素，时间复杂度优于O(nlogn)</p>
</blockquote>
<p><strong>样例</strong><br>给出[1,1,1,2,2,3] 和 k = 2]]>
    </summary>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Priority Queue" scheme="http://yoursite.com/tags/Priority-Queue/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[493 [Implement Queue by Linked List II]]></title>
    <link href="http://yoursite.com/2016/06/28/493-Implement-Queue-by-Linked-List-II/"/>
    <id>http://yoursite.com/2016/06/28/493-Implement-Queue-by-Linked-List-II/</id>
    <published>2016-06-28T23:16:43.000Z</published>
    <updated>2016-06-29T06:17:23.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个双端队列</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push_front(1)&#10;push_back(2)&#10;pop_back() // return 2&#10;pop_back() // return 1&#10;push_back(3)&#10;push_back(4)&#10;pop_front() // return 3&#10;pop_front() // return 4</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>自己构建一个双向链表</li>
<li>需要注意从前面pop出最后一个元素和从后面pop出最后一个元素的情况</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _val)</span>:</span></span><br><span class="line">        self.next = self.prev = <span class="keyword">None</span></span><br><span class="line">        self.val = _val</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dequeue</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># do some intialize if necessary</span></span><br><span class="line">        self.first, self.last = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; item an integer</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_front</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># Write yout code here</span></span><br><span class="line">        <span class="keyword">if</span> self.first <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.first = Node(item)</span><br><span class="line">            self.last = self.first</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = Node(item)</span><br><span class="line">            self.first.prev = tmp</span><br><span class="line">            tmp.next = self.first</span><br><span class="line">            self.first = tmp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; item an integer</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># Write yout code here</span></span><br><span class="line">        <span class="keyword">if</span> self.last <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.first = Node(item)</span><br><span class="line">            self.last = self.first</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = Node(item)</span><br><span class="line">            self.last.next = tmp</span><br><span class="line">            tmp.prev = self.last</span><br><span class="line">            self.last = tmp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> self.first <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            item = self.first.val</span><br><span class="line">            self.first = self.first.next</span><br><span class="line">            <span class="keyword">if</span> self.first <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                self.first.prev = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.last = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_back</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> self.last <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            item = self.last.val</span><br><span class="line">            self.last = self.last.prev</span><br><span class="line">            <span class="keyword">if</span> self.last <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                self.last.next = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.first = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">12</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个双端队列</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><tr><td class]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[492 Implement Queue by Linked List]]></title>
    <link href="http://yoursite.com/2016/06/28/492-Implement-Queue-by-Linked-List/"/>
    <id>http://yoursite.com/2016/06/28/492-Implement-Queue-by-Linked-List/</id>
    <published>2016-06-28T22:52:11.000Z</published>
    <updated>2016-06-29T05:52:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个队列的操作</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enqueue(<span class="number">1</span>)</span><br><span class="line">enqueue(<span class="number">2</span>)</span><br><span class="line">enqueue(<span class="number">3</span>)</span><br><span class="line">dequeue() <span class="comment"># return 1</span></span><br><span class="line">enqueue(<span class="number">4</span>)</span><br><span class="line">dequeue() <span class="comment"># return 2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>简单基础的一道题，用链表实现列队</li>
<li>注意，dequeue的时候如果是下面这种情况，head指向dummyNode，tail指向5。把5删除之后要记得将tail重新指向head所指向的node<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DummyNode -&gt; 5 -&gt; Null</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _val)</span>:</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.val = _val</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># do some intialize if necessary</span></span><br><span class="line">        self.head = Node(<span class="number">0</span>)</span><br><span class="line">        self.tail = self.head</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; item an integer</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># Write yout code here</span></span><br><span class="line">        self.tail.next = Node(item)</span><br><span class="line">        self.tail = self.tail.next</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        res = self.head.next.val</span><br><span class="line">        self.head.next = self.head.next.next</span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.size == <span class="number">0</span>:</span><br><span class="line">            self.tail = self.head</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个队列的操作</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight python"><table><tr><td cla]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[225 Implement Stack by Two Queues]]></title>
    <link href="http://yoursite.com/2016/06/27/225-Implement-Stack-by-Two-Queues/"/>
    <id>http://yoursite.com/2016/06/27/225-Implement-Stack-by-Two-Queues/</id>
    <published>2016-06-28T01:06:49.000Z</published>
    <updated>2016-06-28T08:07:35.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>利用两个队列来实现一个栈的功能</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push(1)&#10;pop()&#10;push(2)&#10;isEmpty() // return false&#10;top() // return 2&#10;pop()&#10;isEmpty() // return true</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>使用两个queue<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q1 = []       q2 = []&#10;push 1&#10;q1 = [1]      q2 = []&#10;q1 = []       q2 = [1] &#10;push 2&#10;q1 = [2]      q2 = [1]&#10;q1 = [2, 1]   q2 = []&#10;q1 = []       q2 = [2, 1]&#10;push 3&#10;q1 = [3]       q2 = [2, 1]&#10;q1 = [3, 2, 1] q2 = []&#10;q1 = []        q2 = [3, 2, 1]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        initialize your data structure here.</span><br><span class="line">        """</span></span><br><span class="line">        self.q1 = Queue.Queue()</span><br><span class="line">        self.q2 = Queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        self.q1.put(x)</span><br><span class="line">        <span class="keyword">while</span> self.q2.qsize() != <span class="number">0</span>:</span><br><span class="line">            self.q1.put(self.q2.get())</span><br><span class="line">        <span class="keyword">while</span> self.q1.qsize() != <span class="number">0</span>:</span><br><span class="line">            self.q2.put(self.q1.get())</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        self.q2.get()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.q2.queue[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.q2.qsize() == <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>利用两个队列来实现一个栈的功能</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><tr><t]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[495 Implement Stack]]></title>
    <link href="http://yoursite.com/2016/06/27/495-Implement-Stack/"/>
    <id>http://yoursite.com/2016/06/27/495-Implement-Stack/</id>
    <published>2016-06-28T00:41:06.000Z</published>
    <updated>2016-06-28T07:41:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个栈，可以使用除了栈之外的数据结构</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push(1)&#10;pop()&#10;push(2)&#10;top()  // return 2&#10;pop()&#10;isEmpty() // return true&#10;push(3)&#10;isEmpty() // return false</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>使用python list实现stack数据结构</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="comment"># initialize your data structure here.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param x, an integer, push a new item into the stack</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        self.items.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return nothing, pop the top of the stack</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return an integer, return the top of the stack</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">return</span> self.items[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return a boolean, check the stack is empty or not.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items) == <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个栈，可以使用除了栈之外的数据结构</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><]]>
    </summary>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[263 Ugly Number]]></title>
    <link href="http://yoursite.com/2016/06/26/263-Ugly-Number/"/>
    <id>http://yoursite.com/2016/06/26/263-Ugly-Number/</id>
    <published>2016-06-26T23:09:58.000Z</published>
    <updated>2016-06-27T06:10:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>写一个程序来检测一个整数是不是丑数。<br>丑数的定义是，只包含质因子 2, 3, 5的正整数。比如 6, 8 就是丑数，但是 14 不是丑数以为他包含了质因子 7。<br><strong>注意事项</strong><br>可以认为 1 是一个特殊的丑数。</p>
</blockquote>
<p><strong>样例</strong><br>给出 num = 8，返回 true。<br>给出 num = 14，返回 false。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>由于本题只需要判断num是不是丑数，根据丑数的定义：<ul>
<li>如果num对2取模等于0，则num除以2</li>
<li>如果num对3取模等于0，则num除以3</li>
<li>如果num对5取模等于0，则num除以5</li>
</ul>
</li>
<li>如果最后num等于1则是丑数，否则不是</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUgly</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type num: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                num /= <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                num /= <span class="number">3</span></span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                num /= <span class="number">5</span></span><br><span class="line">            <span class="keyword">return</span> num == <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>写一个程序来检测一个整数是不是丑数。<br>丑数的定义是，只包含质因子 2, 3, 5的正整数。比如 6, 8 就是丑数，但是 14 不是丑数以为他包含了质因子 7。<br><strong>注意事项</stro]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[232 Implement Queue using Stacks]]></title>
    <link href="http://yoursite.com/2016/06/26/232-Implement-Queue-using-Stacks/"/>
    <id>http://yoursite.com/2016/06/26/232-Implement-Queue-using-Stacks/</id>
    <published>2016-06-26T17:12:41.000Z</published>
    <updated>2016-06-27T00:13:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>正如标题所述，你需要使用两个栈来实现队列的一些操作。<br>队列应支持push(element)，pop() 和 top()，其中pop是弹出队列中的第一个(最前面的)元素。<br>pop和top方法都应该返回第一个元素的值。</p>
</blockquote>
<p><strong>样例</strong><br>比如push(1), pop(), push(2), push(3), top(), pop()，<br>你应该返回1，2和2</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>使用两个stack就可以实现queue的API</li>
<li>每次push就push到stack1</li>
<li>每次pop或者top，则看stack2是否为空，若为空，则将stack1中的元素pop出来并push到stack2<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">pop <span class="number">3</span></span><br><span class="line">stack2 = [<span class="number">3</span>]</span><br><span class="line">pop <span class="number">2</span></span><br><span class="line">stack2 = [<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">pop <span class="number">1</span></span><br><span class="line">stack2 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] <span class="comment">#真正的pop/top操作在stack2上执行</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        initialize your data structure here.</span><br><span class="line">        """</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        self.stack1.append(x)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2[-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack1) == <span class="number">0</span> <span class="keyword">and</span> len(self.stack2) == <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>正如标题所述，你需要使用两个栈来实现队列的一些操作。<br>队列应支持push(element)，pop() 和 top()，其中pop是弹出队列中的第一个(最前面的)元素。<br>pop和top方法都应该返回]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[486 Merge k Sorted Arrays]]></title>
    <link href="http://yoursite.com/2016/06/26/486-Merge-k-Sorted-Arrays/"/>
    <id>http://yoursite.com/2016/06/26/486-Merge-k-Sorted-Arrays/</id>
    <published>2016-06-26T16:58:02.000Z</published>
    <updated>2016-06-26T23:58:46.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>将 k 个排序数组合并为一个大的排序数组。</p>
</blockquote>
<p><strong>样例</strong><br>给出下面的 3 个排序数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#10; [1, 3, 5, 7], &#10; [2, 4, 6], &#10; [0, 8, 9, 10, 11]&#10;]</span><br></pre></td></tr></table></figure></p>
<p>合并后的大数组应为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>本题类似于Merge k Sorted Lists。与之不同的是，arrays不能直接通过一个值找到相邻的下一个值，所以需要建立一个set(数值，数组编号，index)</li>
<li>这样，我们就拥有了当前数组是Arrays中的哪一个数组，并且知道了是这个数组的第几个数字</li>
<li>首先创建一个最小堆，把每一个array的第一个数字放入堆中，然后取最小，把最小值放入res中，并把最小值所在数组中的相邻的数放入堆中</li>
</ul>
<p><strong>注意</strong><br>使用heapq性能优于封装的Queue.PriorityQueue，本题使用Queue.PriorityQueue会TLE</p>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[][]&#125; arrays k sorted integer arrays</span></span><br><span class="line">    <span class="comment"># @return &#123;int[]&#125; a sorted array</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergekSortedArrays</span><span class="params">(self, arrays)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        result = []</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> index, array <span class="keyword">in</span> enumerate(arrays):</span><br><span class="line">            <span class="keyword">if</span> len(array) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            heapq.heappush(heap, (array[<span class="number">0</span>], index, <span class="number">0</span>))</span><br><span class="line">             </span><br><span class="line">        <span class="keyword">while</span> len(heap):</span><br><span class="line">            val, arrayNum, index = heapq.heappop(heap)</span><br><span class="line">            result.append(val)</span><br><span class="line">            <span class="keyword">if</span> index + <span class="number">1</span> &lt; len(arrays[arrayNum]):</span><br><span class="line">                heapq.heappush(heap, (arrays[arrayNum][index + <span class="number">1</span>], arrayNum, index + <span class="number">1</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>将 k 个排序数组合并为一个大的排序数组。</p>
</blockquote>
<p><strong>样例</strong><br>给出下面的 3 个排序数组：<br><figure class="highli]]>
    </summary>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Priority Queue" scheme="http://yoursite.com/tags/Priority-Queue/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[545 Top k Largest Number II]]></title>
    <link href="http://yoursite.com/2016/06/26/545-Top-k-Largest-Number-II/"/>
    <id>http://yoursite.com/2016/06/26/545-Top-k-Largest-Number-II/</id>
    <published>2016-06-26T16:22:37.000Z</published>
    <updated>2016-06-26T23:23:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个数据结构，提供下面两个接口<br>1.add(number) 添加一个元素<br>2.topk() 返回前K大的数</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = new Solution(3);&#10;&#62;&#62; create a new data structure.&#10;s.add(3)&#10;s.add(10)&#10;s.topk()&#10;&#62;&#62; return [10, 3]&#10;s.add(1000)&#10;s.add(-99)&#10;s.topk()&#10;&#62;&#62; return [1000, 10, 3]&#10;s.add(4)&#10;s.topk()&#10;&#62;&#62; return [1000, 10, 4]&#10;s.add(100)&#10;s.topk()&#10;&#62;&#62; return [1000, 100, 10]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>内部维护一个大小为k的最小堆</li>
<li>如果size &lt; k则直接将num加入到minHeap</li>
<li>如果size &gt;= k, 则比较num与minHeap中的最小值，若小于最小值则忽略，大于最小值则删除最小值，并把num加入到minHeap</li>
<li>每次返回minHeap数组，返回时先反向排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(nums, reverse=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; k an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="comment"># initialize your data structure here.</span></span><br><span class="line">        self.size = k</span><br><span class="line">        self.minHeap = Queue.PriorityQueue()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># @param &#123;int&#125; num an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> self.minHeap.qsize() &lt; self.size:</span><br><span class="line">            self.minHeap.put(num)</span><br><span class="line">        <span class="keyword">elif</span> num &gt; self.minHeap.queue[<span class="number">0</span>]:</span><br><span class="line">            self.minHeap.get()</span><br><span class="line">            self.minHeap.put(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return &#123;int[]&#125; the top k largest numbers</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">return</span> sorted(self.minHeap.queue, reverse=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个数据结构，提供下面两个接口<br>1.add(number) 添加一个元素<br>2.topk() 返回前K大的数</p>
</blockquote>
<p><strong>样例</strong><br]]>
    </summary>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Priority Queue" scheme="http://yoursite.com/tags/Priority-Queue/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[544 Top k Largest Numbers]]></title>
    <link href="http://yoursite.com/2016/06/26/544-Top-k-Largest-Numbers/"/>
    <id>http://yoursite.com/2016/06/26/544-Top-k-Largest-Numbers/</id>
    <published>2016-06-26T15:59:50.000Z</published>
    <updated>2016-06-26T23:00:29.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个数组中找到前K大的数</p>
</blockquote>
<p><strong>样例</strong><br>给出 [3,10,1000,-99,4,100], k = 3.<br>返回 [1000, 100, 10]</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>方法一：快速排序，然后取出前k大的数。时间复杂度O(n*logn + k)</li>
<li><p>方法二：维护一个大小为k的最大堆/最小堆，代码如下。时间复杂度为O(n * logk)</p>
</li>
<li><p>关于Heap</p>
<ul>
<li>在python中有两个接口：<strong>heapq</strong>和<strong>Queue.PriorityQueue</strong>。其中PriorityQueue module is using the <strong>heapq</strong> module which is slower because it adds locks, encapsulation, and a nice object oriented API.</li>
<li>heapq的使用：<ul>
<li>heapq.<strong>heappush</strong>: Push the value <em>item</em> onto the <em>heap</em>, maintaining the heap invariant.</li>
<li>heapq.<strong>heappop</strong>: Pop and return the smallest item from the <em>heap</em>, maintaining the heap invariant.</li>
<li>heapq.<strong>heapify</strong>: Transform list <em>x</em> into a heap, in-place, in linear time.</li>
</ul>
</li>
<li>Queue.PriorityQueue的使用 (myqueue = Queue.PriorityQueue)<ul>
<li>myqueue.put()</li>
<li>myqueue.get()</li>
<li>myqueue.qsize()</li>
<li>myqueue.empty()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">'''</span><br><span class="line">    @param &#123;int[]&#125; nums an integer array</span><br><span class="line">    @param &#123;int&#125; k an integer</span><br><span class="line">    @return &#123;int[]&#125; the top k largest numbers in array</span><br><span class="line">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topk</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">            </span><br><span class="line">        MaxHeap = Queue.PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            MaxHeap.put(-num)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            res.append(-MaxHeap.get())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个数组中找到前K大的数</p>
</blockquote>
<p><strong>样例</strong><br>给出 [3,10,1000,-99,4,100], k = 3.<br>返回 [1000, 1]]>
    </summary>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Priority Queue" scheme="http://yoursite.com/tags/Priority-Queue/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[128 Hash Function]]></title>
    <link href="http://yoursite.com/2016/06/25/128-Hash-Function/"/>
    <id>http://yoursite.com/2016/06/25/128-Hash-Function/</id>
    <published>2016-06-25T23:15:32.000Z</published>
    <updated>2016-06-26T06:16:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在数据结构中，哈希函数是用来将一个字符串（或任何其他类型）转化为小于哈希表大小且大于等于零的整数。一个好的哈希函数可以尽可能少地产生冲突。一种广泛使用的哈希函数算法是使用数值33，假设任何字符串都是基于33的一个大整数。给出一个字符串作为key和一个哈希表的大小，返回这个字符串的哈希值。</p>
</blockquote>
<p>对于key=”abcd” 并且 size=100， 返回 78</p>
<h3 id="解题思路：">解题思路：</h3><ul>
<li><p>关于哈希表：</p>
<ul>
<li>哈希表在内存中是一个事先开辟好的数组，通过hash function把一个key转化为某一个index，来实现O(1)的查找</li>
<li>理想状态下，每次算出的index都是唯一的，而实际上会有Collision</li>
<li>hash function设计标准是越乱越没有规则越好，以避免Collision，一般是通过某种方式将key转化为一个integer然后对hash table size取模</li>
<li>哈希表的size最好要是所要存的数字数量的10倍，当size不够时，需要rehashing。</li>
</ul>
</li>
<li><p>如何处理冲突 - Collision</p>
<ul>
<li>Open hashing - 冲突的话，index下面采用linked list</li>
<li>Closed hashing - 如果有冲突，则向前或者向后位移。致命缺点，不支持删除，所以几乎没人采用</li>
</ul>
</li>
<li><p>将key转化为整数的方式有：</p>
<ul>
<li>MD5, 但是耗费较大</li>
<li>APR hash function - magic number 33(只是经验值)</li>
</ul>
</li>
<li><p>Python中char和integer之间的转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#62;&#62;&#62;ord(&#34;a&#34;)&#10;97&#10;&#62;&#62;&#62;chr(97)&#10;&#39;a&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>小技巧，如何计算a * 33^3 + b * 33^2 + c * 33 + d</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = a * 33&#10;sum = (a * 33 + b) * 33&#10;sum = (a * 33^2 + b * 33 + c) * 33&#10;sum = (a * 33^3 + b * 33^2 + c * 33 + d) * 33&#10;...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param key: A String you should hash</span><br><span class="line">    @param HASH_SIZE: An integer</span><br><span class="line">    @return an integer</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span><span class="params">(self, key, HASH_SIZE)</span>:</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> key:</span><br><span class="line">            sum = sum * <span class="number">33</span> + ord(char)</span><br><span class="line">            sum = sum % HASH_SIZE</span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在数据结构中，哈希函数是用来将一个字符串（或任何其他类型）转化为小于哈希表大小且大于等于零的整数。一个好的哈希函数可以尽可能少地产生冲突。一种广泛使用的哈希函数算法是使用数值33，假设任何字符串都是基于33的一]]>
    </summary>
    
      <category term="Hash" scheme="http://yoursite.com/tags/Hash/"/>
    
      <category term="Hash Function" scheme="http://yoursite.com/tags/Hash-Function/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[49 Sort Letters by Case]]></title>
    <link href="http://yoursite.com/2016/06/19/49-Sort-Letters-by-Case/"/>
    <id>http://yoursite.com/2016/06/19/49-Sort-Letters-by-Case/</id>
    <published>2016-06-20T02:09:04.000Z</published>
    <updated>2016-06-20T09:09:56.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个只包含字母的字符串，按照先小写字母后大写字母的顺序进行排序。</p>
</blockquote>
<p>给出<strong>“abAcD”</strong>，一个可能的答案为<strong>“acbAD”</strong></p>
<p>小写字母或者大写字母他们之间不一定要保持在原始字符串中的相对位置。<br>在原地扫描一遍完成</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>Two Pointers  - 对撞型指针问题</li>
<li>做指针和右指针指向的字母，可能出现四种情况需要考虑：<ul>
<li>左：小写 | 右：小写 ====&gt; 左指针左移</li>
<li>左：大写 | 右：小写 ====&gt; 交换字母</li>
<li>左：大写 | 右：大写 ====&gt; 右指针右移</li>
<li>左：小写 | 右：小写 ====&gt; 左指针左移，右指针右移</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param chars: The letters array you should sort.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortLetters</span><span class="params">(self, chars)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> chars <span class="keyword">or</span> len(chars) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> chars</span><br><span class="line">            </span><br><span class="line">        left, right = <span class="number">0</span>, len(chars) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> ord(chars[left]) &lt; <span class="number">96</span> <span class="keyword">and</span> ord(chars[right]) &gt; <span class="number">96</span>:</span><br><span class="line">                chars[left], chars[right] = chars[right], chars[left]</span><br><span class="line">            <span class="keyword">elif</span> ord(chars[left]) &lt; <span class="number">96</span> <span class="keyword">and</span> ord(chars[right]) &lt; <span class="number">96</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> ord(chars[left]) &gt; <span class="number">96</span> <span class="keyword">and</span> ord(chars[right]) &gt; <span class="number">96</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span> </span><br><span class="line">                right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个只包含字母的字符串，按照先小写字母后大写字母的顺序进行排序。</p>
</blockquote>
<p>给出<strong>“abAcD”</strong>，一个可能的答案为<strong>“acbAD]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[4 Median of two Sorted Arrays]]></title>
    <link href="http://yoursite.com/2016/06/19/4-Median-of-two-Sorted-Arrays/"/>
    <id>http://yoursite.com/2016/06/19/4-Median-of-two-Sorted-Arrays/</id>
    <published>2016-06-20T01:27:04.000Z</published>
    <updated>2016-06-20T08:27:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>两个排序的数组A和B分别含有m和n个数，找到两个排序数组的中位数，要求时间复杂度应为O(log (m+n))。</p>
</blockquote>
<p><strong>样例</strong><br>给出数组A =<strong> [1,2,3,4,5,6]</strong> B = <strong>[2,3,4,5]</strong>，中位数3.5<br>给出数组A = <strong>[1,2,3]</strong> B = <strong>[4,5]</strong>，中位数 3</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>根据题目要求的时间复杂度是O(log(m+n))可知，必须要有个类似于binary search一样，每次操作可以扔一半。</li>
<li>如果数组A和B一个含有n个元素，那么,<ul>
<li>如果n是奇数，则中位数是合并数组的第n/2+1个数</li>
<li>如果n是偶数，则中位数是合并数组的第n/2个数和n/2+1个数的平均数</li>
</ul>
</li>
<li>最后为题转化为如何求两个排序数组的第k大的数，时间复杂度为O(log(m+n))</li>
<li>思路：每次找A的k/2的位置和B的k/2的位置的数与相比较<ul>
<li>如果A[k/2] &lt; B[k/2]，则扔掉A的前k/2个数，因为第k大的数一定不在其中。找第k大的数转化为，在剩下的A数组和B数组中找第k/2大的数</li>
<li>如果A[k/2] &gt;= B[k/2]，则扔掉B的前k/2个数，因为第k大的数一定不在其中。找第k大的数转化为，在剩下的B数组和A数组中找第k/2大的数</li>
</ul>
</li>
<li><strong>注意</strong>：如果要求返回float类型，要<code>/ 2.0</code>而不是<code>/ 2</code></li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums1: List[int]</span><br><span class="line">        :type nums2: List[int]</span><br><span class="line">        :rtype: float</span><br><span class="line">        """</span></span><br><span class="line">        n = len(nums1) + len(nums2)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findKthNum(nums1, nums2, n / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.findKthNum(nums1, nums2, n / <span class="number">2</span>) + self.findKthNum(nums1, nums2, n / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthNum</span><span class="params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums1) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums2[k - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> len(nums2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[k -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min(nums1[<span class="number">0</span>], nums2[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        a = nums1[k / <span class="number">2</span> - <span class="number">1</span>] <span class="keyword">if</span> k / <span class="number">2</span> &lt;= len(nums1) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">        b = nums2[k / <span class="number">2</span> - <span class="number">1</span>] <span class="keyword">if</span> k / <span class="number">2</span> &lt;= len(nums2) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> b <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> (a <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> a &lt; b):</span><br><span class="line">            <span class="keyword">return</span> self.findKthNum(nums1[k / <span class="number">2</span>:], nums2, k - k / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findKthNum(nums1, nums2[k / <span class="number">2</span>:], k - k / <span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>两个排序的数组A和B分别含有m和n个数，找到两个排序数组的中位数，要求时间复杂度应为O(log (m+n))。</p>
</blockquote>
<p><strong>样例</strong><br>给出数组A]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1 Two Sum]]></title>
    <link href="http://yoursite.com/2016/06/19/1-Two-Sum/"/>
    <id>http://yoursite.com/2016/06/19/1-Two-Sum/</id>
    <published>2016-06-19T16:27:40.000Z</published>
    <updated>2016-06-19T23:28:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一个整数数组，找到两个数使得他们的和等于一个给定的数target。<br>你需要实现的函数twoSum需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是1到n，不是以0开头。</p>
</blockquote>
<p>numbers=[2, 7, 11, 15],  target=9, return [1, 2]</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>对撞型指针</li>
<li>由于要返回下标，所以先建立一个hash map储存每个值得下标</li>
<li>两个指针分别从数组的头跟尾向中间扫描，如果两个数的和等于target则回到hash map中找到相应最小的下标返回，否则相应的移动头指针或者尾指针，知道两个指针相撞，结束</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        index = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> index:</span><br><span class="line">                index[num] = [i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index[num].append(i)</span><br><span class="line">                </span><br><span class="line">        sortedNums = sorted(nums)</span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> sortedNums[i] + sortedNums[j] == target:</span><br><span class="line">                <span class="keyword">if</span> sortedNums[i] == sortedNums[j]:</span><br><span class="line">                    <span class="keyword">return</span> [index[sortedNums[i]][<span class="number">0</span>], index[sortedNums[i]][<span class="number">1</span>]]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res = [index[sortedNums[i]][<span class="number">0</span>], index[sortedNums[j]][<span class="number">0</span>]]</span><br><span class="line">                    <span class="keyword">return</span> sorted(res)</span><br><span class="line">            <span class="keyword">elif</span> sortedNums[i] + sortedNums[j] &gt; target:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一个整数数组，找到两个数使得他们的和等于一个给定的数target。<br>你需要实现的函数twoSum需要返回这两个数的下标, 并且第一个下标小于第二个下标。注意这里下标的范围是1到n，不是以0开头。</p>]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[533 Two Sum Closest]]></title>
    <link href="http://yoursite.com/2016/06/19/533-Two-Sum-Closest/"/>
    <id>http://yoursite.com/2016/06/19/533-Two-Sum-Closest/</id>
    <published>2016-06-19T16:03:28.000Z</published>
    <updated>2016-06-19T23:03:57.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>找到两个数字使得他们和最接近target</p>
</blockquote>
<p><strong>样例</strong><br>nums = [-1, 2, 1, -4],target = 4.<br>最接近值为 1</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>对撞型指针问题，思路与Two Sum类似 O(n2) =&gt; O(n)</li>
<li>两个指针分别从数组的头跟尾向中间移动，相比于两次for循环，避免了不必要的扫描</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; nums an integer array</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; the difference between the sum and the target</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSumCloset</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        i, j = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        diff = sys.maxint</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[j] &lt; target:</span><br><span class="line">                diff = min(diff, target - nums[i] - nums[j])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                diff = min(diff, nums[i] + nums[j] - target)</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> diff</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>找到两个数字使得他们和最接近target</p>
</blockquote>
<p><strong>样例</strong><br>nums = [-1, 2, 1, -4],target = 4.<br>最接近]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[350 Intersection of Two Array II]]></title>
    <link href="http://yoursite.com/2016/06/17/350-Intersection-of-Two-Array-II/"/>
    <id>http://yoursite.com/2016/06/17/350-Intersection-of-Two-Array-II/</id>
    <published>2016-06-18T02:22:52.000Z</published>
    <updated>2016-06-18T09:23:29.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>计算两个数组的交<br><strong>注意事项</strong><br>每个元素出现次数得和在数组里一样答案可以以任意顺序给出</p>
</blockquote>
<p><strong>样例</strong><br>nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2, 2].</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>遍历第一个数组，构建hash map，计数</li>
<li>遍历第二个数组，如果存在在hash map而且个数大于零，加入res数组</li>
<li>其他方法：先排序，两根指针</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersect</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums1: List[int]</span><br><span class="line">        :type nums2: List[int]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> map:</span><br><span class="line">                map[x] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                map[x] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> y <span class="keyword">in</span> map <span class="keyword">and</span> map[y] &gt; <span class="number">0</span>:</span><br><span class="line">                res.append(y)</span><br><span class="line">                map[y] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>计算两个数组的交<br><strong>注意事项</strong><br>每个元素出现次数得和在数组里一样答案可以以任意顺序给出</p>
</blockquote>
<p><strong>样例</strong>]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Map" scheme="http://yoursite.com/tags/Hash-Map/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[138 Subarray Sum]]></title>
    <link href="http://yoursite.com/2016/06/17/138-Subarray-Sum/"/>
    <id>http://yoursite.com/2016/06/17/138-Subarray-Sum/</id>
    <published>2016-06-18T01:33:02.000Z</published>
    <updated>2016-06-18T08:34:30.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个整数数组，找到和为零的子数组。你的代码应该返回满足要求的子数组的起始位置和结束位置。</p>
</blockquote>
<p>给出<strong>[-3, 1, 2, -3, 4]</strong>，返回<strong>[0, 2]</strong> 或者<strong> [1, 3].</strong></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>使用一个hash map记录前n项和，初始化dict[0] = -1 =&gt; 前-1 + 1 = 0项和等于0</li>
<li>以此类推，前1项和等于-3，前2项和等于-2，前3项和等于0，此时发现0存在于dict中，dict[0] = -1，所以加入<strong>-1 + 1</strong>和<strong>i</strong>，res = [0, 2]</li>
<li>也就是说一旦发现前i项和等于前j项和，那么<strong>i~j这一段</strong>的和等于零，把坐标加入到res数组</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param nums: A list of integers</span><br><span class="line">    @return: A list of integers includes the index of the first number </span><br><span class="line">             and the index of the last number</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        dict[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            sum += num</span><br><span class="line">            <span class="keyword">if</span> sum <span class="keyword">in</span> dict:</span><br><span class="line">                res.append(dict[sum] + <span class="number">1</span>)</span><br><span class="line">                res.append(i)</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            dict[sum] = i</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个整数数组，找到和为零的子数组。你的代码应该返回满足要求的子数组的起始位置和结束位置。</p>
</blockquote>
<p>给出<strong>[-3, 1, 2, -3, 4]</strong>，]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Map" scheme="http://yoursite.com/tags/Hash-Map/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[349 Intersection of Two Arrays]]></title>
    <link href="http://yoursite.com/2016/06/13/349-Intersection-of-Two-Arrays/"/>
    <id>http://yoursite.com/2016/06/13/349-Intersection-of-Two-Arrays/</id>
    <published>2016-06-13T23:46:57.000Z</published>
    <updated>2016-06-18T08:38:50.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>返回两个数组的交</p>
</blockquote>
<p><strong>样例</strong><br>nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2]</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>方法一：hash map 实现如下</li>
<li>方法二：先把连个数组排序，再merge</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; nums1 an integer array</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; nums2 an integer array</span></span><br><span class="line">    <span class="comment"># @return &#123;int[]&#125; an integer array</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> map:</span><br><span class="line">                map[x] = <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> y <span class="keyword">in</span> map <span class="keyword">and</span> map[y] == <span class="number">1</span>:</span><br><span class="line">                res.append(y)</span><br><span class="line">                map[y] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>返回两个数组的交</p>
</blockquote>
<p><strong>样例</strong><br>nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2]</p>
<h3]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Hash Map" scheme="http://yoursite.com/tags/Hash-Map/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[148 Sort List]]></title>
    <link href="http://yoursite.com/2016/06/12/148-Sort-List/"/>
    <id>http://yoursite.com/2016/06/12/148-Sort-List/</id>
    <published>2016-06-13T00:56:58.000Z</published>
    <updated>2016-06-13T08:02:07.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在 O(<em>n</em> log <em>n</em>) 时间复杂度和常数级的空间复杂度下给链表排序。</p>
</blockquote>
<p><strong>样例</strong>给出 1-&gt;3-&gt;2-&gt;null，给它排序变成 1-&gt;2-&gt;3-&gt;null.</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>方法一：遍历链表，存入数组中，排序数组，然后重新构建链表</li>
<li>方法二：直接操作链表，Merge Sort，先局部有序再整体有序，找中点，然后左半部分和右半部分分别递归merge sort (Divide and Conquer)</li>
<li>总结：<ul>
<li>对于数组，quick sort好于merge sort，因为quick sort是in-place，而merge sort需要额外空间，开辟空间/回收空间都要耗费时间</li>
<li>对于链表，merge sort并不需要额外空间</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        ans = []</span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="keyword">while</span> tmp != <span class="keyword">None</span>:</span><br><span class="line">            ans.append(tmp.val)</span><br><span class="line">            tmp = tmp.next</span><br><span class="line"></span><br><span class="line">        ans.sort()</span><br><span class="line">        tmp = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">            tmp.val = i</span><br><span class="line">            tmp = tmp.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span> <span class="keyword">or</span> head.next == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        mid = self.findMiddle(head)</span><br><span class="line"></span><br><span class="line">        right = self.sortList(mid.next)</span><br><span class="line">        mid.next = <span class="keyword">None</span></span><br><span class="line">        left = self.sortList(head)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.merge(left, right)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMiddle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        slow, fast = head, head.next</span><br><span class="line">        <span class="keyword">while</span> fast != <span class="keyword">None</span> <span class="keyword">and</span> fast.next != <span class="keyword">None</span>:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">return</span> slow    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, head1, head2)</span>:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        head = dummy</span><br><span class="line">        <span class="keyword">while</span> head1 <span class="keyword">and</span> head2:</span><br><span class="line">            <span class="keyword">if</span> head1.val &lt; head2.val:</span><br><span class="line">                head.next = head1</span><br><span class="line">                head1 = head1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head.next = head2</span><br><span class="line">                head2 = head2.next</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">if</span> head1:</span><br><span class="line">            head.next = head1</span><br><span class="line">        <span class="keyword">if</span> head2:</span><br><span class="line">            head.next = head2</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在 O(<em>n</em> log <em>n</em>) 时间复杂度和常数级的空间复杂度下给链表排序。</p>
</blockquote>
<p><strong>样例</strong>给出 1-&gt;3-]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="Merge Sort" scheme="http://yoursite.com/tags/Merge-Sort/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[61 Rotate List]]></title>
    <link href="http://yoursite.com/2016/06/12/61-Rotate-List/"/>
    <id>http://yoursite.com/2016/06/12/61-Rotate-List/</id>
    <published>2016-06-13T00:34:08.000Z</published>
    <updated>2016-06-13T07:34:31.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个链表，旋转链表，使得每个节点向右移动k个位置，其中k是一个非负数。</p>
</blockquote>
<p><strong>样例</strong><br>给出链表<strong>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null</strong>和k=2<br>返回<strong>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;null</strong></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>分解问题，各个击破</li>
<li>首先找到链表的尾部，并且计算长度</li>
<li>找到需要旋转的起点位置</li>
<li>最后做出相应的连接，旋转链表</li>
<li>注意移动的位置实际是<strong>(k % len)</strong></li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># find the tail</span></span><br><span class="line">        tail = head</span><br><span class="line">        len = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> tail.next != <span class="keyword">None</span>:</span><br><span class="line">            tail = tail.next</span><br><span class="line">            len += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> k % len == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># find the rotate place</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k % len):</span><br><span class="line">            fast = fast.next</span><br><span class="line">        <span class="keyword">while</span> fast.next != <span class="keyword">None</span>:</span><br><span class="line">            fast = fast.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">            </span><br><span class="line">        tail.next = head</span><br><span class="line">        head = slow.next</span><br><span class="line">        slow.next = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个链表，旋转链表，使得每个节点向右移动k个位置，其中k是一个非负数。</p>
</blockquote>
<p><strong>样例</strong><br>给出链表<strong>1-&gt;2-&gt]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
</feed>
