<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Chemistry]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-09-05T03:05:41.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Jason Yuan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[221 Maximal Square]]></title>
    <link href="http://yoursite.com/2016/09/04/221-Maximal-Square/"/>
    <id>http://yoursite.com/2016/09/04/221-Maximal-Square/</id>
    <published>2016-09-04T20:04:50.000Z</published>
    <updated>2016-09-05T03:05:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个二维01矩阵中找到全为1的最大正方形</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>返回 4</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>动态规划</li>
<li>dp[i][j]跟左上，左，上三个位置最大能延伸的正方形边长相关，如果dp[i][j]不等于0，则是三个中的最小值+1</li>
<li>初始化第一行，第一列，然后双层for循环更新</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type matrix: List[List[str]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        width = len(matrix[<span class="number">0</span>])</span><br><span class="line">        height = len(matrix)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(width)] <span class="keyword">for</span> j <span class="keyword">in</span> range(height)]</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(width):</span><br><span class="line">            dp[<span class="number">0</span>][i] = int(matrix[<span class="number">0</span>][i])</span><br><span class="line">            ans = max(ans, dp[<span class="number">0</span>][i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(height):</span><br><span class="line">            dp[j][<span class="number">0</span>] = int(matrix[j][<span class="number">0</span>])</span><br><span class="line">            ans = max(ans, dp[j][<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, height):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, width):</span><br><span class="line">                <span class="keyword">if</span> matrix[j][i] != <span class="string">"0"</span>:</span><br><span class="line">                    dp[j][i] = min(dp[j-<span class="number">1</span>][i-<span class="number">1</span>], min(dp[j-<span class="number">1</span>][i], dp[j][i-<span class="number">1</span>])) + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, dp[j][i])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans * ans</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个二维01矩阵中找到全为1的最大正方形</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight python"><table]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[398 Longest Increasing Continuous Subsequence II]]></title>
    <link href="http://yoursite.com/2016/09/04/398-Longest-Increasing-Continuous-Subsequence-II/"/>
    <id>http://yoursite.com/2016/09/04/398-Longest-Increasing-Continuous-Subsequence-II/</id>
    <published>2016-09-04T19:13:05.000Z</published>
    <updated>2016-09-05T02:13:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个整数矩阵（其中，有 n 行， m 列），请找出矩阵中的最长上升连续子序列。（最长上升连续子序列可从任意行或任意列开始，向上/下/左/右任意方向移动）。</p>
</blockquote>
<p><strong>样例</strong><br>给定一个矩阵<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>],</span><br><span class="line">  [<span class="number">16</span>,<span class="number">17</span>,<span class="number">24</span>,<span class="number">23</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">18</span>,<span class="number">25</span>,<span class="number">22</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">14</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>返回 25</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>类似于滑雪问题</li>
<li>记忆化搜索 - 因为对于某一个点，可以从上下左右更新，所以很难写出for循环那种DP</li>
<li>所谓记忆化所有，就是当我想更新matrix[x][y]的时候，我需要知道以matrix[x-1][y], matrix[x][y-1], matrix[x+1][y], matrix[x][y+1]这四个点结尾的最大长度，每次求出以matrix某个点结尾的连续的最大长度之后，都记录下来，下一次先去记忆的matrix中找，没有再算，有的话直接返回值</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[][]&#125; A an integer matrix</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125;  an integer</span></span><br><span class="line">    DIRECTIONS = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingContinuousSubsequenceII</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">0</span> <span class="keyword">or</span> len(A[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.width = len(A[<span class="number">0</span>])</span><br><span class="line">        self.height = len(A)</span><br><span class="line">        self.matrix = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(self.width)] <span class="keyword">for</span> j <span class="keyword">in</span> range(self.height)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.height):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.width):</span><br><span class="line">                self.search(A, i, j)</span><br><span class="line">        <span class="keyword">return</span> max(max(row) <span class="keyword">for</span> row <span class="keyword">in</span> self.matrix)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, A, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.matrix[x][y] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.matrix[x][y]</span><br><span class="line">        </span><br><span class="line">        longest = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.DIRECTIONS:</span><br><span class="line">            <span class="keyword">if</span> x + dx &lt; <span class="number">0</span> <span class="keyword">or</span> x + dx &gt;= self.height:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> y + dy &lt; <span class="number">0</span> <span class="keyword">or</span> y + dy &gt;= self.width:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> A[x][y] &gt;= A[x + dx][y + dy]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            longest = max(longest, self.search(A, x + dx, y + dy) + <span class="number">1</span>)</span><br><span class="line">        self.matrix[x][y] = longest</span><br><span class="line">        <span class="keyword">return</span> self.matrix[x][y]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个整数矩阵（其中，有 n 行， m 列），请找出矩阵中的最长上升连续子序列。（最长上升连续子序列可从任意行或任意列开始，向上/下/左/右任意方向移动）。</p>
</blockquote>
<p><str]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[397 Longest Increasing Continuous Subsequence]]></title>
    <link href="http://yoursite.com/2016/09/04/397-Longest-Increasing-Continuous-Subsequence/"/>
    <id>http://yoursite.com/2016/09/04/397-Longest-Increasing-Continuous-Subsequence/</id>
    <published>2016-09-04T18:52:15.000Z</published>
    <updated>2016-09-05T01:53:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）</p>
</blockquote>
<p><strong>样例</strong><br>给定 [5, 4, 2, 1, 3], 其最长上升连续子序列（LICS）为[5, 4, 2, 1], 返回 4.<br>给定 [5, 1, 2, 3, 4], 其最长上升连续子序列（LICS）为[1, 2, 3, 4], 返回 4.</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>正序逆序各求一个最长序列的值，取最大</li>
<li>一个全局变量res记录最长的长度，一个局部变量temp<ul>
<li>当nums[i] &gt; nums[i - 1]时，temp加1</li>
<li>当nums[i] &lt;= nums[i - 1]时，temp重置为1</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; A an array of Integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125;  an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingContinuousSubsequence</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">return</span> max(self.helper(A), self.helper(A[::-<span class="number">1</span>]))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        res, temp = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i - <span class="number">1</span>] <span class="keyword">or</span> i == <span class="number">0</span>:</span><br><span class="line">                temp += <span class="number">1</span></span><br><span class="line">                res = max(res, temp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）</p>
</blockquote>
<p><]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[213 House Robber II]]></title>
    <link href="http://yoursite.com/2016/09/04/213-House-Robber-II/"/>
    <id>http://yoursite.com/2016/09/04/213-House-Robber-II/</id>
    <published>2016-09-04T18:05:23.000Z</published>
    <updated>2016-09-05T01:07:03.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在上次打劫完一条街道之后，窃贼又发现了一个新的可以打劫的地方，<strong>但这次所有的房子围成了一个圈，这就意味着第一间房子和最后一间房子是挨着的</strong>。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：<strong>相邻的房子装着相互联系的防盗系统，且 当相邻的两个房子同一天被打劫时，该系统会自动报警</strong>。<br>给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，你最多可以得到多少钱 在不触动报警装置的情况下。</p>
</blockquote>
<p><strong>样例</strong><br>给出nums = [3,6,4], 返回　6，　你不能打劫3和4所在的房间，因为它们围成一个圈，是相邻的．</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>状态转移方程和【House Robber I】是一样的，唯一的区别是房子看成环状的，所以首位只能二选一</li>
<li>不包括头求一个最大值，不包括尾再求一个最大值。最后返回较大的</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, nums[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">        ans = dp[len(nums) - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max(dp[len(nums) - <span class="number">2</span>], ans)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在上次打劫完一条街道之后，窃贼又发现了一个新的可以打劫的地方，<strong>但这次所有的房子围成了一个圈，这就意味着第一间房子和最后一间房子是挨着的</strong>。每个房子都存放着特定金额的钱。你面临的唯]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[198 House Robber]]></title>
    <link href="http://yoursite.com/2016/09/04/198-House-Robber/"/>
    <id>http://yoursite.com/2016/09/04/198-House-Robber/</id>
    <published>2016-09-04T18:00:18.000Z</published>
    <updated>2016-09-05T01:01:11.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 <strong>当相邻的两个房子同一天被打劫时，该系统会自动报警</strong>。<br>给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，你最多可以得到多少钱 <strong>在不触动报警装置的情况下</strong>。</p>
</blockquote>
<p><strong>样例</strong><br>给定 [3, 8, 4], 返回 8.</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>单序列型动态规划</li>
<li>dp[i]代表前i个房子能获得的最大价值，所以<code>dp[i] = max(dp[i-1], dp[i-2] + nums[i])</code></li>
<li>可以使用滚动数组优化</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[len(nums) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 <strong>当相邻的两个房子同一天被打劫时，该系统会自动报警</s]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[57 Insert Interval]]></title>
    <link href="http://yoursite.com/2016/09/04/57-Insert-Interval/"/>
    <id>http://yoursite.com/2016/09/04/57-Insert-Interval/</id>
    <published>2016-09-04T17:04:36.000Z</published>
    <updated>2016-09-05T00:05:14.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个<strong>无重叠的</strong>按照区间起始端点排序的区间列表。<br>在列表中插入一个新的区间，你要确保列表中的区间仍然有序且<strong>不重叠</strong>（如果有必要的话，可以合并区间）。</p>
</blockquote>
<p><strong>样例</strong><br>插入区间<strong>[2, 5]</strong> 到 <strong>[[1,2], [5,9]]</strong>，我们得到 <strong>[[1,9]]
</strong>。<br>插入区间<strong>[3, 4]</strong> 到 <strong>[[1,2], [5,9]]</strong>，我们得到<strong> [[1,2], [3,4], [5,9]]</strong>。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>遍历每一个区间，进行更新，对区间和给定新区间进行判断，是否交叉<ul>
<li>interval.end &lt; newInterval.start，一定不交叉，该interval可以直接加入到result数组，但是insertPos要加一</li>
<li>interval.start &gt; newInterval.end，也一定不交叉，直接把该interval加入到result数组</li>
<li>剩下的情况，则表示两个interval交叉了，要更新newInterval的边界<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newInterval.start = min(interval.start, newInterval.start)</span><br><span class="line">newInterval.end = max(interval.end, newInterval.end)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals, newInterval)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type intervals: List[Interval]</span><br><span class="line">        :type newInterval: Interval</span><br><span class="line">        :rtype: List[Interval]</span><br><span class="line">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        insertPos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> interval.end &lt; newInterval.start:</span><br><span class="line">                res.append(interval)</span><br><span class="line">                insertPos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> interval.start &gt; newInterval.end:</span><br><span class="line">                res.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newInterval.start = min(interval.start, newInterval.start)</span><br><span class="line">                newInterval.end = max(interval.end, newInterval.end)</span><br><span class="line">        res.insert(insertPos, newInterval)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个<strong>无重叠的</strong>按照区间起始端点排序的区间列表。<br>在列表中插入一个新的区间，你要确保列表中的区间仍然有序且<strong>不重叠</strong>（如果有必要的话，可以合]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[56 Merge Intervals]]></title>
    <link href="http://yoursite.com/2016/09/04/56-Merge-Intervals/"/>
    <id>http://yoursite.com/2016/09/04/56-Merge-Intervals/</id>
    <published>2016-09-04T16:36:05.000Z</published>
    <updated>2016-09-04T23:36:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出若干闭合区间，合并所有重叠的部分。</p>
</blockquote>
<p><strong>样例</strong><br>给出的区间列表 =&gt; 合并后的区间列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[                     [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">3</span>],               [<span class="number">1</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">6</span>],      =&gt;       [<span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">  [<span class="number">8</span>, <span class="number">10</span>],              [<span class="number">15</span>, <span class="number">18</span>]</span><br><span class="line">  [<span class="number">15</span>, <span class="number">18</span>]            ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>首先，把区间按照起始点排序</li>
<li>然后遍历每一个区间<ul>
<li>如果result中的最后一个区间的end小于下一个区间的start，则加入下一个区间</li>
<li>若大于则update这个<code>end = max(res[-1].end, interval.end)</code></li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type intervals: List[Interval]</span><br><span class="line">        :rtype: List[Interval]</span><br><span class="line">        """</span></span><br><span class="line">        intervals = sorted(intervals, key=<span class="keyword">lambda</span> x:x.start)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> res[-<span class="number">1</span>].end &lt; interval.start:</span><br><span class="line">                res.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[-<span class="number">1</span>].end = max(res[-<span class="number">1</span>].end, interval.end)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出若干闭合区间，合并所有重叠的部分。</p>
</blockquote>
<p><strong>样例</strong><br>给出的区间列表 =&gt; 合并后的区间列表：<br><figure class=]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[378 Kth Smallest Sum in Sorted Matrix]]></title>
    <link href="http://yoursite.com/2016/09/04/378-Kth-Smallest-Sum-in-Sorted-Matrix/"/>
    <id>http://yoursite.com/2016/09/04/378-Kth-Smallest-Sum-in-Sorted-Matrix/</id>
    <published>2016-09-04T16:04:46.000Z</published>
    <updated>2016-09-04T23:09:16.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个排序矩阵中找从小到大的第 <em>k</em> 个整数。<br>排序矩阵的定义为：每一行递增，每一列也递增。</p>
</blockquote>
<p><strong>样例</strong><br>给出 <em>k</em> = 4和一个排序矩阵：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span> ,<span class="number">5</span> ,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">3</span> ,<span class="number">7</span> ,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">4</span> ,<span class="number">8</span> ,<span class="number">9</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>返回 5。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>首先把左上角的元素放入minHeap中，进入while循环，每次pop一个最小值，然后把该位置右边和下班的值+坐标放入minHeap中。k减一，当k等于0时，返回当前的值</li>
<li>同时要注意，另外开一个二维数组记录哪些元素已经被访问过，因为同一个元素可能在A的下面和B的右面</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type matrix: List[List[int]]</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        exist = [[<span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]))] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix))]</span><br><span class="line">        q = Queue.PriorityQueue()</span><br><span class="line">        q.put((matrix[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        exist[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            cur, x, y = q.get()</span><br><span class="line">            <span class="keyword">if</span> x + <span class="number">1</span> &lt; len(matrix) <span class="keyword">and</span> <span class="keyword">not</span> exist[x+<span class="number">1</span>][y]:</span><br><span class="line">                q.put((matrix[x+<span class="number">1</span>][y], x+<span class="number">1</span>, y))</span><br><span class="line">                exist[x+<span class="number">1</span>][y] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> y + <span class="number">1</span> &lt; len(matrix[<span class="number">0</span>]) <span class="keyword">and</span> <span class="keyword">not</span> exist[x][y+<span class="number">1</span>]:</span><br><span class="line">                q.put((matrix[x][y+<span class="number">1</span>], x, y+<span class="number">1</span>))</span><br><span class="line">                exist[x][y+<span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个排序矩阵中找从小到大的第 <em>k</em> 个整数。<br>排序矩阵的定义为：每一行递增，每一列也递增。</p>
</blockquote>
<p><strong>样例</strong><br>给出 ]]>
    </summary>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[113 Path Sum II]]></title>
    <link href="http://yoursite.com/2016/08/17/113-Path-Sum-II/"/>
    <id>http://yoursite.com/2016/08/17/113-Path-Sum-II/</id>
    <published>2016-08-18T00:25:34.000Z</published>
    <updated>2016-08-18T07:26:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个二叉树和一个sum, 找出所有存在的自根节点到叶节点的路径，如果路径和等于sum</p>
</blockquote>
<p><strong>样例</strong><br>给出如下二叉树和 sum = 22<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">      5&#10;     / \&#10;    4   8&#10;   /   / \&#10;  11  13  4&#10; /  \    / \&#10;7    2  5   1</span><br></pre></td></tr></table></figure></p>
<p>返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;   [5,4,11,2],&#10;   [5,8,4,5]&#10;]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>二叉树遍历</li>
<li>helper函数要保存subSum, path，当节点为根节点而且和等于sum时，向res中添加此刻的path</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type sum: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        self.helper(root, [], <span class="number">0</span>, sum, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, path, subSum, sum, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> subSum + root.val == sum:</span><br><span class="line">                res.append(path + [root.val])</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.helper(root.left, path + [root.val], subSum + root.val, sum, res)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.helper(root.right, path + [root.val], subSum + root.val, sum, res)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个二叉树和一个sum, 找出所有存在的自根节点到叶节点的路径，如果路径和等于sum</p>
</blockquote>
<p><strong>样例</strong><br>给出如下二叉树和 sum = 2]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[112 Path Sum]]></title>
    <link href="http://yoursite.com/2016/08/17/112-Path-Sum/"/>
    <id>http://yoursite.com/2016/08/17/112-Path-Sum/</id>
    <published>2016-08-18T00:14:54.000Z</published>
    <updated>2016-08-18T07:15:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个二叉树和一个sum, 判断是否存在一条自根节点到叶节点路径，使路径和等于sum</p>
</blockquote>
<p><strong>样例</strong><br>给出下面的二叉树 和 sum = 22<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">      5&#10;     / \&#10;    4   8&#10;   /   / \&#10;  11  13  4&#10; /  \      \&#10;7    2      1</span><br></pre></td></tr></table></figure></p>
<p>返回 True 因为5-&gt;4-&gt;11-&gt;2 的和等于22</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>二叉树遍历</li>
<li>如果找到一个根到叶的路径求和，如果等于sum直接返回True</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type sum: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> self.helper(root, <span class="number">0</span>, sum) == <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, subSum, sum)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> subSum + root.val == sum:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> self.helper(root.left, subSum + root.val, sum):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> root.right <span class="keyword">and</span> self.helper(root.right, subSum + root.val, sum):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个二叉树和一个sum, 判断是否存在一条自根节点到叶节点路径，使路径和等于sum</p>
</blockquote>
<p><strong>样例</strong><br>给出下面的二叉树 和 sum = ]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[366 Fibonacci]]></title>
    <link href="http://yoursite.com/2016/08/17/366-Fibonacci/"/>
    <id>http://yoursite.com/2016/08/17/366-Fibonacci/</id>
    <published>2016-08-17T23:12:01.000Z</published>
    <updated>2016-08-18T06:13:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>查找斐波纳契数列中第 N 个数。<br>所谓的斐波纳契数列是指：<br>前2个数是 0 和 1 。<br>第 <em>i</em> 个数是第 <em>i</em>-1 个数和第<em>i</em>-2 个数的和。</p>
<p>斐波纳契数列的前10个数字是：<br>0, 1, 1, 2, 3, 5, 8, 13, 21, 34 …</p>
</blockquote>
<p><strong>样例</strong><br>给定 1，返回 0<br>给定 2，返回 1<br>给定 10，返回 34</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>方法一： 递归求解</li>
<li>方法二：动态规划 - 记忆化搜索</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Method 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n: an integer</span></span><br><span class="line">    <span class="comment"># @return an integer f(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.fibonacci(n - <span class="number">1</span>) + self.fibonacci(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n: an integer</span></span><br><span class="line">    <span class="comment"># @return an integer f(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        T = [<span class="keyword">None</span>] * (n+<span class="number">1</span>)   <span class="comment"># T = [None, None, None, None ......]</span></span><br><span class="line">        T[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        T[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            T[i] = T[i-<span class="number">1</span>] + T[i-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> T[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>查找斐波纳契数列中第 N 个数。<br>所谓的斐波纳契数列是指：<br>前2个数是 0 和 1 。<br>第 <em>i</em> 个数是第 <em>i</em>-1 个数和第<em>i</em>-2 个数的和]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[245 Subtree]]></title>
    <link href="http://yoursite.com/2016/08/17/245-Subtree/"/>
    <id>http://yoursite.com/2016/08/17/245-Subtree/</id>
    <published>2016-08-17T22:19:13.000Z</published>
    <updated>2016-08-18T05:21:02.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>有两个不同大小的二进制树： T1 有上百万的节点； T2 有好几百的节点。请设计一种算法，判定 T2 是否为 T1的子树。</p>
</blockquote>
<p><strong>样例</strong><br>下面的例子中 T2 是 T1 的子树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">       1                3&#10;      / \              / &#10;T1 = 2   3      T2 =  4&#10;        /&#10;       4</span><br></pre></td></tr></table></figure></p>
<p>下面的例子中 T2 不是 T1 的子树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">       1               3&#10;      / \               \&#10;T1 = 2   3       T2 =    4&#10;        /&#10;       4</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>写一个前序遍历，将二叉树扁平化为string</li>
<li>判断string1是不是string2的子串</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param T1, T2: The roots of binary tree.</span></span><br><span class="line">    <span class="comment"># @return: True if T2 is a subtree of T1, or false.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubtree</span><span class="params">(self, T1, T2)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        res = []</span><br><span class="line">        self.get(T1, res)</span><br><span class="line">        s1 = <span class="string">""</span>.join(res)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        self.get(T2, res)</span><br><span class="line">        s2 = <span class="string">""</span>.join(res)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s2 <span class="keyword">in</span> s1</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, root, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            res.append(<span class="string">"#"</span>)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        res.append(str(root.val))</span><br><span class="line">        self.get(root.left, res)</span><br><span class="line">        self.get(root.right, res)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>有两个不同大小的二进制树： T1 有上百万的节点； T2 有好几百的节点。请设计一种算法，判定 T2 是否为 T1的子树。</p>
</blockquote>
<p><strong>样例</strong><br]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[257 Binary Tree Paths]]></title>
    <link href="http://yoursite.com/2016/08/17/257-Binary-Tree-Paths/"/>
    <id>http://yoursite.com/2016/08/17/257-Binary-Tree-Paths/</id>
    <published>2016-08-17T22:13:15.000Z</published>
    <updated>2016-08-18T05:13:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一棵二叉树，找出从根节点到叶子节点的所有路径。</p>
</blockquote>
<p><strong>样例</strong><br>给出下面这棵二叉树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   1&#10; /   \&#10;2     3&#10; \&#10;  5</span><br></pre></td></tr></table></figure></p>
<p>所有根到叶子的路径为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;  &#34;1-&#62;2-&#62;5&#34;,&#10;  &#34;1-&#62;3&#34;&#10;]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>二叉树遍历问题<ul>
<li>如果当前节点的左儿子和右儿子都为None =&gt; 说明当前节点为一个根节点，输出一条路径</li>
<li>如果当前节点有左儿子，带着path向左进行。如果有右儿子，带着path向右进行</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;TreeNode&#125; root</span></span><br><span class="line">    <span class="comment"># @return &#123;string[]&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        self.helper(root, [], res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, path, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            res.append(<span class="string">""</span>.join(path + [str(root.val)]))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.helper(root.left, path + [str(root.val)+<span class="string">"-&gt;"</span>], res)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.helper(root.right, path + [str(root.val)+<span class="string">"-&gt;"</span>], res)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一棵二叉树，找出从根节点到叶子节点的所有路径。</p>
</blockquote>
<p><strong>样例</strong><br>给出下面这棵二叉树：<br><figure class="highlig]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[238 Product of Array Except Self]]></title>
    <link href="http://yoursite.com/2016/08/15/238-Product-of-Array-Except-Self/"/>
    <id>http://yoursite.com/2016/08/15/238-Product-of-Array-Except-Self/</id>
    <published>2016-08-16T02:32:21.000Z</published>
    <updated>2016-08-16T09:32:51.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个整数数组A。<br>定义B[i] = A[0] <em> … </em> A[i-1] <em> A[i+1] </em> … * A[n-1]， 计算B的时候请不要使用除法。</p>
</blockquote>
<p><strong>样例</strong><br>给出A=<strong>[1, 2, 3]</strong>，返回 B为<strong>[6, 3, 2]</strong></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>求出数组中每一个位置左边的乘积和右边的乘积</li>
<li>最后遍历每一个位置，把左右乘积相乘</li>
<li>时间复杂度O(n) - 扫两遍，或者可以扫三遍</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        p = <span class="number">1</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n):</span><br><span class="line">            output.append(p)</span><br><span class="line">            p = p * nums[i]</span><br><span class="line">        p = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            output[i] = output[i] * p</span><br><span class="line">            p = p * nums[i]</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个整数数组A。<br>定义B[i] = A[0] <em> … </em> A[i-1] <em> A[i+1] </em> … * A[n-1]， 计算B的时候请不要使用除法。</p>
</blockq]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[280 Wiggle Sort]]></title>
    <link href="http://yoursite.com/2016/08/09/280-Wiggle-Sort/"/>
    <id>http://yoursite.com/2016/08/09/280-Wiggle-Sort/</id>
    <published>2016-08-09T23:30:03.000Z</published>
    <updated>2016-08-10T06:30:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给你一个没有排序的数组，请将原数组就地重新排列满足如下性质<br>nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]….</p>
</blockquote>
<p><strong>样例</strong><br>给出数组为 <em>nums</em> = [3, 5, 2, 1, 6, 4] 一种输出方案为[1, 6, 2, 5, 3, 4]</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>根据题意，摇摆排序的定义有两部分：<ul>
<li>如果i是奇数，nums[i] &gt;= nums[i - 1]</li>
<li>如果i是偶数，nums[i] &lt;= nums[i - 1]</li>
</ul>
</li>
<li>所以遍历一遍，将错误的进行调整就可以了</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param &#123;int[]&#125; nums a list of integer</span><br><span class="line">    @return nothing, modify nums in-place instead</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wiggleSort</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> nums[i] &lt; nums[i - <span class="number">1</span>] <span class="keyword">or</span> \</span><br><span class="line">                i % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> nums[i] &gt; nums[i - <span class="number">1</span>]:</span><br><span class="line">                nums[i], nums[i - <span class="number">1</span>] = nums[i- <span class="number">1</span>], nums[i]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给你一个没有排序的数组，请将原数组就地重新排列满足如下性质<br>nums[0] &lt;= nums[1] &gt;= nums[2] &lt;= nums[3]….</p>
</blockquote>
<p]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[66 Plus One]]></title>
    <link href="http://yoursite.com/2016/08/08/66-Plus-One/"/>
    <id>http://yoursite.com/2016/08/08/66-Plus-One/</id>
    <published>2016-08-09T03:07:24.000Z</published>
    <updated>2016-08-09T10:12:16.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个非负数，表示一个数字数组，在该数的基础上+1，返回一个新的数组。<br>该数字按照大小进行排列，最大的数在列表的最前面。</p>
</blockquote>
<p><strong>样例</strong><br>给定 [1,2,3] 表示 123, 返回 [1,2,4].<br>给定 [9,9,9] 表示 999, 返回 [1,0,0,0].</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>模拟十进制进位加法</li>
<li>定义一个carry，初始为1。如carry等于1当前数组为加1，判断是否超过9</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type digits: List[int]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        carry = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(digits) - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> carry == <span class="number">1</span>:</span><br><span class="line">                digits[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> digits[i] &gt; <span class="number">9</span>:</span><br><span class="line">            	    carry = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    carry = <span class="number">0</span></span><br><span class="line">            	    <span class="keyword">break</span></span><br><span class="line">            digits[i] = digits[i] % <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> carry == <span class="number">1</span>:</span><br><span class="line">            digits.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个非负数，表示一个数字数组，在该数的基础上+1，返回一个新的数组。<br>该数字按照大小进行排列，最大的数在列表的最前面。</p>
</blockquote>
<p><strong>样例</strong>]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[26 Remove Duplicates from Sorted Array]]></title>
    <link href="http://yoursite.com/2016/08/08/26-Remove-Duplicates-from-Sorted-Array/"/>
    <id>http://yoursite.com/2016/08/08/26-Remove-Duplicates-from-Sorted-Array/</id>
    <published>2016-08-09T02:28:51.000Z</published>
    <updated>2016-08-09T09:29:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个排序数组，在原数组中删除重复出现的数字，使得每个元素只出现一次，并且返回新的数组的长度。<br>不要使用额外的数组空间，必须在原地没有额外空间的条件下完成。</p>
</blockquote>
<p><strong>样例</strong><br>给出数组A =<strong>[1,1,2]</strong>，你的函数应该返回长度2，此时A=<strong>[1,2]</strong>。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>使用一个指针length记录当前位置，即该写入到哪里</li>
<li>使用一个prev记录之前的值，每次比较：<ul>
<li>如果与之前的值不同，把当前值写入length的位置，length += 1</li>
<li>如果与之前值相同，继续</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        prev = <span class="keyword">None</span></span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num != prev:</span><br><span class="line">                prev = num</span><br><span class="line">                nums[length] = num</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> length</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个排序数组，在原数组中删除重复出现的数字，使得每个元素只出现一次，并且返回新的数组的长度。<br>不要使用额外的数组空间，必须在原地没有额外空间的条件下完成。</p>
</blockquote>
<p><]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[27 Remove Element]]></title>
    <link href="http://yoursite.com/2016/08/07/27-Remove-Element/"/>
    <id>http://yoursite.com/2016/08/07/27-Remove-Element/</id>
    <published>2016-08-08T01:55:04.000Z</published>
    <updated>2016-08-08T08:56:20.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个数组和一个值，在原地删除与值相同的数字，返回新数组的长度。<br>元素的顺序可以改变，并且对新的数组不会有影响。</p>
</blockquote>
<p><strong>样例</strong><br>给出一个数组<strong> [0,4,4,0,0,2,4,4]</strong>，和值 4<br>返回 4 并且4个元素的新数组为<strong>[0,0,0,2]</strong></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>两根指针 - 对撞型指针，一前一后</li>
<li>pythonic way</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Method 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type val: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> nums[l] == val:</span><br><span class="line">                nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type val: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">while</span> val <span class="keyword">in</span> nums:</span><br><span class="line">            nums.remove(val)</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个数组和一个值，在原地删除与值相同的数字，返回新数组的长度。<br>元素的顺序可以改变，并且对新的数组不会有影响。</p>
</blockquote>
<p><strong>样例</strong><br>]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[260 Single Number III]]></title>
    <link href="http://yoursite.com/2016/08/07/260-Single-Number-III/"/>
    <id>http://yoursite.com/2016/08/07/260-Single-Number-III/</id>
    <published>2016-08-08T01:13:22.000Z</published>
    <updated>2016-08-08T08:13:52.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出2*n + 2个的数字，除其中两个数字之外其他每个数字均出现两次，找到这两个数字。</p>
</blockquote>
<p><strong>样例</strong><br>给出 <strong>[1,2,2,3,4,4,5,3]</strong>，返回 1和5</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>首先，通过位运算 - 异或之后，可以求出出现次数为1的两个数的异或结果，如本例中1和5的异或结果，但是根据异或结果不能反推原来的两个数是什么</li>
<li>但是我们可以通过求出lastBit 把原来的数组分成两部分，一部分含有1一部分含有5，分别采用single number I的做法就可以求出这两个数字</li>
<li><p>下面举例子如何求出左边数的第一个1，即给出10011100110 返回 00000000010</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">15 -&gt; 1111 | 5 -&gt; 0101 所以 15 ^ 5 = 1010 希望得到 0010</span><br><span class="line">xor - (xor &amp; xor - 1) = 1010 - (1010 &amp; 1010 - 1)</span><br><span class="line">                        = 1010 - (1010 &amp; 1001)</span><br><span class="line">                        = 1010 - 1000</span><br><span class="line">                        = 0010</span><br></pre></td></tr></table></figure>
</li>
<li><p>x &amp; x - 1的操作相当于把左边数第一个1的数变为0，因为2的某次方一定是10…000，所以<code>x &amp; x - 1 == 0</code> 可以判断一个数是不是2的某次方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>xxx...xxxx100 </span><br><span class="line">x - <span class="number">1</span> = <span class="number">1</span>xxx...xxxx011</span><br><span class="line">x &amp; (x - <span class="number">1</span>) = <span class="number">1</span>xxx...xxx000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">          </span><br><span class="line">        xor = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> nums:</span><br><span class="line">            xor ^= item</span><br><span class="line">        </span><br><span class="line">        lastBit = xor - (xor &amp; xor - <span class="number">1</span>)    </span><br><span class="line">        group1, group2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> lastBit &amp; item == <span class="number">0</span>:</span><br><span class="line">                group1 ^= item</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                group2 ^= item</span><br><span class="line">                </span><br><span class="line">        res = []</span><br><span class="line">        res.append(group1)</span><br><span class="line">        res.append(group2)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出2*n + 2个的数字，除其中两个数字之外其他每个数字均出现两次，找到这两个数字。</p>
</blockquote>
<p><strong>样例</strong><br>给出 <strong>[1,2,2]]>
    </summary>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[137 Single Number II]]></title>
    <link href="http://yoursite.com/2016/08/07/137-Single-Number-II/"/>
    <id>http://yoursite.com/2016/08/07/137-Single-Number-II/</id>
    <published>2016-08-07T23:28:23.000Z</published>
    <updated>2016-08-08T07:38:09.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出3*n + 1 个的数字，除其中一个数字之外其他每个数字均出现三次，找到这个数字。</p>
</blockquote>
<p><strong>样例</strong><br>给出<strong> [1,1,2,3,3,3,2,2,4,1]</strong> ，返回 4</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>方法一：三进制不进位加法，比如02 + 01 = 00 (2+1=3做加法不进位)。所以同一个数，比如7的三进制表示为21，21+21+21 = 00 即十进制下的0。最终代码即统计每一位上1，对3取模</li>
<li>方法二：分别统计，记录出现一次，两次，三次的数</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        ones, twos, threes = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> A:</span><br><span class="line">            twos |= ones &amp; item</span><br><span class="line">            ones ^= item</span><br><span class="line">            threes = ones &amp; twos</span><br><span class="line"></span><br><span class="line">            ones ^= threes         </span><br><span class="line">            twos ^= threes         </span><br><span class="line">        <span class="keyword">return</span> ones</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出3*n + 1 个的数字，除其中一个数字之外其他每个数字均出现三次，找到这个数字。</p>
</blockquote>
<p><strong>样例</strong><br>给出<strong> [1,1,2]]>
    </summary>
    
      <category term="Bit Manipulation" scheme="http://yoursite.com/tags/Bit-Manipulation/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
</feed>
