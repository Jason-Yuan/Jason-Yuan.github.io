<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Chemistry]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-11-02T08:52:24.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Jason Yuan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[139 Word Break]]></title>
    <link href="http://yoursite.com/2015/11/01/139-Word-Break/"/>
    <id>http://yoursite.com/2015/11/01/139-Word-Break/</id>
    <published>2015-11-02T00:51:09.000Z</published>
    <updated>2015-11-02T08:52:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个字符串s和一个词典，判断字符串s是否可以被空格切分成一个或多个出现在字典中的单词。</p>
</blockquote>
<p>给出<br>s = <strong>“leetcode”</strong><br>dict = <strong>[“leet”,”code”]</strong><br>返回 true 因为<strong>“leetcode”</strong>可以被空格切分成<strong>“leet code”</strong></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>动态规划是一种解决问题的思想 - 大规模问题的结果，是由小规模问题的结果运算得来的</li>
<li><strong>动态规划不等同于递归，动态规划思想可以由递归来实现</strong></li>
<li>DP初始化时一般要有个<code>1</code>或者<code>true</code></li>
<li>本题属于序列型动态规划 - Sequence DP</li>
<li><code>cache[i]</code>表示前<code>i</code>个字符能不能被<code>dict</code>完美划分</li>
<li>判断<code>cache[i]</code>，则需要遍历<code>0~i</code>中是否存在一个<code>j</code>，使得<code>cache[j]=true</code>而且<code>j+1~i</code>存在于<code>dict</code>中</li>
<li>本题还有一个值得注意的地方，<strong>一定要考虑到单词长度是有上限的！</strong>，所以每次不需要遍历<code>0~i</code>而是<code>x~i</code>(i-x为单词最大长度)</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type wordDict: Set[str]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> wordDict:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        maxLength = self.getMaxLength(wordDict)</span><br><span class="line">        cache = [<span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) + <span class="number">1</span>)]</span><br><span class="line">        cache[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= maxLength <span class="keyword">and</span> j &lt;= i:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cache[i - j]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> s[i - j:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    cache[i] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> cache[len(s)]</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxLength</span><span class="params">(self, dict)</span>:</span></span><br><span class="line">        maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> dict:</span><br><span class="line">            maxLength = max(len(word), maxLength)</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个字符串s和一个词典，判断字符串s是否可以被空格切分成一个或多个出现在字典中的单词。</p>
</blockquote>
<p>给出<br>s = <strong>“leetcode”</strong><]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sequence DP" scheme="http://yoursite.com/tags/Sequence-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[76 Longest Increasing Subsequence]]></title>
    <link href="http://yoursite.com/2015/10/31/76-Longest-Increasing-Subsequence/"/>
    <id>http://yoursite.com/2015/10/31/76-Longest-Increasing-Subsequence/</id>
    <published>2015-10-31T20:14:09.000Z</published>
    <updated>2015-11-01T03:15:10.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。</p>
</blockquote>
<p>给出<strong>[5,4,1,2,3]</strong>，这个LIS是<strong>[1,2,3]</strong>，返回 3<br>给出<strong>[4,2,4,5,3,7]</strong>，这个LIS是<strong>[4,4,5,7]</strong>，返回 4</p>
<p>最长上升子序列问题是在一个无序的给定序列中找到一个尽可能长的由低到高排列的子序列，这种子序列不一定是连续的或者唯一的。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>序列型动态规划 - Sequence DP</li>
<li>判定条件：序列非集合，求最长</li>
<li><code>cache[i]</code>表示以i结尾的最长子序列的长度</li>
<li>每次遍历<code>0 ~ i-1</code>如果存在<code>nums[x] &lt; nums[i]</code>并且<code>cache[x] + 1 &gt; cache[i]</code>则更新</li>
<li>for循环中维护一个<code>res</code>，即最大值</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param nums: The integer array</span><br><span class="line">    @return: The length of LIS (longest increasing subsequence)</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingSubsequence</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        cache = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt;= nums[i]:</span><br><span class="line">                    <span class="keyword">if</span> cache[j] + <span class="number">1</span> &gt; cache[i]:</span><br><span class="line">                        cache[i] = cache[j] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cache[i] &gt; res:</span><br><span class="line">                res = cache[i]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。</p>
</blockquote>
<p>给出<strong>[5,4,1,2,3]</strong>，这个LIS是<strong>[1,2,]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Sequence DP" scheme="http://yoursite.com/tags/Sequence-DP/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[45 Jump Game II]]></title>
    <link href="http://yoursite.com/2015/10/31/45-Jump-Game-II/"/>
    <id>http://yoursite.com/2015/10/31/45-Jump-Game-II/</id>
    <published>2015-10-31T19:37:41.000Z</published>
    <updated>2015-11-01T02:39:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个非负整数数组，你最初定位在数组的第一个位置。<br>数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
</blockquote>
<p>给出数组A =<strong> [2,3,1,1,4]</strong>，最少到达数组最后一个位置的跳跃次数是2(从数组下标0跳一步到数组下标1，然后跳3步到数组的最后一个位置，一共跳跃2次)</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>方法一：贪心(Greedy)<ul>
<li>维护一个<code>farthest</code>变量，每次在遍历<code>start</code>到<code>end</code>之间的元素，尝试更新<code>farthest</code>变量</li>
<li><code>start = end + 1</code></li>
<li><code>end = farthest</code></li>
<li>比较<code>end</code>时候大于数组长度，大于返回结果，否则<code>steps += 1</code></li>
</ul>
</li>
<li>方法二：动态规划(领会思路，OJ会超时)<ul>
<li>开辟一个<code>steps</code>数组长度与<code>input</code>数组相同，初始值为<code>maxint</code></li>
<li><code>steps[0] = 0</code></li>
<li><code>steps[i]</code>等于遍历<code>steps[0]</code> ~ <code>steps[i-1]</code>，如果存在<code>nums[x] + x &gt; i</code>，则更新<code>steps[i] = steps[x] + 1</code></li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：贪心</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        start, end, steps = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; len(nums) - <span class="number">1</span>:</span><br><span class="line">            steps += <span class="number">1</span></span><br><span class="line">            farthest = end</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + i &gt; farthest:</span><br><span class="line">                    farthest = nums[i] + i</span><br><span class="line">            start = end + <span class="number">1</span></span><br><span class="line">            end = farthest</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> steps</span><br><span class="line"><span class="comment"># 方法二：动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        steps = [sys.maxint <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        </span><br><span class="line">        steps[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> steps[j] != sys.maxint <span class="keyword">and</span> j + nums[j] &gt;= i:</span><br><span class="line">                    steps[i] = steps[j] + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> steps[len(nums) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个非负整数数组，你最初定位在数组的第一个位置。<br>数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
</blockquot]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[183 Wood Cut]]></title>
    <link href="http://yoursite.com/2015/10/31/183-Wood-Cut/"/>
    <id>http://yoursite.com/2015/10/31/183-Wood-Cut/</id>
    <published>2015-10-31T18:38:50.000Z</published>
    <updated>2015-11-01T01:39:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>有一些原木，现在想把这些木头切割成一些长度相同的小段木头，需要得到的小段的数目至少为 k。当然，我们希望得到的小段越长越好，你需要计算能够得到的小段木头的最大长度。</p>
</blockquote>
<p>有3根木头[232, 124, 456], k=7, 最大长度为114.</p>
<p>木头长度的单位是厘米。原木的长度都是正整数，我们要求切割得到的小段木头的长度也要求是整数。无法切出要求至少 k 段的,则返回 0 即可。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>思路：<strong>Binary Search</strong></li>
<li>问题又可以转化成在1和给的所有原木中最长的长度中间找一个合适的长度，使得把每段原木按此分段后得到的小段木头数目至少为k</li>
<li>扩展，<strong>除法转化为二分法</strong>，求100除以5，相当于在0到100之间找一个数使得x<em>5小于等于100，(x+1)\</em>5大于100</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param L: Given n pieces of wood with length L[i]</span><br><span class="line">    @param k: An integer</span><br><span class="line">    return: The maximum length of the small pieces.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">woodCut</span><span class="params">(self, L, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sum(L) &lt; k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        start, end = <span class="number">1</span>, max(L)</span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            pieces = sum([l / mid <span class="keyword">for</span> l <span class="keyword">in</span> L])</span><br><span class="line">            <span class="keyword">if</span> pieces &gt;= k:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> sum([l / end <span class="keyword">for</span> l <span class="keyword">in</span> L]) &gt; k:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>有一些原木，现在想把这些木头切割成一些长度相同的小段木头，需要得到的小段的数目至少为 k。当然，我们希望得到的小段越长越好，你需要计算能够得到的小段木头的最大长度。</p>
</blockquote>
<p>有]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[41 First Missing Positive]]></title>
    <link href="http://yoursite.com/2015/10/31/41-First-Missing-Positive/"/>
    <id>http://yoursite.com/2015/10/31/41-First-Missing-Positive/</id>
    <published>2015-10-31T18:18:29.000Z</published>
    <updated>2015-11-01T01:19:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个无序的正数数组，找出其中没有出现的最小正整数。</p>
</blockquote>
<p>如果给出 [1,2,0], return 3 如果给出 [3,4,-1,1], return 2<br>只允许时间复杂度O(n)的算法，并且只能使用常数级别的空间。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>类似于<strong>桶排序的思路</strong>，对于每一个整数，我们按照一定的规则放到相应的位置上，最后再去检查如果指定位置的数不存在，即为没有出现的最小正整数</li>
<li>规则：1放在array[0]，2放在array[1]，以此类推<br>对于[3, 4, -1, 1]，运行最终结果为[1, -1, 3, 4]所以检查到array[1]时，2不存在，2即为没有出现的最小正整数</li>
<li>注意，遍历数组是，对于每一位要while循环至该位置的数字放到正确的位置为止<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> nums[i] &lt;= len(nums) <span class="keyword">and</span> nums[i] &gt; <span class="number">0</span> <span class="keyword">and</span> nums[nums[i] - <span class="number">1</span>] != nums[i]:</span><br><span class="line">    nums[nums[i] - <span class="number">1</span>], nums[i] = nums[i], nums[nums[i] - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">while</span> nums[i] &lt;= len(nums) <span class="keyword">and</span> nums[i] &gt; <span class="number">0</span> <span class="keyword">and</span> nums[nums[i] - <span class="number">1</span>] != nums[i]:</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>], nums[i] = nums[i], nums[nums[i] - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums) + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个无序的正数数组，找出其中没有出现的最小正整数。</p>
</blockquote>
<p>如果给出 [1,2,0], return 3 如果给出 [3,4,-1,1], return 2<br>只允许时]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[49 Group Anagrams]]></title>
    <link href="http://yoursite.com/2015/10/31/49-Group-Anagrams/"/>
    <id>http://yoursite.com/2015/10/31/49-Group-Anagrams/</id>
    <published>2015-10-31T17:43:31.000Z</published>
    <updated>2015-11-01T00:46:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个字符串数组S，找到其中所有的乱序字符串(Anagram)。如果一个字符串是乱序字符串，那么他存在一个字母集合相同，但顺序不同的字符串也在S中。</p>
</blockquote>
<p>对于字符串数组 [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;&#160; [&#34;ate&#34;, &#34;eat&#34;,&#34;tea&#34;],&#10;&#160; [&#34;nat&#34;,&#34;tan&#34;],&#10;&#160; [&#34;bat&#34;]&#10;]</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>首先，注意返回结果中，子字符串数组内要保持有序，所以第一步先把strs排序</li>
<li>本题考察使用hashtable，与直接判断两个字符串是否是anagram不同，遍历一遍字符串数组，将<strong>排序的字符串作为key</strong>，把原始字符串作为value</li>
<li>最后遍历hashtable生成结果</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        """</span></span><br><span class="line">        strs.sort()</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> str <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">""</span>.join(sorted(str)) <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[<span class="string">""</span>.join(sorted(str))] = [str]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[<span class="string">""</span>.join(sorted(str))].append(str)</span><br><span class="line">                </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">            res.append(value)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个字符串数组S，找到其中所有的乱序字符串(Anagram)。如果一个字符串是乱序字符串，那么他存在一个字母集合相同，但顺序不同的字符串也在S中。</p>
</blockquote>
<p>对于字符串数组 ]]>
    </summary>
    
      <category term="Hash" scheme="http://yoursite.com/tags/Hash/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[55 Jump Game]]></title>
    <link href="http://yoursite.com/2015/10/25/55-Jump-Game/"/>
    <id>http://yoursite.com/2015/10/25/55-Jump-Game/</id>
    <published>2015-10-26T03:34:39.000Z</published>
    <updated>2015-10-26T10:35:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个非负整数数组，你最初定位在数组的第一个位置。　　　<br>数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　　<br>判断你是否能到达数组的最后一个位置。</p>
</blockquote>
<p>A =<strong> [2,3,1,1,4]</strong>，返回 true.<br>A =<strong> [3,2,1,0,4]</strong>，返回 false.</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>方法一：贪心法 greedy</li>
<li>方法二：单序列型动态规划 - Sequence DP (因为题目中给的是序列而不是数组，注意两者的区别)，本题动归的方法不能过OJ</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一，贪心</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        farest = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &lt;= farest <span class="keyword">and</span> nums[i] + i &gt; farest:</span><br><span class="line">                farest = nums[i] + i</span><br><span class="line">            <span class="keyword">if</span> farest &gt;= len(nums) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二，动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        cache = [<span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        cache[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> cache[j] <span class="keyword">is</span> <span class="keyword">True</span> <span class="keyword">and</span> j + nums[j] &gt;= i:</span><br><span class="line">                    cache[i] == <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> cache[len(nums) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个非负整数数组，你最初定位在数组的第一个位置。　　　<br>数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　　<br>判断你是否能到达数组的最后一个位置。</p>
</blockquote>
<]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sequence DP" scheme="http://yoursite.com/tags/Sequence-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[120 Triangle]]></title>
    <link href="http://yoursite.com/2015/10/25/120-Triangle/"/>
    <id>http://yoursite.com/2015/10/25/120-Triangle/</id>
    <published>2015-10-26T03:02:53.000Z</published>
    <updated>2015-10-26T10:03:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。</p>
</blockquote>
<p>比如，给出下列数字三角形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;&#160; &#160; &#160;[2],&#10;  &#160; [3,4],&#10;&#160; &#160;[6,5,7],&#10;&#160; [4,1,8,3]&#10;]</span><br></pre></td></tr></table></figure></p>
<p>从顶到底部的最小路径和为11 (<strong> 2 + 3 + 5 + 1 = 11</strong>)。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>矩阵型动态规划问题 - Matrix DP</li>
<li>有两种解决方案，自顶向下或者自底向上</li>
<li>下面代码采用自底向上的方法，cache[i][j]表明从最底层到i,j所用的最短距离是多少</li>
<li><code>cache[i][j]</code>就等于<code>cache[i+1][j]</code>(左下角)与<code>cache[i+1][j+1]</code>(右下角)中最小的加上<code>triangle[i][j]</code>的值</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type triangle: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> triangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        m = len(triangle)</span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            cache[m - <span class="number">1</span>][i] = triangle[m - <span class="number">1</span>][i]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m - i):</span><br><span class="line">                cache[m - <span class="number">1</span> - i][j] = min(cache[m - i][j], cache[m - i][j + <span class="number">1</span>]) + triangle[m - <span class="number">1</span> - i][j]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> cache[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。</p>
</blockquote>
<p>比如，给出下列数字三角形：<br><figure class="highlig]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Matrix DP" scheme="http://yoursite.com/tags/Matrix-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[64 Minimum Path Sum]]></title>
    <link href="http://yoursite.com/2015/10/24/64-Minimum-Path-Sum/"/>
    <id>http://yoursite.com/2015/10/24/64-Minimum-Path-Sum/</id>
    <published>2015-10-25T03:32:25.000Z</published>
    <updated>2015-10-25T10:33:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。</p>
</blockquote>
<p>你在同一时间只能向下或者向右移动一步</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>矩阵型动态规划 - Matrix DP</li>
<li>与Unique Paths I/II非常类似，不同的是每次要找最小value</li>
<li>cache[i][j]表示从左上角到达i,j的数字和最小路径，它等于cache[i][j - 1]与cache[i - 1][j]的最小值，加上grid[i][j]的值</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type grid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">        sum1 = sum2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum1 += grid[<span class="number">0</span>][i]</span><br><span class="line">            cache[<span class="number">0</span>][i] = sum1</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            sum2 += grid[j][<span class="number">0</span>]</span><br><span class="line">            cache[j][<span class="number">0</span>] = sum2</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">                cache[j][i] = min(cache[j - <span class="number">1</span>][i], cache[j][i - <span class="number">1</span>]) + grid[j][i]</span><br><span class="line">        <span class="keyword">return</span> cache[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。</p>
</blockquote>
<p>你在同一时间只能向下或者向右移动一步</p>
<h1 id="解题思路">解题思路]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Matrix DP" scheme="http://yoursite.com/tags/Matrix-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[70 Climbing Stairs]]></title>
    <link href="http://yoursite.com/2015/10/24/70-Climbing-Stairs/"/>
    <id>http://yoursite.com/2015/10/24/70-Climbing-Stairs/</id>
    <published>2015-10-25T03:20:40.000Z</published>
    <updated>2015-10-25T10:21:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？</p>
</blockquote>
<p>比如n=3，1+1+1=1+2=2+1=3，共有3中不同的方法<br>返回 3</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>本题本质和菲波那切数列问题非常相似</li>
<li>单序列型动态规划问题 - Sequence DP</li>
<li>cache[i]表示有i个台阶，能跳到第i个台阶的方案个数</li>
<li>因为每次可以跳一步或者跳两步，所以cache[i]就等于下面的和<ul>
<li>可以跳的i - 1的方案个数即cache[i - 1]</li>
<li>可以跳到i - 2的方案个数即cache[i - 2]</li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        cache = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        cache[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        cache[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            cache[i] = cache[i - <span class="number">1</span>] + cache[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> cache[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？</p>
</blockquote>
<p>比如n=3，1+1+1=1+2=2+1=3，共有3中不同的方法]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sequence DP" scheme="http://yoursite.com/tags/Sequence-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[63 Unique Paths II]]></title>
    <link href="http://yoursite.com/2015/10/24/63-Unique-Paths-II/"/>
    <id>http://yoursite.com/2015/10/24/63-Unique-Paths-II/</id>
    <published>2015-10-25T02:18:09.000Z</published>
    <updated>2015-10-25T09:18:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>现在考虑网格中有障碍物，那样将会有多少条不同的路径？<br>网格中的障碍和空位置分别用<strong>1</strong>和<strong>0</strong>来表示。</p>
</blockquote>
<p>如下所示在3x3的网格中有一个障碍物：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;&#160; [0,0,0],&#10;&#160; [0,1,0],&#10;&#160; [0,0,0]&#10;]</span><br></pre></td></tr></table></figure></p>
<p>一共有2条不同的路径从左上角到右下角。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>同样是矩阵型动态规划 - Matrix DP</li>
<li>对于有障碍物的地图来说，只需要把<strong>障碍物的坐标设为0即可</strong></li>
<li>要注意对第一行和第一列的初始化，如果遇到障碍物第一行后面和第一列下面都是0</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type obstacleGrid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid <span class="keyword">or</span> <span class="keyword">not</span> obstacleGrid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(obstacleGrid)</span><br><span class="line">        n = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">        flag1 = flag2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m): </span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[j][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                flag1 = <span class="number">0</span></span><br><span class="line">            cache[j][<span class="number">0</span>] = flag1</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>:</span><br><span class="line">                flag2 = <span class="number">0</span></span><br><span class="line">            cache[<span class="number">0</span>][i] = flag2</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                cache[j][i] = (cache[j - <span class="number">1</span>][i] + cache[j][i - <span class="number">1</span>]) <span class="keyword">if</span> obstacleGrid[j][i] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> cache[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>现在考虑网格中有障碍物，那样将会有多少条不同的路径？<br>网格中的障碍和空位置分别用<strong>1</strong>和<strong>0</strong>来表示。</p>
</blockquote>
<p]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Matrix DP" scheme="http://yoursite.com/tags/Matrix-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[62 Unique Paths]]></title>
    <link href="http://yoursite.com/2015/10/24/62-Unique-Paths/"/>
    <id>http://yoursite.com/2015/10/24/62-Unique-Paths/</id>
    <published>2015-10-25T01:52:40.000Z</published>
    <updated>2015-10-25T08:59:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>有一个机器人的位于一个M×N个网格左上角（下图中标记为’Start’）。<br>机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角（下图中标记为’Finish’）。<br>问有多少条不同的路径？</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">1, 1</th>
<th style="text-align:center">1, 2</th>
<th style="text-align:center">1, 3</th>
<th style="text-align:center">1, 4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2, 1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">3, 1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">4, 1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">4, 4</td>
</tr>
</tbody>
</table>
<p>以上4 x 4的网格中，有多少条不同的路径？</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>动态规划就是解决了重复计算，具体实现方式有：<ul>
<li>记忆化搜索</li>
<li>循环求解(本题采用此方法)</li>
</ul>
</li>
<li>典型DP问题 - <strong>矩阵型动态规划</strong>(Matrix DP)</li>
<li><code>cache[x][y]</code>表示从起点到<code>x,y</code>的路径数，等于<code>cache[x][y - 1]</code>与<code>cache[x - 1][y]</code>的路径数之和</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type m: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> m &lt; <span class="number">1</span> <span class="keyword">or</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            cache[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            cache[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">                cache[i][j] = cache[i - <span class="number">1</span>][j] + cache[i][j - <span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> cache[n - <span class="number">1</span>][m - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>有一个机器人的位于一个M×N个网格左上角（下图中标记为’Start’）。<br>机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角（下图中标记为’Finish’）。<br>问有多少条不同的路径？]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Matrix DP" scheme="http://yoursite.com/tags/Matrix-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[94 Binary Tree Inorder Traversal]]></title>
    <link href="http://yoursite.com/2015/10/21/94-Binary-Tree-Inorder-Traversal/"/>
    <id>http://yoursite.com/2015/10/21/94-Binary-Tree-Inorder-Traversal/</id>
    <published>2015-10-22T02:58:13.000Z</published>
    <updated>2015-10-22T09:59:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树,返回其中序遍历</p>
</blockquote>
<p>给出二叉树 {1,#,2,3}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160;&#160; 1&#10;&#160; &#160; \&#10;&#160;&#160; &#160; 2&#10;&#160; &#160; /&#10;&#160;&#160; 3</span><br></pre></td></tr></table></figure></p>
<p>返回 [1,3,2]</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>方法一：递归，定义helper函数</li>
<li>方法二：Divide &amp; Conquer</li>
<li>方法二：非递归<ul>
<li>(操作一)每一次从当前节点开始(第一次是root节点)遍历至最左节点，一次入栈。</li>
<li>(操作二)pop出栈一个node，node.val加入到结果，然后看该node有没有右儿子</li>
<li>有的话重复操作一</li>
<li>没有的话，继续pop出栈一个node，重复操作二</li>
</ul>
</li>
<li>非递归解法可以体会一下另外一个题[Inorder Successor in Binary Search Tree]</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        self.helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">            self.helper(root.left, result)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">            self.helper(root.right, result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># divide</span></span><br><span class="line">        left = self.inorderTraversal(root.left)</span><br><span class="line">        right = self.inorderTraversal(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># conquer</span></span><br><span class="line">        <span class="keyword">return</span> left + result + right</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        result = []</span><br><span class="line">        current = root</span><br><span class="line">        <span class="keyword">while</span> current != <span class="keyword">None</span> <span class="keyword">or</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> current != <span class="keyword">None</span>:</span><br><span class="line">                stack.append(current)</span><br><span class="line">                current = current.left</span><br><span class="line">            current = stack[-<span class="number">1</span>];</span><br><span class="line">            stack.pop();</span><br><span class="line">            result.append(current.val);</span><br><span class="line">            current = current.right;</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树,返回其中序遍历</p>
</blockquote>
<p>给出二叉树 {1,#,2,3}<br><figure class="highlight plain"><table><tr><td cl]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Non-recursion" scheme="http://yoursite.com/tags/Non-recursion/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[145 Binary Tree Postorder Traversal]]></title>
    <link href="http://yoursite.com/2015/10/21/145-Binary-Tree-Postorder-Traversal/"/>
    <id>http://yoursite.com/2015/10/21/145-Binary-Tree-Postorder-Traversal/</id>
    <published>2015-10-22T02:42:32.000Z</published>
    <updated>2015-10-27T09:04:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树，返回其节点值的后序遍历。</p>
</blockquote>
<p>给出一棵二叉树 {1,#,2,3}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160;&#160; 1&#10;&#160; &#160; \&#10;&#160;&#160; &#160; 2&#10;&#160; &#160; /&#10;&#160;&#160; 3</span><br></pre></td></tr></table></figure></p>
<p>返回 [3,2,1]</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>递归求解，定义一个helper函数，定义一个result全局变量，传入helper函数</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root: The root of binary tree.</span><br><span class="line">    @return: Postorder in ArrayList which contains node values.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.helper(root.left, result)</span><br><span class="line">            self.helper(root.right, result)</span><br><span class="line">            result.append(root.val)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树，返回其节点值的后序遍历。</p>
</blockquote>
<p>给出一棵二叉树 {1,#,2,3}<br><figure class="highlight plain"><table><tr]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[85 Insert Node in a Binary Search Tree]]></title>
    <link href="http://yoursite.com/2015/10/21/85-Insert-Node-in-a-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2015/10/21/85-Insert-Node-in-a-Binary-Search-Tree/</id>
    <published>2015-10-22T02:35:26.000Z</published>
    <updated>2015-10-22T09:35:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一棵二叉查找树和一个新的树节点，将节点插入到树中。<br>你需要保证该树仍然是一棵二叉查找树。</p>
</blockquote>
<p>给出如下一棵二叉查找树，在插入节点6之后这棵二叉查找树可以是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; 2 &#160; &#160; &#160; &#160; &#160; &#160; 2&#10;&#160;/ \ &#160; &#160; &#160; &#160; &#160; / \&#10;1 &#160; 4 &#160; --&#62; &#160; 1 &#160; 4&#10;&#160;&#160; / &#160; &#160; &#160; &#160; &#160; &#160; / \&#160;&#10;&#160; 3 &#160; &#160; &#160; &#160; &#160; &#160; 3 &#160; 6</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>如果root为空，给root赋值</li>
<li>root不为空，根据root.val与node.val的大小去判断往左儿子走还是右儿子走</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root: The root of the binary search tree.</span><br><span class="line">    @param node: insert this node into the binary search tree.</span><br><span class="line">    @return: The root of the new binary search tree.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertNode</span><span class="params">(self, root, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            root = node</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; node.val:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                self.insertNode(root.left, node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.left = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                self.insertNode(root.right, node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.right = node</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一棵二叉查找树和一个新的树节点，将节点插入到树中。<br>你需要保证该树仍然是一棵二叉查找树。</p>
</blockquote>
<p>给出如下一棵二叉查找树，在插入节点6之后这棵二叉查找树可以是这样的：]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[111 Minimum Depth of Binary Tree]]></title>
    <link href="http://yoursite.com/2015/10/21/111-Minimum-Depth-of-Binary-Tree/"/>
    <id>http://yoursite.com/2015/10/21/111-Minimum-Depth-of-Binary-Tree/</id>
    <published>2015-10-22T01:40:09.000Z</published>
    <updated>2015-10-22T08:40:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个二叉树，找出其最小深度。<br>二叉树的最小深度为根节点到最近叶子节点的距离。</p>
</blockquote>
<p>给出一棵如下的二叉树:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; &#160; &#160; &#160; 1&#10;&#160; &#160; &#160;/ &#160; &#160; \&#160;&#10;&#160; &#160;2 &#160; &#160; &#160; 3&#10;&#160; &#160; &#160; &#160; &#160; / &#160; &#160;\&#10;&#160; &#160; &#160; &#160; 4 &#160; &#160; &#160;5</span><br></pre></td></tr></table></figure></p>
<p>这个二叉树的最小深度为 2</p>
<h1 id="解题思路">解题思路</h1><ul>
<li><p><strong>一定要注意定义</strong>，比如下面这棵树的最小深度是<strong>3</strong>不是<strong>1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#10; \&#10;  2&#10;   \&#10;    3</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法和找最大深度一样，Divide &amp; Conquer<br>只需要判断如果左右儿子中又None，则返回非None的儿子的高度+1</p>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">None</span> <span class="keyword">in</span> [root.left, root.right]:</span><br><span class="line">            <span class="keyword">return</span> max(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> min(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个二叉树，找出其最小深度。<br>二叉树的最小深度为根节点到最近叶子节点的距离。</p>
</blockquote>
<p>给出一棵如下的二叉树:<br><figure class="highlight ]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[236 Lowest Common Ancestor of a Binary Tree]]></title>
    <link href="http://yoursite.com/2015/10/21/236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
    <id>http://yoursite.com/2015/10/21/236-Lowest-Common-Ancestor-of-a-Binary-Tree/</id>
    <published>2015-10-22T01:18:10.000Z</published>
    <updated>2015-10-22T08:18:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。<br>最近公共祖先是两个节点的公共的祖先节点且具有最大深度。</p>
</blockquote>
<p>对于下面这棵二叉树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; 4&#10;&#160;/ \&#10;3 &#160; 7&#10;&#160;&#160; / \&#10;&#160; 5 &#160; 6&#10;LCA(3, 5) = 4&#10;LCA(5, 6) = 7&#10;LCA(6, 7) = 7</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>Divide &amp; Conquer 的思路</li>
<li>如果<code>root</code>为空，则返回空</li>
<li>如果<code>root</code>等于其中某个<code>node</code>，则返回<code>root</code></li>
<li>如果上述两种情况都不满足，则divide，左右子树分别调用该方法</li>
<li>Divide &amp; Conquer中<strong>治</strong>这一步要考虑清楚，本题三种情况<ul>
<li>如果<code>left</code>和<code>right</code>都有结果返回，说明root是最小公共祖先</li>
<li>如果只有<code>left</code>有返回值，说明<code>left</code><strong>的返回值</strong>是最小公共祖先</li>
<li>如果只有<code>right</code>有返回值，说明<code>right</code><strong>的返回值</strong>是最小公共祖先</li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># divide</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># conquer</span></span><br><span class="line">        <span class="keyword">if</span> left != <span class="keyword">None</span> <span class="keyword">and</span> right != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。<br>最近公共祖先是两个节点的公共的祖先节点且具有最大深度。</p>
</blockquote>
<p>对于下面这棵二叉树<br><figure cla]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LCA" scheme="http://yoursite.com/tags/LCA/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[235 Lowest Common Ancestor of a Binary Search Tree]]></title>
    <link href="http://yoursite.com/2015/10/21/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2015/10/21/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</id>
    <published>2015-10-22T01:09:04.000Z</published>
    <updated>2015-10-22T08:19:43.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一棵平衡二叉树(BST)，找到两个节点的最近公共父节点(LCA)。<br>最近公共祖先是两个节点的公共的祖先节点且具有最大深度。</p>
</blockquote>
<p>对于下面这棵二叉树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; 4&#10;&#160;/ \&#10;3 &#160; 7&#10;&#160;&#160; / \&#10;&#160; 5 &#160; 6</span><br></pre></td></tr></table></figure></p>
<p>LCA(3, 5) = 4<br>LCA(5, 6) = 7<br>LCA(6, 7) = 7</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>与本题类似的题是把BST换成普通的二叉树，方法为divide &amp; conquer</li>
<li>对于本题，初始如果<code>root</code>为空，则直接返回None</li>
<li>如果有其中一个<code>node</code>跟<code>root</code>相等，则返回<code>root</code></li>
<li>以上两两种情况都不满足，考虑到是一棵平衡二叉树，所以有以下三种情况<ul>
<li>如果两个<code>node</code>中的较小值都大于<code>root.val</code>，则答案一定在右子树</li>
<li>如果两个<code>node</code>中的较大值都小于<code>root.val</code>，则答案一定在左子树</li>
<li>或者<code>root.val</code>的值介于两个<code>node</code>的值中间，则返回<code>root</code></li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root.val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> q.val &gt; p.val:</span><br><span class="line">            q, p = p, q</span><br><span class="line">        <span class="keyword">if</span> q.val &lt; root.val <span class="keyword">and</span> p.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> root.val</span><br><span class="line">        <span class="keyword">if</span> q.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一棵平衡二叉树(BST)，找到两个节点的最近公共父节点(LCA)。<br>最近公共祖先是两个节点的公共的祖先节点且具有最大深度。</p>
</blockquote>
<p>对于下面这棵二叉树<br><fig]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="LCA" scheme="http://yoursite.com/tags/LCA/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[173 Binary Search Tree Iterator]]></title>
    <link href="http://yoursite.com/2015/10/20/173-Binary-Search-Tree-Iterator/"/>
    <id>http://yoursite.com/2015/10/20/173-Binary-Search-Tree-Iterator/</id>
    <published>2015-10-21T03:38:56.000Z</published>
    <updated>2015-10-21T10:40:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>设计实现一个带有下列属性的二叉查找树的迭代器：<br>元素按照递增的顺序被访问（比如中序遍历）<br>next()和hasNext()的询问操作要求<strong>均摊</strong>时间复杂度是O(1)</p>
</blockquote>
<p>对于下列二叉查找树，使用迭代器进行中序遍历的结果为 [3, 6, 7, 8, 9, 10, 11, 12]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160;&#160;   10&#10;&#160;  /&#160; &#160; \&#10;  6&#160; &#160; &#160; 11&#10; /&#160;\ &#160; &#160; &#160; \&#10;3&#160;  9 &#160; &#160; &#160; 12&#10;   /&#10;  8&#10; /&#10;7</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>本题相当于考察了BST的非递归中序遍历</li>
<li><p>需要maintain一个stack，首先从root开始push入栈直到最左节点<br>初始stack为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10, 6, 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>在遍历过程中，如果某个节点存在右儿子，则继续从右儿子开始push入栈直到其最左节点<br>result = 3, 6<br>因为6有右儿子，所以6被pop出去之后，从6为root开始push入栈直到最左节点，然后stack为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10&#65292; 9&#65292; 8&#65292; 7</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line"></span><br><span class="line">Example of iterate a tree:</span><br><span class="line">iterator = Solution(root)</span><br><span class="line">while iterator.hasNext():</span><br><span class="line">    node = iterator.next()</span><br><span class="line">    do something for node </span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            self.stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return a boolean, whether we have a next smallest number</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> self.stack <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return an node</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        current = self.stack.pop()</span><br><span class="line">        node = current.right</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            self.stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">return</span> current</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>设计实现一个带有下列属性的二叉查找树的迭代器：<br>元素按照递增的顺序被访问（比如中序遍历）<br>next()和hasNext()的询问操作要求<strong>均摊</strong>时间复杂度是O(1)</]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Non-recursion" scheme="http://yoursite.com/tags/Non-recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[11 Search Range In Binary Search Tree]]></title>
    <link href="http://yoursite.com/2015/10/20/11-Search-Range-In-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2015/10/20/11-Search-Range-In-Binary-Search-Tree/</id>
    <published>2015-10-21T03:14:34.000Z</published>
    <updated>2015-10-21T10:15:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定两个值 k1 和 k2（k1 &lt; k2）和一个二叉查找树的根节点。找到树中所有值在 k1 到 k2 范围内的节点。即打印所有x (k1 &lt;= x &lt;= k2) 其中 x 是二叉查找树的中的节点值。返回所有升序的节点值。</p>
</blockquote>
<p>如果有 k1 = 10 和 k2 = 22, 你的程序应该返回 [12, 20, 22].<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; &#160; 20&#10;&#160;&#160; /&#160; \&#10;&#160; 8 &#160; 22&#10;&#160;/ \&#10;4 &#160; 12</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>方法一：暴力解法，DFS遍历所有节点，符合要求的加入result中，最后result排序，返回</li>
<li>方法二：同样是DFS遍历，但加入判断，相当于剪枝。<ul>
<li>如果<code>root.val &gt; start</code>则可以继续左子树</li>
<li>如果<code>root.val &lt; end</code>则可以继续右子树</li>
<li>如果<code>start &lt;= root.val &lt;= end</code>则把<code>root.val</code>加入<code>result</code></li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root: The root of the binary search tree.</span><br><span class="line">    @param k1 and k2: range k1 to k2.</span><br><span class="line">    @return: Return all keys that k1&lt;=key&lt;=k2 in ascending order.</span><br><span class="line">    """</span>     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, root, k1, k2)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root, k1, k2, res)</span><br><span class="line">        <span class="keyword">return</span> sorted(res)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, start, end, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt;= start <span class="keyword">and</span> root.val &lt;= end:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">            self.dfs(root.left, start, end, result)</span><br><span class="line">            self.dfs(root.right, start, end, result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root: The root of the binary search tree.</span><br><span class="line">    @param k1 and k2: range k1 to k2.</span><br><span class="line">    @return: Return all keys that k1&lt;=key&lt;=k2 in ascending order.</span><br><span class="line">    """</span>     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, root, k1, k2)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root, k1, k2, res)</span><br><span class="line">        <span class="keyword">return</span> sorted(res)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, start, end, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; start:</span><br><span class="line">                self.dfs(root.left, start, end, result)</span><br><span class="line">            <span class="keyword">if</span> root.val &gt;= start <span class="keyword">and</span> root.val &lt;= end:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; end:</span><br><span class="line">                self.dfs(root.right, start, end, result)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定两个值 k1 和 k2（k1 &lt; k2）和一个二叉查找树的根节点。找到树中所有值在 k1 到 k2 范围内的节点。即打印所有x (k1 &lt;= x &lt;= k2) 其中 x 是二叉查找树的中的]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
</feed>
