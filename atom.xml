<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Chemistry]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-10-26T10:35:25.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Jason Yuan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[55 Jump Game]]></title>
    <link href="http://yoursite.com/2015/10/25/55-Jump-Game/"/>
    <id>http://yoursite.com/2015/10/25/55-Jump-Game/</id>
    <published>2015-10-26T03:34:39.000Z</published>
    <updated>2015-10-26T10:35:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个非负整数数组，你最初定位在数组的第一个位置。　　　<br>数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　　<br>判断你是否能到达数组的最后一个位置。</p>
</blockquote>
<p>A =<strong> [2,3,1,1,4]</strong>，返回 true.<br>A =<strong> [3,2,1,0,4]</strong>，返回 false.</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>方法一：贪心法 greedy</li>
<li>方法二：单序列型动态规划 - Sequence DP (因为题目中给的是序列而不是数组，注意两者的区别)，本题动归的方法不能过OJ</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一，贪心</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        farest = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &lt;= farest <span class="keyword">and</span> nums[i] + i &gt; farest:</span><br><span class="line">                farest = nums[i] + i</span><br><span class="line">            <span class="keyword">if</span> farest &gt;= len(nums) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二，动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        cache = [<span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        cache[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> cache[j] <span class="keyword">is</span> <span class="keyword">True</span> <span class="keyword">and</span> j + nums[j] &gt;= i:</span><br><span class="line">                    cache[i] == <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> cache[len(nums) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个非负整数数组，你最初定位在数组的第一个位置。　　　<br>数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　　<br>判断你是否能到达数组的最后一个位置。</p>
</blockquote>
<]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sequence DP" scheme="http://yoursite.com/tags/Sequence-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[120 Triangle]]></title>
    <link href="http://yoursite.com/2015/10/25/120-Triangle/"/>
    <id>http://yoursite.com/2015/10/25/120-Triangle/</id>
    <published>2015-10-26T03:02:53.000Z</published>
    <updated>2015-10-26T10:03:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。</p>
</blockquote>
<p>比如，给出下列数字三角形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;&#160; &#160; &#160;[2],&#10;  &#160; [3,4],&#10;&#160; &#160;[6,5,7],&#10;&#160; [4,1,8,3]&#10;]</span><br></pre></td></tr></table></figure></p>
<p>从顶到底部的最小路径和为11 (<strong> 2 + 3 + 5 + 1 = 11</strong>)。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>矩阵型动态规划问题 - Matrix DP</li>
<li>有两种解决方案，自顶向下或者自底向上</li>
<li>下面代码采用自底向上的方法，cache[i][j]表明从最底层到i,j所用的最短距离是多少</li>
<li><code>cache[i][j]</code>就等于<code>cache[i+1][j]</code>(左下角)与<code>cache[i+1][j+1]</code>(右下角)中最小的加上<code>triangle[i][j]</code>的值</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type triangle: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> triangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        m = len(triangle)</span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            cache[m - <span class="number">1</span>][i] = triangle[m - <span class="number">1</span>][i]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m - i):</span><br><span class="line">                cache[m - <span class="number">1</span> - i][j] = min(cache[m - i][j], cache[m - i][j + <span class="number">1</span>]) + triangle[m - <span class="number">1</span> - i][j]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> cache[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。</p>
</blockquote>
<p>比如，给出下列数字三角形：<br><figure class="highlig]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Matrix DP" scheme="http://yoursite.com/tags/Matrix-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[64 Minimum Path Sum]]></title>
    <link href="http://yoursite.com/2015/10/24/64-Minimum-Path-Sum/"/>
    <id>http://yoursite.com/2015/10/24/64-Minimum-Path-Sum/</id>
    <published>2015-10-25T03:32:25.000Z</published>
    <updated>2015-10-25T10:33:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。</p>
</blockquote>
<p>你在同一时间只能向下或者向右移动一步</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>矩阵型动态规划 - Matrix DP</li>
<li>与Unique Paths I/II非常类似，不同的是每次要找最小value</li>
<li>cache[i][j]表示从左上角到达i,j的数字和最小路径，它等于cache[i][j - 1]与cache[i - 1][j]的最小值，加上grid[i][j]的值</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type grid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">        sum1 = sum2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum1 += grid[<span class="number">0</span>][i]</span><br><span class="line">            cache[<span class="number">0</span>][i] = sum1</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            sum2 += grid[j][<span class="number">0</span>]</span><br><span class="line">            cache[j][<span class="number">0</span>] = sum2</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">                cache[j][i] = min(cache[j - <span class="number">1</span>][i], cache[j][i - <span class="number">1</span>]) + grid[j][i]</span><br><span class="line">        <span class="keyword">return</span> cache[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。</p>
</blockquote>
<p>你在同一时间只能向下或者向右移动一步</p>
<h1 id="解题思路">解题思路]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Matrix DP" scheme="http://yoursite.com/tags/Matrix-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[70 Climbing Stairs]]></title>
    <link href="http://yoursite.com/2015/10/24/70-Climbing-Stairs/"/>
    <id>http://yoursite.com/2015/10/24/70-Climbing-Stairs/</id>
    <published>2015-10-25T03:20:40.000Z</published>
    <updated>2015-10-25T10:21:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？</p>
</blockquote>
<p>比如n=3，1+1+1=1+2=2+1=3，共有3中不同的方法<br>返回 3</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>本题本质和菲波那切数列问题非常相似</li>
<li>单序列型动态规划问题 - Sequence DP</li>
<li>cache[i]表示有i个台阶，能跳到第i个台阶的方案个数</li>
<li>因为每次可以跳一步或者跳两步，所以cache[i]就等于下面的和<ul>
<li>可以跳的i - 1的方案个数即cache[i - 1]</li>
<li>可以跳到i - 2的方案个数即cache[i - 2]</li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        cache = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        cache[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        cache[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            cache[i] = cache[i - <span class="number">1</span>] + cache[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> cache[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？</p>
</blockquote>
<p>比如n=3，1+1+1=1+2=2+1=3，共有3中不同的方法]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sequence DP" scheme="http://yoursite.com/tags/Sequence-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[63 Unique Paths II]]></title>
    <link href="http://yoursite.com/2015/10/24/63-Unique-Paths-II/"/>
    <id>http://yoursite.com/2015/10/24/63-Unique-Paths-II/</id>
    <published>2015-10-25T02:18:09.000Z</published>
    <updated>2015-10-25T09:18:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>现在考虑网格中有障碍物，那样将会有多少条不同的路径？<br>网格中的障碍和空位置分别用<strong>1</strong>和<strong>0</strong>来表示。</p>
</blockquote>
<p>如下所示在3x3的网格中有一个障碍物：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;&#160; [0,0,0],&#10;&#160; [0,1,0],&#10;&#160; [0,0,0]&#10;]</span><br></pre></td></tr></table></figure></p>
<p>一共有2条不同的路径从左上角到右下角。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>同样是矩阵型动态规划 - Matrix DP</li>
<li>对于有障碍物的地图来说，只需要把<strong>障碍物的坐标设为0即可</strong></li>
<li>要注意对第一行和第一列的初始化，如果遇到障碍物第一行后面和第一列下面都是0</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type obstacleGrid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid <span class="keyword">or</span> <span class="keyword">not</span> obstacleGrid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(obstacleGrid)</span><br><span class="line">        n = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">        flag1 = flag2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m): </span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[j][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                flag1 = <span class="number">0</span></span><br><span class="line">            cache[j][<span class="number">0</span>] = flag1</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>:</span><br><span class="line">                flag2 = <span class="number">0</span></span><br><span class="line">            cache[<span class="number">0</span>][i] = flag2</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                cache[j][i] = (cache[j - <span class="number">1</span>][i] + cache[j][i - <span class="number">1</span>]) <span class="keyword">if</span> obstacleGrid[j][i] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> cache[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>现在考虑网格中有障碍物，那样将会有多少条不同的路径？<br>网格中的障碍和空位置分别用<strong>1</strong>和<strong>0</strong>来表示。</p>
</blockquote>
<p]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Matrix DP" scheme="http://yoursite.com/tags/Matrix-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[62 Unique Paths]]></title>
    <link href="http://yoursite.com/2015/10/24/62-Unique-Paths/"/>
    <id>http://yoursite.com/2015/10/24/62-Unique-Paths/</id>
    <published>2015-10-25T01:52:40.000Z</published>
    <updated>2015-10-25T08:59:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>有一个机器人的位于一个M×N个网格左上角（下图中标记为’Start’）。<br>机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角（下图中标记为’Finish’）。<br>问有多少条不同的路径？</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">1, 1</th>
<th style="text-align:center">1, 2</th>
<th style="text-align:center">1, 3</th>
<th style="text-align:center">1, 4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2, 1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">3, 1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">4, 1</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">4, 4</td>
</tr>
</tbody>
</table>
<p>以上4 x 4的网格中，有多少条不同的路径？</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>动态规划就是解决了重复计算，具体实现方式有：<ul>
<li>记忆化搜索</li>
<li>循环求解(本题采用此方法)</li>
</ul>
</li>
<li>典型DP问题 - <strong>矩阵型动态规划</strong>(Matrix DP)</li>
<li><code>cache[x][y]</code>表示从起点到<code>x,y</code>的路径数，等于<code>cache[x][y - 1]</code>与<code>cache[x - 1][y]</code>的路径数之和</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type m: int</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> m &lt; <span class="number">1</span> <span class="keyword">or</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            cache[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            cache[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">                cache[i][j] = cache[i - <span class="number">1</span>][j] + cache[i][j - <span class="number">1</span>]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> cache[n - <span class="number">1</span>][m - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>有一个机器人的位于一个M×N个网格左上角（下图中标记为’Start’）。<br>机器人每一时刻只能向下或者向右移动一步。机器人试图达到网格的右下角（下图中标记为’Finish’）。<br>问有多少条不同的路径？]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Matrix DP" scheme="http://yoursite.com/tags/Matrix-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[94 Binary Tree Inorder Traversal]]></title>
    <link href="http://yoursite.com/2015/10/21/94-Binary-Tree-Inorder-Traversal/"/>
    <id>http://yoursite.com/2015/10/21/94-Binary-Tree-Inorder-Traversal/</id>
    <published>2015-10-22T02:58:13.000Z</published>
    <updated>2015-10-22T09:59:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树,返回其中序遍历</p>
</blockquote>
<p>给出二叉树 {1,#,2,3}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160;&#160; 1&#10;&#160; &#160; \&#10;&#160;&#160; &#160; 2&#10;&#160; &#160; /&#10;&#160;&#160; 3</span><br></pre></td></tr></table></figure></p>
<p>返回 [1,3,2]</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>方法一：递归，定义helper函数</li>
<li>方法二：Divide &amp; Conquer</li>
<li>方法二：非递归<ul>
<li>(操作一)每一次从当前节点开始(第一次是root节点)遍历至最左节点，一次入栈。</li>
<li>(操作二)pop出栈一个node，node.val加入到结果，然后看该node有没有右儿子</li>
<li>有的话重复操作一</li>
<li>没有的话，继续pop出栈一个node，重复操作二</li>
</ul>
</li>
<li>非递归解法可以体会一下另外一个题[Inorder Successor in Binary Search Tree]</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        self.helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">            self.helper(root.left, result)</span><br><span class="line">            result.append(root.val)</span><br><span class="line">            self.helper(root.right, result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        result.append(root.val)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># divide</span></span><br><span class="line">        left = self.inorderTraversal(root.left)</span><br><span class="line">        right = self.inorderTraversal(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># conquer</span></span><br><span class="line">        <span class="keyword">return</span> left + result + right</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        result = []</span><br><span class="line">        current = root</span><br><span class="line">        <span class="keyword">while</span> current != <span class="keyword">None</span> <span class="keyword">or</span> len(stack) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> current != <span class="keyword">None</span>:</span><br><span class="line">                stack.append(current)</span><br><span class="line">                current = current.left</span><br><span class="line">            current = stack[-<span class="number">1</span>];</span><br><span class="line">            stack.pop();</span><br><span class="line">            result.append(current.val);</span><br><span class="line">            current = current.right;</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树,返回其中序遍历</p>
</blockquote>
<p>给出二叉树 {1,#,2,3}<br><figure class="highlight plain"><table><tr><td cl]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Non-recursion" scheme="http://yoursite.com/tags/Non-recursion/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[145 Binary Tree Postorder Traversal]]></title>
    <link href="http://yoursite.com/2015/10/21/145-Binary-Tree-Postorder-Traversal/"/>
    <id>http://yoursite.com/2015/10/21/145-Binary-Tree-Postorder-Traversal/</id>
    <published>2015-10-22T02:42:32.000Z</published>
    <updated>2015-10-27T09:04:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树，返回其节点值的后序遍历。</p>
</blockquote>
<p>给出一棵二叉树 {1,#,2,3}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160;&#160; 1&#10;&#160; &#160; \&#10;&#160;&#160; &#160; 2&#10;&#160; &#160; /&#10;&#160;&#160; 3</span><br></pre></td></tr></table></figure></p>
<p>返回 [3,2,1]</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>递归求解，定义一个helper函数，定义一个result全局变量，传入helper函数</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root: The root of binary tree.</span><br><span class="line">    @return: Postorder in ArrayList which contains node values.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.helper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.helper(root.left, result)</span><br><span class="line">            self.helper(root.right, result)</span><br><span class="line">            result.append(root.val)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树，返回其节点值的后序遍历。</p>
</blockquote>
<p>给出一棵二叉树 {1,#,2,3}<br><figure class="highlight plain"><table><tr]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[85 Insert Node in a Binary Search Tree]]></title>
    <link href="http://yoursite.com/2015/10/21/85-Insert-Node-in-a-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2015/10/21/85-Insert-Node-in-a-Binary-Search-Tree/</id>
    <published>2015-10-22T02:35:26.000Z</published>
    <updated>2015-10-22T09:35:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一棵二叉查找树和一个新的树节点，将节点插入到树中。<br>你需要保证该树仍然是一棵二叉查找树。</p>
</blockquote>
<p>给出如下一棵二叉查找树，在插入节点6之后这棵二叉查找树可以是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; 2 &#160; &#160; &#160; &#160; &#160; &#160; 2&#10;&#160;/ \ &#160; &#160; &#160; &#160; &#160; / \&#10;1 &#160; 4 &#160; --&#62; &#160; 1 &#160; 4&#10;&#160;&#160; / &#160; &#160; &#160; &#160; &#160; &#160; / \&#160;&#10;&#160; 3 &#160; &#160; &#160; &#160; &#160; &#160; 3 &#160; 6</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>如果root为空，给root赋值</li>
<li>root不为空，根据root.val与node.val的大小去判断往左儿子走还是右儿子走</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root: The root of the binary search tree.</span><br><span class="line">    @param node: insert this node into the binary search tree.</span><br><span class="line">    @return: The root of the new binary search tree.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertNode</span><span class="params">(self, root, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            root = node</span><br><span class="line">        <span class="keyword">elif</span> root.val &gt; node.val:</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                self.insertNode(root.left, node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.left = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                self.insertNode(root.right, node)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root.right = node</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一棵二叉查找树和一个新的树节点，将节点插入到树中。<br>你需要保证该树仍然是一棵二叉查找树。</p>
</blockquote>
<p>给出如下一棵二叉查找树，在插入节点6之后这棵二叉查找树可以是这样的：]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[111 Minimum Depth of Binary Tree]]></title>
    <link href="http://yoursite.com/2015/10/21/111-Minimum-Depth-of-Binary-Tree/"/>
    <id>http://yoursite.com/2015/10/21/111-Minimum-Depth-of-Binary-Tree/</id>
    <published>2015-10-22T01:40:09.000Z</published>
    <updated>2015-10-22T08:40:55.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个二叉树，找出其最小深度。<br>二叉树的最小深度为根节点到最近叶子节点的距离。</p>
</blockquote>
<p>给出一棵如下的二叉树:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; &#160; &#160; &#160; 1&#10;&#160; &#160; &#160;/ &#160; &#160; \&#160;&#10;&#160; &#160;2 &#160; &#160; &#160; 3&#10;&#160; &#160; &#160; &#160; &#160; / &#160; &#160;\&#10;&#160; &#160; &#160; &#160; 4 &#160; &#160; &#160;5</span><br></pre></td></tr></table></figure></p>
<p>这个二叉树的最小深度为 2</p>
<h1 id="解题思路">解题思路</h1><ul>
<li><p><strong>一定要注意定义</strong>，比如下面这棵树的最小深度是<strong>3</strong>不是<strong>1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#10; \&#10;  2&#10;   \&#10;    3</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法和找最大深度一样，Divide &amp; Conquer<br>只需要判断如果左右儿子中又None，则返回非None的儿子的高度+1</p>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">None</span> <span class="keyword">in</span> [root.left, root.right]:</span><br><span class="line">            <span class="keyword">return</span> max(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> min(self.minDepth(root.left), self.minDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个二叉树，找出其最小深度。<br>二叉树的最小深度为根节点到最近叶子节点的距离。</p>
</blockquote>
<p>给出一棵如下的二叉树:<br><figure class="highlight ]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[236 Lowest Common Ancestor of a Binary Tree]]></title>
    <link href="http://yoursite.com/2015/10/21/236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
    <id>http://yoursite.com/2015/10/21/236-Lowest-Common-Ancestor-of-a-Binary-Tree/</id>
    <published>2015-10-22T01:18:10.000Z</published>
    <updated>2015-10-22T08:18:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。<br>最近公共祖先是两个节点的公共的祖先节点且具有最大深度。</p>
</blockquote>
<p>对于下面这棵二叉树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; 4&#10;&#160;/ \&#10;3 &#160; 7&#10;&#160;&#160; / \&#10;&#160; 5 &#160; 6&#10;LCA(3, 5) = 4&#10;LCA(5, 6) = 7&#10;LCA(6, 7) = 7</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>Divide &amp; Conquer 的思路</li>
<li>如果<code>root</code>为空，则返回空</li>
<li>如果<code>root</code>等于其中某个<code>node</code>，则返回<code>root</code></li>
<li>如果上述两种情况都不满足，则divide，左右子树分别调用该方法</li>
<li>Divide &amp; Conquer中<strong>治</strong>这一步要考虑清楚，本题三种情况<ul>
<li>如果<code>left</code>和<code>right</code>都有结果返回，说明root是最小公共祖先</li>
<li>如果只有<code>left</code>有返回值，说明<code>left</code><strong>的返回值</strong>是最小公共祖先</li>
<li>如果只有<code>right</code>有返回值，说明<code>right</code><strong>的返回值</strong>是最小公共祖先</li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># divide</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># conquer</span></span><br><span class="line">        <span class="keyword">if</span> left != <span class="keyword">None</span> <span class="keyword">and</span> right != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一棵二叉树，找到两个节点的最近公共父节点(LCA)。<br>最近公共祖先是两个节点的公共的祖先节点且具有最大深度。</p>
</blockquote>
<p>对于下面这棵二叉树<br><figure cla]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LCA" scheme="http://yoursite.com/tags/LCA/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[235 Lowest Common Ancestor of a Binary Search Tree]]></title>
    <link href="http://yoursite.com/2015/10/21/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2015/10/21/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</id>
    <published>2015-10-22T01:09:04.000Z</published>
    <updated>2015-10-22T08:19:43.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一棵平衡二叉树(BST)，找到两个节点的最近公共父节点(LCA)。<br>最近公共祖先是两个节点的公共的祖先节点且具有最大深度。</p>
</blockquote>
<p>对于下面这棵二叉树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; 4&#10;&#160;/ \&#10;3 &#160; 7&#10;&#160;&#160; / \&#10;&#160; 5 &#160; 6</span><br></pre></td></tr></table></figure></p>
<p>LCA(3, 5) = 4<br>LCA(5, 6) = 7<br>LCA(6, 7) = 7</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>与本题类似的题是把BST换成普通的二叉树，方法为divide &amp; conquer</li>
<li>对于本题，初始如果<code>root</code>为空，则直接返回None</li>
<li>如果有其中一个<code>node</code>跟<code>root</code>相等，则返回<code>root</code></li>
<li>以上两两种情况都不满足，考虑到是一棵平衡二叉树，所以有以下三种情况<ul>
<li>如果两个<code>node</code>中的较小值都大于<code>root.val</code>，则答案一定在右子树</li>
<li>如果两个<code>node</code>中的较大值都小于<code>root.val</code>，则答案一定在左子树</li>
<li>或者<code>root.val</code>的值介于两个<code>node</code>的值中间，则返回<code>root</code></li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type p: TreeNode</span><br><span class="line">        :type q: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root.val</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> q.val &gt; p.val:</span><br><span class="line">            q, p = p, q</span><br><span class="line">        <span class="keyword">if</span> q.val &lt; root.val <span class="keyword">and</span> p.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> root.val</span><br><span class="line">        <span class="keyword">if</span> q.val &gt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一棵平衡二叉树(BST)，找到两个节点的最近公共父节点(LCA)。<br>最近公共祖先是两个节点的公共的祖先节点且具有最大深度。</p>
</blockquote>
<p>对于下面这棵二叉树<br><fig]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="LCA" scheme="http://yoursite.com/tags/LCA/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[173 Binary Search Tree Iterator]]></title>
    <link href="http://yoursite.com/2015/10/20/173-Binary-Search-Tree-Iterator/"/>
    <id>http://yoursite.com/2015/10/20/173-Binary-Search-Tree-Iterator/</id>
    <published>2015-10-21T03:38:56.000Z</published>
    <updated>2015-10-21T10:40:29.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>设计实现一个带有下列属性的二叉查找树的迭代器：<br>元素按照递增的顺序被访问（比如中序遍历）<br>next()和hasNext()的询问操作要求<strong>均摊</strong>时间复杂度是O(1)</p>
</blockquote>
<p>对于下列二叉查找树，使用迭代器进行中序遍历的结果为 [3, 6, 7, 8, 9, 10, 11, 12]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160;&#160;   10&#10;&#160;  /&#160; &#160; \&#10;  6&#160; &#160; &#160; 11&#10; /&#160;\ &#160; &#160; &#160; \&#10;3&#160;  9 &#160; &#160; &#160; 12&#10;   /&#10;  8&#10; /&#10;7</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>本题相当于考察了BST的非递归中序遍历</li>
<li><p>需要maintain一个stack，首先从root开始push入栈直到最左节点<br>初始stack为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10, 6, 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>在遍历过程中，如果某个节点存在右儿子，则继续从右儿子开始push入栈直到其最左节点<br>result = 3, 6<br>因为6有右儿子，所以6被pop出去之后，从6为root开始push入栈直到最左节点，然后stack为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10&#65292; 9&#65292; 8&#65292; 7</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line"></span><br><span class="line">Example of iterate a tree:</span><br><span class="line">iterator = Solution(root)</span><br><span class="line">while iterator.hasNext():</span><br><span class="line">    node = iterator.next()</span><br><span class="line">    do something for node </span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            self.stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return a boolean, whether we have a next smallest number</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> self.stack <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return an node</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        current = self.stack.pop()</span><br><span class="line">        node = current.right</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            self.stack.append(node)</span><br><span class="line">            node = node.left</span><br><span class="line">        <span class="keyword">return</span> current</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>设计实现一个带有下列属性的二叉查找树的迭代器：<br>元素按照递增的顺序被访问（比如中序遍历）<br>next()和hasNext()的询问操作要求<strong>均摊</strong>时间复杂度是O(1)</]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Non-recursion" scheme="http://yoursite.com/tags/Non-recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[11 Search Range In Binary Search Tree]]></title>
    <link href="http://yoursite.com/2015/10/20/11-Search-Range-In-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2015/10/20/11-Search-Range-In-Binary-Search-Tree/</id>
    <published>2015-10-21T03:14:34.000Z</published>
    <updated>2015-10-21T10:15:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定两个值 k1 和 k2（k1 &lt; k2）和一个二叉查找树的根节点。找到树中所有值在 k1 到 k2 范围内的节点。即打印所有x (k1 &lt;= x &lt;= k2) 其中 x 是二叉查找树的中的节点值。返回所有升序的节点值。</p>
</blockquote>
<p>如果有 k1 = 10 和 k2 = 22, 你的程序应该返回 [12, 20, 22].<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; &#160; 20&#10;&#160;&#160; /&#160; \&#10;&#160; 8 &#160; 22&#10;&#160;/ \&#10;4 &#160; 12</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>方法一：暴力解法，DFS遍历所有节点，符合要求的加入result中，最后result排序，返回</li>
<li>方法二：同样是DFS遍历，但加入判断，相当于剪枝。<ul>
<li>如果<code>root.val &gt; start</code>则可以继续左子树</li>
<li>如果<code>root.val &lt; end</code>则可以继续右子树</li>
<li>如果<code>start &lt;= root.val &lt;= end</code>则把<code>root.val</code>加入<code>result</code></li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root: The root of the binary search tree.</span><br><span class="line">    @param k1 and k2: range k1 to k2.</span><br><span class="line">    @return: Return all keys that k1&lt;=key&lt;=k2 in ascending order.</span><br><span class="line">    """</span>     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, root, k1, k2)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root, k1, k2, res)</span><br><span class="line">        <span class="keyword">return</span> sorted(res)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, start, end, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt;= start <span class="keyword">and</span> root.val &lt;= end:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">            self.dfs(root.left, start, end, result)</span><br><span class="line">            self.dfs(root.right, start, end, result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root: The root of the binary search tree.</span><br><span class="line">    @param k1 and k2: range k1 to k2.</span><br><span class="line">    @return: Return all keys that k1&lt;=key&lt;=k2 in ascending order.</span><br><span class="line">    """</span>     </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, root, k1, k2)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.dfs(root, k1, k2, res)</span><br><span class="line">        <span class="keyword">return</span> sorted(res)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, start, end, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; start:</span><br><span class="line">                self.dfs(root.left, start, end, result)</span><br><span class="line">            <span class="keyword">if</span> root.val &gt;= start <span class="keyword">and</span> root.val &lt;= end:</span><br><span class="line">                result.append(root.val)</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; end:</span><br><span class="line">                self.dfs(root.right, start, end, result)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定两个值 k1 和 k2（k1 &lt; k2）和一个二叉查找树的根节点。找到树中所有值在 k1 到 k2 范围内的节点。即打印所有x (k1 &lt;= x &lt;= k2) 其中 x 是二叉查找树的中的]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[98 Validate Binary Search Tree]]></title>
    <link href="http://yoursite.com/2015/10/20/98-Validate-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2015/10/20/98-Validate-Binary-Search-Tree/</id>
    <published>2015-10-21T02:52:44.000Z</published>
    <updated>2015-10-21T09:54:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个二叉树，判断它是否是合法的二叉查找树(BST)<br>一棵BST定义为：<br>节点的左子树中的值要<strong>严格小于</strong>该节点的值。<br>节点的右子树中的值要<strong>严格大于</strong>该节点的值。<br>左右子树也必须是二叉查找树。</p>
</blockquote>
<p>一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160;&#160; 1&#10;&#160; / \&#10;&#160;2 &#160; 3&#10;&#160; &#160; /&#10;&#160;&#160; 4&#10;&#160; &#160; \&#10;&#160;&#160; &#160; 5</span><br></pre></td></tr></table></figure></p>
<p>上述这棵二叉树序列化为”{1,2,3,#,#,4,#,#,5}”.</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>BST的中序遍历结果是一个<strong>升序序列</strong><br>所以可以转化为数组，再遍历一遍数组，看是否升序。时间空间复杂度都是O(n)</li>
<li>divide &amp; conquer<ul>
<li>result每次返回一个区间的最大，最小</li>
<li>conquer的时候判断左子树</li>
</ul>
</li>
<li>递归判断<code>min &lt; left.val &lt; node.val &lt; right.val &lt; max</code></li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        self.inOrderToArray(root, res)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(res)):</span><br><span class="line">            <span class="keyword">if</span> res[i-<span class="number">1</span>] &gt;= res[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrderToArray</span><span class="params">(self, node, array)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                self.inOrderToArray(node.left, array)</span><br><span class="line">            array.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                self.inOrderToArray(node.right, array)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        res, _, _ = self.Helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span>, - sys.maxint, sys.maxint</span><br><span class="line">        </span><br><span class="line">        left = self.Helper(root.left)</span><br><span class="line">        right = self.Helper(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left[<span class="number">0</span>] <span class="keyword">or</span> <span class="keyword">not</span> right[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">None</span> <span class="keyword">and</span> left[<span class="number">1</span>] &gt;= root.val) <span class="keyword">or</span> (root.right != <span class="keyword">None</span> <span class="keyword">and</span> right[<span class="number">2</span>] &lt;= root.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span>, max(root.val, right[<span class="number">1</span>]), min(root.val, left[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法三</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root)  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, min=-float<span class="params">(<span class="string">"inf"</span>)</span>, max=float<span class="params">(<span class="string">"inf"</span>)</span>)</span>:</span></span><br><span class="line">	    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">		    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">	    <span class="keyword">elif</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>:</span><br><span class="line">		    <span class="keyword">return</span> root.val &gt; min <span class="keyword">and</span> root.val &lt; max</span><br><span class="line">	    <span class="keyword">elif</span> root.left == <span class="keyword">None</span>:</span><br><span class="line">		    <span class="keyword">return</span> self.helper(root.right, root.val, max) <span class="keyword">and</span> root.val &gt; min</span><br><span class="line">	    <span class="keyword">elif</span> root.right == <span class="keyword">None</span>:</span><br><span class="line">		    <span class="keyword">return</span> self.helper(root.left, min, root.val) <span class="keyword">and</span> root.val &lt; max</span><br><span class="line">	    <span class="keyword">return</span> self.helper(root.left, min, root.val) <span class="keyword">and</span> self.helper(root.right, root.val, max)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个二叉树，判断它是否是合法的二叉查找树(BST)<br>一棵BST定义为：<br>节点的左子树中的值要<strong>严格小于</strong>该节点的值。<br>节点的右子树中的值要<strong>严格]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="Traversal" scheme="http://yoursite.com/tags/Traversal/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[103 Binary Tree Zigzag Level Order Traversal]]></title>
    <link href="http://yoursite.com/2015/10/20/103-Binary-Tree-Zigzag-Level-Order-Traversal/"/>
    <id>http://yoursite.com/2015/10/20/103-Binary-Tree-Zigzag-Level-Order-Traversal/</id>
    <published>2015-10-21T02:02:13.000Z</published>
    <updated>2015-10-21T09:02:50.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树，返回其节点值的锯齿形层次遍历（先从左往右，下一层再从右往左，层与层之间交替进行） </p>
</blockquote>
<p>给出一棵二叉树 {3,9,20,#,#,15,7}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; &#160; 3&#10;&#160;&#160; / \&#10;&#160; 9&#160; 20&#10;&#160; &#160; /&#160; \&#10;&#160;&#160; 15 &#160; 7</span><br></pre></td></tr></table></figure></p>
<p>返回其锯齿形的层次遍历为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;&#160; [3],&#10;&#160; [20,9],&#10;&#160; [15,7]&#10;]</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>相似题[Binary Tree Level Order Traversal]和[Binary Tree Level Order Traversal II]</li>
<li>同样是一个queue实现BFS，只是在处理temp结果的时候每次改变顺序，借助一个<code>flag</code>变量</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">        result = []</span><br><span class="line">        MyQueue = Queue.Queue()</span><br><span class="line">        MyQueue.put(root)</span><br><span class="line">        flag = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> MyQueue.empty():</span><br><span class="line">            size = MyQueue.qsize()</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">                node = MyQueue.get()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    MyQueue.put(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    MyQueue.put(node.right)</span><br><span class="line">                <span class="keyword">if</span> flag:</span><br><span class="line">                    temp.append(node.val)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp.insert(<span class="number">0</span>, node.val)</span><br><span class="line">            result.append(temp)</span><br><span class="line">            flag = <span class="keyword">not</span> flag</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树，返回其节点值的锯齿形层次遍历（先从左往右，下一层再从右往左，层与层之间交替进行） </p>
</blockquote>
<p>给出一棵二叉树 {3,9,20,#,#,15,7}<br><figu]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[107 Binary Tree Level Order Traversal II]]></title>
    <link href="http://yoursite.com/2015/10/20/107-Binary-Tree-Level-Order-Traversal-II/"/>
    <id>http://yoursite.com/2015/10/20/107-Binary-Tree-Level-Order-Traversal-II/</id>
    <published>2015-10-21T01:38:34.000Z</published>
    <updated>2015-10-21T08:39:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树，返回其节点值从底向上的层次序遍历（按从叶节点所在层到根节点所在的层遍历，然后逐层从左往右遍历）</p>
</blockquote>
<p>给出一棵二叉树 {3,9,20,#,#,15,7}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; &#160; 3&#10;&#160;&#160; / \&#10;&#160; 9&#160; 20&#10;&#160; &#160; /&#160; \&#10;&#160;&#160; 15 &#160; 7</span><br></pre></td></tr></table></figure></p>
<p>按照从下往上的层次遍历为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;&#160; [15,7],&#10;&#160; [9,20],&#10;&#160; [3]&#10;]</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>本题与[Binary Tree Level Order Traversal I]一样，同样使用一个queue解决，只是在生成result的时候不是<code>append</code>而是<code>insert(0, temp)</code></li>
<li>每次从见面加入<code>temp</code>结果</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">        result = []</span><br><span class="line">        MyQueue = Queue.Queue()</span><br><span class="line">        MyQueue.put(root)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> MyQueue.empty():</span><br><span class="line">            temp = []</span><br><span class="line">            size = MyQueue.qsize()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">                node = MyQueue.get()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    MyQueue.put(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    MyQueue.put(node.right)</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">            result.insert(<span class="number">0</span>, temp)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树，返回其节点值从底向上的层次序遍历（按从叶节点所在层到根节点所在的层遍历，然后逐层从左往右遍历）</p>
</blockquote>
<p>给出一棵二叉树 {3,9,20,#,#,15,7}<br]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[102 Binary Tree Level Order Traversal]]></title>
    <link href="http://yoursite.com/2015/10/20/102-Binary-Tree-Level-Order-Traversal/"/>
    <id>http://yoursite.com/2015/10/20/102-Binary-Tree-Level-Order-Traversal/</id>
    <published>2015-10-21T01:29:57.000Z</published>
    <updated>2015-10-21T08:30:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树，返回其节点值的层次遍历（逐层从左往右访问）</p>
</blockquote>
<p>给一棵二叉树 {3,9,20,#,#,15,7} ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; 3&#10;&#160;/ \&#10;9&#160; 20&#10;&#160; /&#160; \&#10;&#160;15 &#160; 7</span><br></pre></td></tr></table></figure></p>
<p>返回他的分层遍历结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;&#160; [3],&#10;&#160; [9,20],&#10;&#160; [15,7]&#10;]</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>实现方式有三种<ul>
<li>两个queue</li>
<li>一个queue + dummy node</li>
<li>一个queue</li>
</ul>
</li>
<li>对于使用一个queue的实现方式为，每次先求size，即这一层多少node。然后再把这一层node的value加入temp组成数组加入到最后的结果中，把这一层node的左右儿子加入到queue中</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        result = []</span><br><span class="line">        MyQueue = Queue.Queue()</span><br><span class="line">        MyQueue.put(root)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> MyQueue.empty():</span><br><span class="line">            size = MyQueue.qsize()</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">                node = MyQueue.get()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    MyQueue.put(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    MyQueue.put(node.right)</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">            result.append(temp)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树，返回其节点值的层次遍历（逐层从左往右访问）</p>
</blockquote>
<p>给一棵二叉树 {3,9,20,#,#,15,7} ：<br><figure class="highlight]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[124 Binary Tree Maximum Path Sum]]></title>
    <link href="http://yoursite.com/2015/10/20/124-Binary-Tree-Maximum-Path-Sum/"/>
    <id>http://yoursite.com/2015/10/20/124-Binary-Tree-Maximum-Path-Sum/</id>
    <published>2015-10-21T00:48:42.000Z</published>
    <updated>2015-10-21T07:49:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树，寻找一条路径使其路径和最大，路径可以在任一节点中开始和结束（路径和为两个节点之间所在路径上的节点权值之和）</p>
</blockquote>
<p>给出一棵二叉树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160;&#160; &#160; &#160; 1&#10;&#160; &#160; &#160; / \&#10;&#160;&#160; &#160; 2 &#160; 3</span><br></pre></td></tr></table></figure></p>
<p>返回 6</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>首先，想一个简化版(single path)，找从<code>root</code>到任意点得最大值。类似于maxDepth，每次加<code>root.val</code>而不再是<code>+1</code></li>
<li>求单路的时候，如果<code>root</code>加左儿子单路或者右儿子单路最后的值都小于0，则返回0，意味着不要<code>root</code>开始的这个单路了</li>
<li>本题思路，divide &amp; conquer<br>求最大路径和就等于下面三个值的最大值：<ul>
<li>左子树的最大路径和</li>
<li>右子树最大路径和</li>
<li>左子树单路 + 右子树单路 + root.val</li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        res, _ = self.helper(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> -sys.maxint, <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        singlePathSum = max(left[<span class="number">1</span>] + root.val, right[<span class="number">1</span>] + root.val, <span class="number">0</span>)</span><br><span class="line">        maxPathSum = max(left[<span class="number">0</span>], right[<span class="number">0</span>], left[<span class="number">1</span>] + right[<span class="number">1</span>] + root.val)</span><br><span class="line">        <span class="keyword">return</span> maxPathSum, singlePathSum</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一棵二叉树，寻找一条路径使其路径和最大，路径可以在任一节点中开始和结束（路径和为两个节点之间所在路径上的节点权值之和）</p>
</blockquote>
<p>给出一棵二叉树：<br><figure cl]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[110 Balanced Binary Tree]]></title>
    <link href="http://yoursite.com/2015/10/20/110-Balanced-Binary-Tree/"/>
    <id>http://yoursite.com/2015/10/20/110-Balanced-Binary-Tree/</id>
    <published>2015-10-20T23:57:39.000Z</published>
    <updated>2015-10-21T06:58:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个二叉树,确定它是高度平衡的。对于这个问题,一棵高度平衡的二叉树的定义是：一棵二叉树中每个节点的两个子树的深度相差不会超过1。 </p>
</blockquote>
<p>给出二叉树 A={3,9,20,#,#,15,7}, B={3,#,20,15,7}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A)&#160; 3&#160; &#160; &#160; &#160; &#160; &#160; B)&#160; &#160; 3&#160;&#10;&#160;&#160; / \&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; \&#10;&#160; 9&#160; 20 &#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; 20&#10;&#160; &#160; /&#160; \&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160; / \&#10;&#160;&#160; 15 &#160; 7&#160; &#160; &#160; &#160; &#160; &#160; &#160; 15&#160; 7</span><br></pre></td></tr></table></figure></p>
<p>二叉树A是高度平衡的二叉树，但是B不是</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>一般BST的问题，首先往divide &amp; conquer的思路去想</li>
<li>一棵二叉树是不是平衡二叉树 =&gt; 左子树是不是平衡二叉树？右子树是不是平衡二叉树？<ul>
<li>如果任意一颗子树不平衡，整个树肯定不平衡</li>
<li>如果左右子树都是平衡的，但左右子树相差高度大于1，此刻这课树又是不平衡的</li>
<li>问题转化为分别对左右子树求maxDepth，平衡就返回最大深度，不平衡就返回-1</li>
</ul>
</li>
<li>技巧：用-1表示它不是一颗平衡二叉树</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.maxDepth(root) != -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        left = self.maxDepth(root.left)</span><br><span class="line">        right = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">if</span> left == -<span class="number">1</span> <span class="keyword">or</span> right == -<span class="number">1</span> <span class="keyword">or</span> abs(left - right) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个二叉树,确定它是高度平衡的。对于这个问题,一棵高度平衡的二叉树的定义是：一棵二叉树中每个节点的两个子树的深度相差不会超过1。 </p>
</blockquote>
<p>给出二叉树 A={3,9,20,]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
</feed>
