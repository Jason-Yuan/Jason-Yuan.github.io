<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Chemistry]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-06-05T07:30:16.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Jason Yuan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[115 Distinct Subsequence]]></title>
    <link href="http://yoursite.com/2016/06/04/115-Distinct-Subsequence/"/>
    <id>http://yoursite.com/2016/06/04/115-Distinct-Subsequence/</id>
    <published>2016-06-05T00:17:23.000Z</published>
    <updated>2016-06-05T07:30:16.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出字符串S和字符串T，计算S的不同的子序列中T出现的个数。<br>子序列字符串是原始字符串通过删除一些(或零个)产生的一个新的字符串，并且对剩下的字符的相对位置没有影响。(比如，<strong>“ACE”</strong>是<strong>“ABCDE”</strong>的子序列字符串,而<strong>“AEC”</strong>不是)。 </p>
</blockquote>
<p><strong>样例</strong><br>给出S = <strong>“rabbbit”</strong>, T =<strong> “rabbit”</strong><br>返回 3</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>典型动态规划 - Two Sequence DP</li>
<li>状态cache[i][j]表示 S前i位的不同子序列中有几个和T的前j位相同</li>
<li>初始化<ul>
<li>cache[0][0] = 1 T和S都是空串，空串在空串中出现1次</li>
<li>cache[0][j] = 1 T是空串，S只有一种子序列(空串)可以匹配</li>
<li>cache[i][0] = 0 S是空串，T不是空串，S没有子序列可以匹配</li>
</ul>
</li>
<li><p>状态转移方程</p>
<ul>
<li>当S[j] != T[i]的时候， cache[i][j] = cache[i][j - 1] //<strong>“ABCD”匹配”AC”的方式至少有”ABC”匹配”AC”那么多种</strong></li>
<li>当S[j] == T[i]的时候，还要加上cache[i - 1][j - 1]那么多种匹配方式</li>
</ul>
</li>
<li><p>如果状态转移方程比较难想，可以先画图找规律</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/424375-d5fc78358fd3a564.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screenshot at Jun 05 00-07-26.png"></p>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDistinct</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type t: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s) + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(t) + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s) + <span class="number">1</span>):</span><br><span class="line">            cache[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(t) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[j - <span class="number">1</span>] == t[i - <span class="number">1</span>]:</span><br><span class="line">                    cache[i][j] = cache[i][j - <span class="number">1</span>] + cache[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cache[i][j] = cache[i][j - <span class="number">1</span>]</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> cache[len(t)][len(s)]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出字符串S和字符串T，计算S的不同的子序列中T出现的个数。<br>子序列字符串是原始字符串通过删除一些(或零个)产生的一个新的字符串，并且对剩下的字符的相对位置没有影响。(比如，<strong>“ACE”</]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Two Sequence DP" scheme="http://yoursite.com/tags/Two-Sequence-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[97 Interleaving String]]></title>
    <link href="http://yoursite.com/2016/06/04/97-Interleaving-String/"/>
    <id>http://yoursite.com/2016/06/04/97-Interleaving-String/</id>
    <published>2016-06-04T20:29:31.000Z</published>
    <updated>2016-06-05T03:30:28.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出三个字符串:s1、s2、s3，判断s3是否由s1和s2交叉构成。</p>
</blockquote>
<p><strong>样例</strong><br>比如 s1 =<strong> “aabcc”</strong> s2 =<strong> “dbbca”</strong></p>
<ul>
<li>当 s3 = <strong>“aadbbcbcac”</strong>，返回  true.</li>
<li>当 s3 = <strong>“aadbbbaccc”</strong>， 返回 false.</li>
</ul>
<h3 id="解题思路">解题思路</h3><ul>
<li>典型序列型动态规划，Two Sequence DP</li>
<li>状态cache[i][j]表示，s1的前i个字符和s2的前j个字符是否能交叉构成s3的前i+j个字符</li>
<li>初始化：<ul>
<li>cache[0][0] = True 因为两个空字符串可以组成空字符串</li>
<li>边界情况是一个字符串为空，初始化只需判断另一个字符串和目标字符串前x为是否相等</li>
<li>递推关系 cache[i][j] = (s1[i] == s3[i+j] and cache[i-1][j]) or (s2[j] == s3[i+j] and cache[i][j-1])</li>
</ul>
</li>
<li>最后说一个小小的简化程序的trick<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> something &gt; <span class="number">0</span> <span class="keyword">and</span> others &lt; <span class="number">0</span>:</span><br><span class="line">    x = <span class="keyword">True</span></span><br><span class="line"><span class="comment"># 直接可以写成</span></span><br><span class="line">x = something &gt; <span class="number">0</span> <span class="keyword">and</span> others &lt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInterleave</span><span class="params">(self, s1, s2, s3)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s1: str</span><br><span class="line">        :type s2: str</span><br><span class="line">        :type s3: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s3) != len(s1) + len(s2):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">        cache = [[<span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s1) + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s2) + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        cache[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s1) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> cache[<span class="number">0</span>][i -<span class="number">1</span>] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>]:</span><br><span class="line">                cache[<span class="number">0</span>][i] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(s2) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> cache[j - <span class="number">1</span>][<span class="number">0</span>] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[j - <span class="number">1</span>]:</span><br><span class="line">                cache[j][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(s2) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s1) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> (cache[j - <span class="number">1</span>][i] <span class="keyword">and</span> s2[j - <span class="number">1</span>] == s3[j + i - <span class="number">1</span>]) <span class="keyword">or</span> (cache[j][i - <span class="number">1</span>] <span class="keyword">and</span> s1[i - <span class="number">1</span>] == s3[j + i - <span class="number">1</span>]):</span><br><span class="line">                    cache[j][i] = <span class="keyword">True</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> cache[len(s2)][len(s1)]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出三个字符串:s1、s2、s3，判断s3是否由s1和s2交叉构成。</p>
</blockquote>
<p><strong>样例</strong><br>比如 s1 =<strong> “aabcc”</s]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Two Sequence DP" scheme="http://yoursite.com/tags/Two-Sequence-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用C#中的Dispatcher]]></title>
    <link href="http://yoursite.com/2016/06/03/%E4%BD%BF%E7%94%A8C-%E4%B8%AD%E7%9A%84Dispatcher/"/>
    <id>http://yoursite.com/2016/06/03/使用C-中的Dispatcher/</id>
    <published>2016-06-04T01:28:24.000Z</published>
    <updated>2016-06-04T08:29:01.000Z</updated>
    <content type="html"><![CDATA[<p>之前的文章说过了<a href="http://www.jianshu.com/p/b89f39c5f803" target="_blank" rel="external">如何使用BackgroundWorker</a>，今天要说的是WPF程序员处理多线程的另外一个方式 - Dispatcher</p>
<p>当我们打开一个WPF应用程序即开启了一个进程，该进程中至少包含两个线程。</p>
<ul>
<li>一个线程用于处理呈现：隐藏在后台运行</li>
<li>一个线程用于管理用户界面：接收输入、处理事件、绘制屏幕以及运行应用程序代码。即UI线程。</li>
</ul>
<p>在UI线程中有一个Dispatcher对象，管理每一个需要执行的工作项。Dispatcher会根据每个工作项的优先级排队。向Dispatcher列队中添加工作项时可指定10个不同的级别。那么问题来了，如果遇到耗时操作的时候，该操作如果依旧发生在UI线程中，Dispatcher 列队中其他的需要执行的工作项都要等待，从而造成界面假死的现象。为了加快响应速度，提高用户体验，我们应该尽量保证Dispatcher 列队中工作项要<strong>小</strong>。所以，对于耗时操作，我们应该开辟一个新的子线程去处理，在操作完成后，通过向UI线程的Dispatcher列队注册工作项，来通知UI线程更新结果。</p>
<p>Dispatcher提供两个注册工作项的方法：Invoke 和 BeginInvoke。这两个方法均调度一个委托来执行。Invoke 是同步调用，也就是说，直到 UI 线程实际执行完该委托它才返回。BeginInvoke是异步的，将立即返回。</p>
<ul>
<li>Dispatcher实际上并不是多线程</li>
<li>子线程不能直接修改UI线程，必须通过向UI线程中的Dispatcher注册工作项来完成</li>
<li>Dispatcher 是单例模式，暴露了一个静态的CurrentDispatcher方法用于获得当前线程的Dispatcher</li>
<li>每一个UI线程都至少有一个Dispatcher，一个Dispatcher只能在一个线程中执行工作。</li>
<li>开启新线程的方法很多，比如delegate.BeginInvoke()的方式开启的新线程。<blockquote>
<p>Delegate.Invoke: Executes synchronously, on the same thread.<br>Delegate.BeginInvoke: Executes asynchronously, on a threadpool thread.</p>
</blockquote>
</li>
</ul>
<h3 id="示例程序">示例程序</h3><p>XAML<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#60;Window x:Class=&#34;DispatcherExample.MainWindow&#34;&#10;        xmlns=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;&#10;        xmlns:x=&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;&#10;        Title=&#34;MainWindow&#34; Height=&#34;160&#34; Width=&#34;300&#34;&#62;&#10;    &#60;StackPanel&#62;&#10;        &#60;ProgressBar Name=&#34;progressBar&#34; Height=&#34;20&#34; Width=&#34;250&#34; Margin=&#34;10&#34;&#62;&#60;/ProgressBar&#62;&#10;        &#60;TextBox Name=&#34;textBox&#34; Width=&#34;50&#34; Height=&#34;20&#34; HorizontalAlignment=&#34;Center&#34;&#62;&#60;/TextBox&#62;&#10;        &#60;Button Name=&#34;btnProcess&#34; Width=&#34;100&#34; Click=&#34;btnProcess_Click&#34; Margin=&#34;5&#34;&#62;Start&#60;/Button&#62;&#10;        &#60;Button Name=&#34;btnCancel&#34; Width=&#34;100&#34; Click=&#34;btnCancel_Click&#34; Margin=&#34;5&#34;&#62;Cancel&#60;/Button&#62;&#10;    &#60;/StackPanel&#62;&#10;&#60;/Window&#62;</span><br></pre></td></tr></table></figure></p>
<p>C#<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">DispatcherExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> Interaction logic for MainWindow.xaml</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread taskThread;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnProcess_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            taskThread = <span class="keyword">new</span> Thread(DoTask);</span><br><span class="line">            taskThread.Start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnCancel_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            taskThread.Abort();</span><br><span class="line">            MessageBox.Show(<span class="string">"Background task finished normally"</span>, <span class="string">"info"</span>);</span><br><span class="line">            <span class="keyword">this</span>.progressBar.Value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.textBox.Text = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">DoTask</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            Int64 InputNum = (Int64)<span class="number">100</span>;</span><br><span class="line">            <span class="keyword">for</span> (Int64 i = <span class="number">0</span>; i &lt; InputNum; i++)</span><br><span class="line">			&#123;</span><br><span class="line">                Thread.Sleep(<span class="number">100</span>);</span><br><span class="line">			    <span class="keyword">this</span>.Dispatcher.BeginInvoke((Action)<span class="keyword">delegate</span>()</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.progressBar.Value = i;</span><br><span class="line">                    <span class="keyword">this</span>.textBox.Text = i.ToString();</span><br><span class="line">                &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">            MessageBox.Show(<span class="string">"Background task has been canceled"</span>, <span class="string">"info"</span>);</span><br><span class="line">            <span class="keyword">this</span>.Dispatcher.BeginInvoke((Action)<span class="keyword">delegate</span>()</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.progressBar.Value = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">this</span>.textBox.Text = <span class="keyword">null</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="演示">演示</h3><p><img src="http://upload-images.jianshu.io/upload_images/424375-cb2af30c9dd0131c.gif?imageMogr2/auto-orient/strip" alt="DispatcherExample.gif"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前的文章说过了<a href="http://www.jianshu.com/p/b89f39c5f803" target="_blank" rel="external">如何使用BackgroundWorker</a>，今天要说的是WPF程序员处理多线程的另外一个方式 ]]>
    </summary>
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="C#学习笔记" scheme="http://yoursite.com/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Multi-threading" scheme="http://yoursite.com/tags/Multi-threading/"/>
    
      <category term="WPF" scheme="http://yoursite.com/tags/WPF/"/>
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
      <category term="C#" scheme="http://yoursite.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[79 Longest Common Substring]]></title>
    <link href="http://yoursite.com/2016/06/01/79-Longest-Common-Substring/"/>
    <id>http://yoursite.com/2016/06/01/79-Longest-Common-Substring/</id>
    <published>2016-06-02T01:04:45.000Z</published>
    <updated>2016-06-02T08:06:14.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出两个字符串，找到最长公共子串，并返回其长度。</p>
</blockquote>
<p><strong>样例</strong><br>给出A=<strong>“ABCD”
</strong>，B=<strong>“CBCE”</strong>，返回 2</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>典型的双序列行动态规划 - Two Sequence DP</li>
<li>不同于Longest Common Subsequence, 本题是substring，string要求是连续的，sequence可以是不连续的</li>
<li>本题的状态表示类似于Longest Increasing Subsequence</li>
<li>cache[i][j]表示string1的前i个字符和string2的前j个字符的LCS，注意<strong>必须以i/j结尾</strong></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/424375-66d6d2de1756c444.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cache"></p>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, B: Two string.</span></span><br><span class="line">    <span class="comment"># @return: the length of the longest common substring.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubstring</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A) + <span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(B) + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(B) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(A) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> A[j - <span class="number">1</span>] == B[i - <span class="number">1</span>]:</span><br><span class="line">                    cache[i][j] = cache[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                res = max(res, cache[i][j])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出两个字符串，找到最长公共子串，并返回其长度。</p>
</blockquote>
<p><strong>样例</strong><br>给出A=<strong>“ABCD”
</strong>，B=<stro]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Two Sequence DP" scheme="http://yoursite.com/tags/Two-Sequence-DP/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[72 Edit Distance]]></title>
    <link href="http://yoursite.com/2016/05/31/72-Edit-Distance/"/>
    <id>http://yoursite.com/2016/05/31/72-Edit-Distance/</id>
    <published>2016-06-01T02:25:32.000Z</published>
    <updated>2016-06-01T09:27:57.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出两个单词word1和word2，计算出将word1转换为word2的最少操作次数。<br>你总共三种操作方法：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
</blockquote>
<p><strong>样例</strong><br>给出 work1=”mart” 和 work2=”karma”<br>返回 3</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>上面的例子 mart =&gt; kart =&gt; karm =&gt; karma</li>
<li>求<strong>最少</strong>步骤 + 给出两个字符串 =&gt; Dynamic Programming (Two Sequence DP)</li>
<li>状态：cache[i][j] 表示字符串a[1]-a[i]转换为b[1]-b[i]的编辑距离，在一个二维矩阵中cache[i][j]只与其<strong>左上</strong>，<strong>左</strong>和<strong>上</strong>三个位置的值有关，分别是cache[i - 1][j - 1], cache[i][j - 1]和cache[i - 1][j]</li>
<li>当word1[i] == word2[j]的时候：<code>cache[j][i] = min(cache[j - 1][i - 1], cache[j - 1][i] + 1, cache[j][i - 1] + 1)</code></li>
<li>不等于的时候 <code>cache[j][i] = min(cache[j - 1][i - 1], cache[j - 1][i], cache[j][i - 1]) + 1</code></li>
<li>起始、边界值<br><strong>DP[0][j] = j</strong>： word1为空，要转化到word2[1:j]，需要添加j个字符。<br><strong>DP[i][0] = i</strong>： word2为空，要从word1转化到空字符串，需要删除i个字符。</li>
</ul>
<p>(另外一个，举例子也比较清楚的](<a href="http://www.dreamxu.com/books/dsa/dp/edit-distance.html" target="_blank" rel="external">http://www.dreamxu.com/books/dsa/dp/edit-distance.html</a>)</p>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDistance</span><span class="params">(self, word1, word2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type word1: str</span><br><span class="line">        :type word2: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word1:</span><br><span class="line">            <span class="keyword">return</span> len(word2)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word2:</span><br><span class="line">            <span class="keyword">return</span> len(word1)</span><br><span class="line">            </span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word1) + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(word2) + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(word1) + <span class="number">1</span>):</span><br><span class="line">            cache[<span class="number">0</span>][i] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(word2) + <span class="number">1</span>):</span><br><span class="line">            cache[j][<span class="number">0</span>] = j</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(word2) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(word1) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]:</span><br><span class="line">                    cache[j][i] = min(cache[j - <span class="number">1</span>][i - <span class="number">1</span>], cache[j - <span class="number">1</span>][i] + <span class="number">1</span>, cache[j][i - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cache[j][i] = min(cache[j - <span class="number">1</span>][i - <span class="number">1</span>], cache[j - <span class="number">1</span>][i], cache[j][i - <span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cache[len(word2)][len(word1)]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出两个单词word1和word2，计算出将word1转换为word2的最少操作次数。<br>你总共三种操作方法：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Two Sequence DP" scheme="http://yoursite.com/tags/Two-Sequence-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[87 Remove Node in Binary Search Tree]]></title>
    <link href="http://yoursite.com/2016/05/30/87-Remove-Node-in-Binary-Search-Tree/"/>
    <id>http://yoursite.com/2016/05/30/87-Remove-Node-in-Binary-Search-Tree/</id>
    <published>2016-05-30T14:39:44.000Z</published>
    <updated>2016-05-30T21:42:00.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一棵具有不同节点值的二叉查找树，删除树中与给定值相同的节点。如果树中没有相同值的节点，就不做任何处理。你应该保证处理之后的树仍是二叉查找树。</p>
</blockquote>
<p>样例<br>给出如下二叉查找树：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">5</span></span><br><span class="line">    /   \</span><br><span class="line">   <span class="number">3</span>     <span class="number">6</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>删除节点3之后，你可以返回：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">5</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">6</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">5</span></span><br><span class="line">    /   \</span><br><span class="line">  <span class="number">4</span>       <span class="number">6</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>首先Inorder遍历整棵树，当数值不等于想要删除的节点的数值时，把节点加入数组</li>
<li>利用刚刚构建的中序遍历的数组重新建立新的搜索二叉树</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root: The root of the binary search tree.</span><br><span class="line">    @param value: Remove the node with given value.</span><br><span class="line">    @return: The root of the binary search tree after removal.</span><br><span class="line">    """</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        self.inorder(root.left, value)</span><br><span class="line">        <span class="keyword">if</span> root.val != value:</span><br><span class="line">            self.ans.append(root.val)</span><br><span class="line">        self.inorder(root.right, value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            node = TreeNode(self.ans[l])</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        <span class="keyword">if</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        mid = (l+r) / <span class="number">2</span></span><br><span class="line">        node = TreeNode(self.ans[mid])</span><br><span class="line">        node.left = self.build(l, mid-<span class="number">1</span>)</span><br><span class="line">        node.right = self.build(mid+<span class="number">1</span>, r)</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNode</span><span class="params">(self, root, value)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        self.inorder(root, value)</span><br><span class="line">        <span class="keyword">return</span> self.build(<span class="number">0</span>, len(self.ans)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一棵具有不同节点值的二叉查找树，删除树中与给定值相同的节点。如果树中没有相同值的节点，就不做任何处理。你应该保证处理之后的树仍是二叉查找树。</p>
</blockquote>
<p>样例<br>给出如下二]]>
    </summary>
    
      <category term="BST" scheme="http://yoursite.com/tags/BST/"/>
    
      <category term="Binary Search Tree" scheme="http://yoursite.com/tags/Binary-Search-Tree/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[474 Lowest Common Ancestor II]]></title>
    <link href="http://yoursite.com/2016/05/29/474-Lowest-Common-Ancestor-II/"/>
    <id>http://yoursite.com/2016/05/29/474-Lowest-Common-Ancestor-II/</id>
    <published>2016-05-29T19:01:48.000Z</published>
    <updated>2016-05-30T02:02:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一棵二叉树和二叉树中的两个节点，找到这两个节点的最近公共祖先LCA。</p>
<p>两个节点的最近公共祖先，是指两个节点的所有父亲节点中（包括这两个节点），离这两个节点最近的公共的节点。</p>
<p>每个节点除了左右儿子指针以外，还包含一个父亲指针parent，指向自己的父亲。</p>
</blockquote>
<p>对于下面的这棵二叉树<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">4</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">3</span>   <span class="number">7</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">5</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>LCA(3, 5) = 4<br>LCA(5, 6) = 7<br>LCA(6, 7) = 7</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>根据p，一路向上找到所有的parent，得到一个list</li>
<li>根据q，一路向上找到所有的parent，得到一个list</li>
<li>从左向右看两个list，最先一样的node即为公共祖先</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of ParentTreeNode:</span><br><span class="line">class ParentTreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        this.val = val</span><br><span class="line">        this.parent, this.left, this.right = None, None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root: The root of the tree</span><br><span class="line">    @param A and B: Two node in the tree</span><br><span class="line">    @return: The lowest common ancestor of A and B</span><br><span class="line">    """</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestorII</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        list = []</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            list.append(p)</span><br><span class="line">            p = p.parent</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">in</span> list:</span><br><span class="line">                <span class="keyword">return</span> q</span><br><span class="line">            q = q.parent</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一棵二叉树和二叉树中的两个节点，找到这两个节点的最近公共祖先LCA。</p>
<p>两个节点的最近公共祖先，是指两个节点的所有父亲节点中（包括这两个节点），离这两个节点最近的公共的节点。</p>
<p>每个节]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[331 Verify Preorder Serialization of a Binary Tree]]></title>
    <link href="http://yoursite.com/2016/05/29/331-Verify-Preorder-Serialization-of-a-Binary-Tree/"/>
    <id>http://yoursite.com/2016/05/29/331-Verify-Preorder-Serialization-of-a-Binary-Tree/</id>
    <published>2016-05-29T17:43:57.000Z</published>
    <updated>2016-05-30T00:45:05.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>先序遍历是序列化二叉树的方式之一。当遇到非空节点时，记录节点的值。如果是空节点，我们将其记为#。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    /   \</span><br><span class="line">   <span class="number">3</span>     <span class="number">2</span></span><br><span class="line">  / \   / \</span><br><span class="line"> <span class="number">4</span>   <span class="number">1</span>  <span class="comment">#  6</span></span><br><span class="line">/ \ / \   / \</span><br><span class="line"><span class="comment"># # # #   # #</span></span><br></pre></td></tr></table></figure></p>
<p>例如，题目描述中的样例二叉树可以序列化为字符串 “9,3,4,#,#,1,#,#,2,#,6,#,#”，其中#代表空节点。</p>
<p>给定一个逗号分隔值字符串，校验其是否是一个正确的二叉树先序遍历序列化字符串。设计一个不需要重建树的算法。</p>
<p>每一个逗号分隔值字符串中的值或者是整数，或者是字符’#’，代表空节点。</p>
<p>你可以假设输入格式总是有效的，例如，不可能出现两个连续的逗号，比如”1,,3”。</p>
</blockquote>
<p>例1：<br><code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code><br>Return true</p>
<p>例2：<br><code>&quot;1,#&quot;</code><br>Return false</p>
<p>例3：<br><code>&quot;9,#,#,1&quot;</code><br>Return false</p>
<h3 id="解题思路">解题思路</h3><ul>
<li><p>方法一：利用Stack, 把序列化的结果不断压入栈，但栈内元素大于等于3的时候，如果遇到x # # =&gt; #，此过程相当于在逐步砍掉叶节点，过程如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">8</span>            <span class="number">8</span>          <span class="comment">#</span></span><br><span class="line">     / \          / \   </span><br><span class="line">    <span class="number">9</span>   <span class="comment">#   =&gt;   #   #  =&gt;   </span></span><br><span class="line">   / \</span><br><span class="line"><span class="comment">#   #</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：统计树的出度（out-degree）和入度（in-degree）</p>
<ul>
<li>根节点提供2个出度和0个入度（但初始时diff=1）</li>
<li>所有的非空节点提供2个出度和1个入度</li>
<li>所有的空节点但提供0个出度和1个入度</li>
<li>当遍历节点时，每次diff - 1（因为节点提供了一个入度）。</li>
<li>如果节点非#，diff + 2（因为非空节点提供了2个出度）</li>
<li>如果序列化是正确的，那么diff在任何时刻都不会小于0，并且最终结果等于0</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSerialization</span><span class="params">(self, preorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type preorder: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> preorder.split(<span class="string">","</span>):</span><br><span class="line">            stack.append(node)</span><br><span class="line">            <span class="keyword">while</span> len(stack) &gt;= <span class="number">3</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == stack[-<span class="number">2</span>] == <span class="string">"#"</span> <span class="keyword">and</span> stack[-<span class="number">3</span>] != <span class="string">"#"</span>:</span><br><span class="line">                stack = stack[:-<span class="number">3</span>] +[<span class="string">'#'</span>]</span><br><span class="line">        <span class="keyword">return</span> len(stack) == <span class="number">1</span> <span class="keyword">and</span> stack[-<span class="number">1</span>] == <span class="string">"#"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># method 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSerialization</span><span class="params">(self, preorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type preorder: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        diff = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> preorder.split(<span class="string">","</span>):</span><br><span class="line">            diff -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> diff &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> node != <span class="string">"#"</span>:</span><br><span class="line">                diff += <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> diff == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>先序遍历是序列化二叉树的方式之一。当遇到非空节点时，记录节点的值。如果是空节点，我们将其记为#。<br><figure class="highlight python"><table><tr><td class]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[297 Serialize and Deserialize Binary Tree]]></title>
    <link href="http://yoursite.com/2016/05/29/297-Serialize-and-Deserialize-Binary-Tree/"/>
    <id>http://yoursite.com/2016/05/29/297-Serialize-and-Deserialize-Binary-Tree/</id>
    <published>2016-05-29T16:24:06.000Z</published>
    <updated>2016-05-29T23:25:39.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>设计一个算法，并编写代码来序列化和反序列化二叉树。将树写入一个文件被称为“序列化”，读取文件后重建同样的二叉树被称为“反序列化”。<br>如何反序列化或序列化二叉树是没有限制的，你只需要确保可以将二叉树序列化为一个字符串，并且可以将字符串反序列化为原来的树结构。</p>
</blockquote>
<p>样例,给出一个测试数据样例， 二叉树{3,9,20,#,#,15,7}，表示如下的树结构：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>序列化：Recursion - 先序遍历，null用#代替，上面的例子先序遍历后成为[3, 9, #, #, 20, 15, #, #, 7, #, #]</li>
<li>反序列化： 根据[3, 9, #, #, 20, 15, #, #, 7, #, #]反序列化，采用先序遍历的思想每次读取一个结点，如果读取到#，忽略。如果读取到结点数值，则插入到当前结点，然后遍历左孩子和右孩子。</li>
<li>BFS，二叉树的层次遍历, 序列化为[3, 9, 20, #, #, 15, 7, #, #, #, #]</li>
<li>Python中的两个内置函数 - iter() 和 next()<ul>
<li>iter() takes an iterable object and returns an iterator. </li>
<li>Each time we call the next() method on the iterator gives us the next element. </li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span><br><span class="line">        </span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(str(node.val))</span><br><span class="line">                dfs(node.left)</span><br><span class="line">                dfs(node.right)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="string">"#"</span>)</span><br><span class="line">        res = []</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">' '</span>.join(res)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span><br><span class="line">        </span><br><span class="line">        :type data: str</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(data) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">()</span>:</span></span><br><span class="line">            val = next(res)</span><br><span class="line">            <span class="keyword">if</span> val == <span class="string">'#'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            node = TreeNode(int(val))</span><br><span class="line">            node.left = dfs()</span><br><span class="line">            node.right = dfs()</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        res = iter(data.split())</span><br><span class="line">        <span class="keyword">return</span> dfs()</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># codec = Codec()</span></span><br><span class="line"><span class="comment"># codec.deserialize(codec.serialize(root))</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>设计一个算法，并编写代码来序列化和反序列化二叉树。将树写入一个文件被称为“序列化”，读取文件后重建同样的二叉树被称为“反序列化”。<br>如何反序列化或序列化二叉树是没有限制的，你只需要确保可以将二叉树序列化为]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[467 Complete Binary Tree]]></title>
    <link href="http://yoursite.com/2016/05/28/467-Complete-Binary-Tree/"/>
    <id>http://yoursite.com/2016/05/28/467-Complete-Binary-Tree/</id>
    <published>2016-05-28T17:32:57.000Z</published>
    <updated>2016-05-29T00:34:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>检查一棵二叉树是不是完全二叉树。完全二叉树是指一棵树除了最后一层，其它层上节点都有左右孩子，最后一层上，所有节点都必须尽量靠左。</p>
</blockquote>
<p>样例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> /</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>是完全二叉树<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>不是完全二叉树</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>理清思路：<ul>
<li>满二叉树：每个节点都有0或是2个孩子。</li>
<li>完全二叉树：所有的叶子都拥有同的深度，所有的内部节点拥有 2个孩子</li>
</ul>
</li>
<li>BFS - 广度优先搜索，对于一棵树，层层遍历，把每层的节点从左向右依此加入Stack，然后把Stack上层的<code>None</code>弹出，最后检查如果Stack中还有<code>None</code>说明不是Complete Tree</li>
<li>比如上面的不完全二叉树生成的数组为[1, 2, 3, None, 4, None, None]，将右侧None弹出后为[1, 2, 3, None, 4]，循环查找，发现还有None存在，所以是不完全二叉树</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        this.val = val</span><br><span class="line">        this.left, this.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root, the root of binary tree.</span><br><span class="line">    @return true if it is a complete binary tree, or false.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isComplete</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        list = [root]</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &lt; len(list):</span><br><span class="line">            <span class="keyword">if</span> list[index]:</span><br><span class="line">                list.append(list[index].left)</span><br><span class="line">                list.append(list[index].right)</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">while</span> list[-<span class="number">1</span>] <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            list.pop()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> list:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>检查一棵二叉树是不是完全二叉树。完全二叉树是指一棵树除了最后一层，其它层上节点都有左右孩子，最后一层上，所有节点都必须尽量靠左。</p>
</blockquote>
<p>样例<br><figure class]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[101 Symmetric Tree]]></title>
    <link href="http://yoursite.com/2016/05/27/101-Symmetric-Tree/"/>
    <id>http://yoursite.com/2016/05/27/101-Symmetric-Tree/</id>
    <published>2016-05-28T02:05:11.000Z</published>
    <updated>2016-05-28T09:17:45.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个二叉树，检查他是不是自己的镜像(轴对称)</p>
</blockquote>
<p>样例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>是对称二叉树<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>不是对称二叉树</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>写一个helper函数，递归求解，但注意helper函数的形参left和right不是指的左儿子和右儿子。那上面的例子为例，我们要传入3，3和4，4</li>
<li>Divide and Conquer的思路 - 如果<code>left.left, right.right</code>和<code>left.right, right.left</code>都对称则整棵树对称</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">return</span> self.helper(root.left, root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right <span class="keyword">and</span> left.val == right.val:</span><br><span class="line">            <span class="keyword">return</span> self.helper(left.left, right.right) <span class="keyword">and</span> \</span><br><span class="line">                    self.helper(left.right, right.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个二叉树，检查他是不是自己的镜像(轴对称)</p>
</blockquote>
<p>样例<br><figure class="highlight python"><table><tr><td class]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[469 Identical Binary Tree]]></title>
    <link href="http://yoursite.com/2016/05/27/469-Identical-Binary-Tree/"/>
    <id>http://yoursite.com/2016/05/27/469-Identical-Binary-Tree/</id>
    <published>2016-05-28T01:34:08.000Z</published>
    <updated>2016-05-28T08:35:02.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>检查两棵二叉树是否等价。等价的意思是说，首先两棵二叉树必须拥有相同的结构，并且每个对应位置上的节点上的数都相等。</p>
</blockquote>
<p>样例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">   / \           / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span>   <span class="keyword">and</span>   <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> /             /</span><br><span class="line"><span class="number">4</span>             <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>就是两棵等价的二叉树。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">   / \           / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span>   <span class="keyword">and</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> /               \</span><br><span class="line"><span class="number">4</span>                 <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>就不是等价的。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>如果两棵树都是None，认为是等价的</li>
<li>Recursion - 递归求解，分治的思路，如果<code>a.val == b.val</code>，则只需考虑左右子树是不是Identical Binary Tree</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        this.val = val</span><br><span class="line">        this.left, this.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param a, b, the root of binary trees.</span><br><span class="line">    @return true if they are identical, or false.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIdentical</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> b <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">and</span> b <span class="keyword">and</span> a.val == b.val:</span><br><span class="line">            <span class="keyword">return</span> self.isIdentical(a.left, b.left) <span class="keyword">and</span> self.isIdentical(a.right, b.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>检查两棵二叉树是否等价。等价的意思是说，首先两棵二叉树必须拥有相同的结构，并且每个对应位置上的节点上的数都相等。</p>
</blockquote>
<p>样例<br><figure class="highli]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[470 Tweaked Identical Binary Tree]]></title>
    <link href="http://yoursite.com/2016/05/27/470-Tweaked-Identical-Binary-Tree/"/>
    <id>http://yoursite.com/2016/05/27/470-Tweaked-Identical-Binary-Tree/</id>
    <published>2016-05-28T01:32:42.000Z</published>
    <updated>2016-05-28T08:33:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>检查两棵二叉树是否在经过若干次扭转后可以等价。扭转的定义是，交换任意节点的左右子树。等价的定义是，两棵二叉树必须为相同的结构，并且对应位置上的节点的值要相等。<br>注意：你可以假设二叉树中不会有重复的节点值。</p>
</blockquote>
<p>样例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">   / \           / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span>   <span class="keyword">and</span>   <span class="number">3</span>   <span class="number">2</span></span><br><span class="line"> /                   \</span><br><span class="line"><span class="number">4</span>                     <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>是扭转后可等价的二叉树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">   / \           / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span>   <span class="keyword">and</span>   <span class="number">3</span>   <span class="number">2</span></span><br><span class="line"> /             /</span><br><span class="line"><span class="number">4</span>             <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>就不是扭转后可以等价的二叉树。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>Recursion - 递归求解，分治的思路。</li>
<li>注意，题目中说的是经过若干次扭转后可以等价，所以不要忘记考虑完全identical的情况，某一个节点的左右子树翻转一次对称，反转两次还原。</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        this.val = val</span><br><span class="line">        this.left, this.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param a, b, the root of binary trees.</span><br><span class="line">    @return true if they are tweaked identical, or false.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isTweakedIdentical</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> b <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">and</span> b <span class="keyword">and</span> a.val == b.val:</span><br><span class="line">            <span class="keyword">return</span> self.isTweakedIdentical(a.left, b.right) <span class="keyword">and</span> \</span><br><span class="line">                    self.isTweakedIdentical(a.right, b.left) <span class="keyword">or</span> \</span><br><span class="line">                    self.isTweakedIdentical(a.left, b.left) <span class="keyword">and</span> \</span><br><span class="line">                    self.isTweakedIdentical(a.right, b.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>检查两棵二叉树是否在经过若干次扭转后可以等价。扭转的定义是，交换任意节点的左右子树。等价的定义是，两棵二叉树必须为相同的结构，并且对应位置上的节点的值要相等。<br>注意：你可以假设二叉树中不会有重复的节点值。]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[376 Binary Tree Path Sum]]></title>
    <link href="http://yoursite.com/2016/05/27/376-Binary-Tree-Path-Sum/"/>
    <id>http://yoursite.com/2016/05/27/376-Binary-Tree-Path-Sum/</id>
    <published>2016-05-27T22:36:31.000Z</published>
    <updated>2016-05-28T05:38:44.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个二叉树，找出所有路径中各节点相加总和等于给定 目标值<br> 的路径。<br>一个有效的路径，指的是从根节点到叶节点的路径。</p>
</blockquote>
<p>给定一个二叉树，和目标值 = 5<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>返回<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>DFS - 递归求解 </li>
<li>类似于求subset的思路，维护一个path，从根节点向下分别沿左右子树搜索。在确保当前节点不为空的情况下，求剩余值<code>remaining = target - root.val</code><ul>
<li>如果剩余值为0 - 把当前的path加入到result中</li>
<li>如果剩余值不为0 - 继续向下朝左右子树寻找，target传入remaining的值</li>
</ul>
</li>
<li>注意每次path要加入root.val，但是每次返回上一层要pop出去刚刚加入的值，或者换一种方式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.helper(root.left, remaining, result, path+[root.val])</span><br><span class="line">    self.helper(root.right, remaining, result, path+[root.val])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;TreeNode&#125; root the root of binary tree</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int[][]&#125; all valid paths</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePathSum</span><span class="params">(self, root, target)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        res = []</span><br><span class="line">        self.helper(root, target, res, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, target, result, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            remaining = target - root.val</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">0</span>:</span><br><span class="line">                result.append(path+[root.val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                path.append(root.val)</span><br><span class="line">                self.helper(root.left, remaining, result, path)</span><br><span class="line">                self.helper(root.right, remaining, result, path)</span><br><span class="line">                path.pop()</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个二叉树，找出所有路径中各节点相加总和等于给定 目标值<br> 的路径。<br>一个有效的路径，指的是从根节点到叶节点的路径。</p>
</blockquote>
<p>给定一个二叉树，和目标值 = 5<]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C#中的Indexer索引器]]></title>
    <link href="http://yoursite.com/2016/05/19/C-%E4%B8%AD%E7%9A%84Indexer%E7%B4%A2%E5%BC%95%E5%99%A8/"/>
    <id>http://yoursite.com/2016/05/19/C-中的Indexer索引器/</id>
    <published>2016-05-19T23:54:04.000Z</published>
    <updated>2016-05-20T06:56:03.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>C#的索引器允许我们对一个<strong>实例</strong>像数组一样进行索引。当我们在一个类中定义了索引器之后，我们可以通过数组操作符([ ])像操作数组一样来访问这个类的实例。</p>
<ul>
<li>索引器的好处就是简化的数组和集合成员的存取操作。</li>
<li>索引器可被重载。</li>
<li>索引器可以有多个形参，例如当访问二维数组时。</li>
</ul>
<h1 id="syntax_–_from_MSDN">syntax – from MSDN</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">this</span>[<span class="keyword">int</span> index]    <span class="comment">// Indexer declaration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get and set accessors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例子">例子</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Example</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Class Student</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> Number &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Sex &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">indexerExample</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 注意下面的数组是private，体现encapsulation, OOP原则</span></span><br><span class="line">       <span class="keyword">private</span> List&lt;Student&gt; students= <span class="keyword">new</span> List&lt;Student&gt;();</span><br><span class="line">       students.Add( <span class="keyword">new</span> Student &#123; Number = <span class="number">1</span>,</span><br><span class="line">                                   Name = <span class="string">"Jason"</span>,</span><br><span class="line">                                   Sex = <span class="string">"Male"</span> &#125;);</span><br><span class="line">       students.Add( <span class="keyword">new</span> Student &#123; Number = <span class="number">2</span>,</span><br><span class="line">                                   Name = <span class="string">"Maggie"</span>,</span><br><span class="line">                                   Sex = <span class="string">"Female"</span> &#125;);</span><br><span class="line">       students.Add( <span class="keyword">new</span> Student &#123; Number = <span class="number">3</span>,</span><br><span class="line">                                   Name = <span class="string">"Lucy"</span>,</span><br><span class="line">                                   Sex = <span class="string">"Female "</span>&#125;);</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span>(<span class="params"><span class="keyword">string</span> name</span>)</span><br><span class="line">       </span>&#123;</span><br><span class="line">           <span class="keyword">foreach</span> student <span class="keyword">in</span> students</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (student.Name == name)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> student;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span>(<span class="params"><span class="keyword">int</span> num</span>)</span><br><span class="line">       </span>&#123;</span><br><span class="line">           <span class="keyword">foreach</span> student <span class="keyword">in</span> students</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (student.Number == num)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> student;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//define indexer</span></span><br><span class="line">       <span class="keyword">public</span> student <span class="keyword">this</span>[<span class="keyword">int</span> num]  </span><br><span class="line">       &#123;  </span><br><span class="line">           <span class="keyword">get</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">foreach</span> student <span class="keyword">in</span> students</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (student.Number == num)</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">return</span> student;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overload indexer</span></span><br><span class="line">       <span class="keyword">public</span> student <span class="keyword">this</span>[<span class="keyword">string</span> name]</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">get</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">foreach</span> student <span class="keyword">in</span> students</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (student.Name == name)</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">return</span> student;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)  </span><br><span class="line">        </span>&#123;  </span><br><span class="line">            Student myStudents = <span class="keyword">new</span> indexerExample();  </span><br><span class="line">            </span><br><span class="line">            Console.WriteLine(myStudents.getStudent(<span class="number">1</span>).Sex);</span><br><span class="line">            Console.WriteLine(myStudents[<span class="number">1</span>].Sex);</span><br><span class="line">            Console.WriteLine(myStudent.getStudent(<span class="string">"Maggie"</span>).Sex);</span><br><span class="line">            Console.WriteLine(myStudents[<span class="string">"Maggie"</span>].Sex);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// "Male"</span></span><br><span class="line"><span class="comment">// "Male"</span></span><br><span class="line"><span class="comment">// "Female"</span></span><br><span class="line"><span class="comment">// "Female"</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>C#的索引器允许我们对一个<strong>实例</strong>像数组一样进行索引。当我们在一个类中定义了索引器之后，我们可以通过数组操作符([ ])像操作数组一样来访问这个类的实例。</p>
<ul>
<li>索引器的好处就是简化的数组和集合成员的存取操作。</]]>
    </summary>
    
      <category term="C#学习笔记" scheme="http://yoursite.com/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Indexer" scheme="http://yoursite.com/tags/Indexer/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[460  K Closest Numbers In Sorted Array]]></title>
    <link href="http://yoursite.com/2016/05/18/460-K-Closest-Numbers-In-Sorted-Array/"/>
    <id>http://yoursite.com/2016/05/18/460-K-Closest-Numbers-In-Sorted-Array/</id>
    <published>2016-05-19T01:38:34.000Z</published>
    <updated>2016-05-19T08:39:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一个目标数 target, 一个非负整数 k, 一个按照升序排列的数组 A。在A中找与target最接近的k个整数。返回这k个数并按照与target的接近程度从小到大排序，如果接近程度相当，那么小的数排在前面。</p>
</blockquote>
<ul>
<li>如果 A = [1, 2, 3], target = 2 and k = 3, 那么返回 [2, 1, 3]</li>
<li>如果 A = [1, 4, 6, 8], target = 3 and k = 3, 那么返回 [4, 1, 6]</li>
</ul>
<h3 id="解题思路">解题思路</h3><ul>
<li>使用Binary Search找到最接近的数字的位置</li>
<li>双指针从该位置左右移动，每次比较找到最接近的数字，加入到答案中，相应的指针++</li>
<li>中间while循环可以略作简化，通过优先处理特殊情况<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> left &lt; <span class="number">0</span>:</span><br><span class="line">                res.append(A[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> right &gt; len(A) - <span class="number">1</span>:</span><br><span class="line">                res.append(A[left])</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> abs(A[left] - target) &lt;= abs(A[right] - target):</span><br><span class="line">                    res.append(A[left])</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(A[right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; A an integer array</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; k a non-negative integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int[]&#125; an integer array</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosestNumbers</span><span class="params">(self, A, target, k)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">        res = []</span><br><span class="line">        index = self.binarySearch(A, target)</span><br><span class="line">        res.append(A[index])</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        left, right = index - <span class="number">1</span>, index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt;= len(A) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> abs(A[left] - target) &lt;= abs(A[right] - target):</span><br><span class="line">                    res.append(A[left])</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(A[right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">while</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> right &lt;= len(A) - <span class="number">1</span>:</span><br><span class="line">                    res.append(A[right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> right &gt; len(A) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">while</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> left &gt;= <span class="number">0</span>:</span><br><span class="line">                    res.append(A[left])</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(self, L, target)</span>:</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(L) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> L[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> L[mid] &gt; target:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> start <span class="keyword">if</span> abs(L[start] - target) &lt;= abs(L[end] - target) <span class="keyword">else</span> end</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一个目标数 target, 一个非负整数 k, 一个按照升序排列的数组 A。在A中找与target最接近的k个整数。返回这k个数并按照与target的接近程度从小到大排序，如果接近程度相当，那么小的数排在前面]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[462 Total Occurrence of Target]]></title>
    <link href="http://yoursite.com/2016/05/18/462-Total-Occurrence-of-Target/"/>
    <id>http://yoursite.com/2016/05/18/462-Total-Occurrence-of-Target/</id>
    <published>2016-05-19T01:00:05.000Z</published>
    <updated>2016-05-19T08:00:53.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个目标数字和一个升序整数数组，返回目标数字在数组中出现的次数。</p>
</blockquote>
<ul>
<li>给出 [1, 3, 3, 4, 5] 并且 target = 3, 返回 2.</li>
<li>给出 [2, 2, 3, 4, 6] 并且 target = 4, 返回 1</li>
<li>给出 [1, 2, 3, 4, 5] 并且 target = 6, 返回 0</li>
</ul>
<h3 id="解题思路">解题思路</h3><ul>
<li>二分法， 分两步：找到第一个出现的位置， 找到最后一个出现的位置。就可以计算出出现频率</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; A an integer array sorted in ascending order</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalOccurrence</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] &lt;= target:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> A[end] == target:</span><br><span class="line">            right = end</span><br><span class="line">        <span class="keyword">elif</span> A[start] == target:</span><br><span class="line">            right = start</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] &gt;= target:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> A[start] == target:</span><br><span class="line">            left = start</span><br><span class="line">        <span class="keyword">elif</span> A[end] == target:</span><br><span class="line">            left = end</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个目标数字和一个升序整数数组，返回目标数字在数组中出现的次数。</p>
</blockquote>
<ul>
<li>给出 [1, 3, 3, 4, 5] 并且 target = 3, 返回 2.</li]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[459 Closest Number in Sorted Array]]></title>
    <link href="http://yoursite.com/2016/05/18/459-Closest-Number-in-Sorted-Array/"/>
    <id>http://yoursite.com/2016/05/18/459-Closest-Number-in-Sorted-Array/</id>
    <published>2016-05-19T00:47:02.000Z</published>
    <updated>2016-05-19T07:47:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个目标数字和一个整数升序数组，找到一个i使得A[i]与目标数字最为接近。</p>
</blockquote>
<ul>
<li>给出 [1, 2, 3] 并且 target = 2, 返回 1</li>
<li>给出 [1, 4, 6] 并且 target = 3, 返回 1</li>
<li>给出 [1, 4, 6] 并且 target = 5, 返回 1 or 2</li>
<li>给出 [1, 3, 3, 4] 并且 target = 2, 返回 0 or 1 or 2</li>
</ul>
<h3 id="解题思路">解题思路</h3><ul>
<li>二分法，直接找target，找到返回index，如果没有找到则target在<strong>A[start]和A[end]之间</strong>，比较之后，返回正确的index</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; A an integer array sorted in ascending order</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestNumber</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> A[mid] &gt; target:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> start <span class="keyword">if</span> abs(A[start] - target) &lt; abs(A[end] - target) <span class="keyword">else</span> end</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个目标数字和一个整数升序数组，找到一个i使得A[i]与目标数字最为接近。</p>
</blockquote>
<ul>
<li>给出 [1, 2, 3] 并且 target = 2, 返回 1</li>
]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[458 Last Position of Target]]></title>
    <link href="http://yoursite.com/2016/05/18/458-Last-Position-of-Target/"/>
    <id>http://yoursite.com/2016/05/18/458-Last-Position-of-Target/</id>
    <published>2016-05-19T00:21:55.000Z</published>
    <updated>2016-05-19T07:23:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个排序数组中找一个数，返回该数出现的最后一个位置，如果不存在，返回-1</p>
</blockquote>
<p>给出数组 [1, 2, 2, 4, 5, 5]</p>
<ul>
<li>对于 target = 2, 返回 2.</li>
<li>对于 target = 5, 返回 5.</li>
<li>对于 target = 6, 返回 -1.</li>
</ul>
<h3 id="解题思路">解题思路</h3><ul>
<li>二分法，对于找最后一个位置的要求：<strong>只有target大于A[end]才会<code>end = mid</code></strong></li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; A an integer array sorted in ascending order</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastPosition</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] &lt;= target:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> A[end] == target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">if</span> A[start] == target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个排序数组中找一个数，返回该数出现的最后一个位置，如果不存在，返回-1</p>
</blockquote>
<p>给出数组 [1, 2, 2, 4, 5, 5]</p>
<ul>
<li>对于 target]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[457 Classical Binary Search]]></title>
    <link href="http://yoursite.com/2016/05/18/457-Classical-Binary-Search/"/>
    <id>http://yoursite.com/2016/05/18/457-Classical-Binary-Search/</id>
    <published>2016-05-19T00:09:36.000Z</published>
    <updated>2016-05-19T07:10:50.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个排序数组中找一个数，返回该数出现的任意位置，如果不存在，返回-1</p>
</blockquote>
<p>给出数组 [1, 2, 2, 4, 5, 5]</p>
<ul>
<li>对于 target = 2, 返回 1 或者 2.</li>
<li>对于 target = 5, 返回 4 或者 5.</li>
<li>对于 target = 6, 返回 -1.</li>
</ul>
<h3 id="解题思路">解题思路</h3><ul>
<li>标准的二分法解决 - Binary Search 模板程序</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; A an integer array sorted in ascending order</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPosition</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> A == []:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> A[mid] &gt; target:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> A[start] == target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> A[end] == target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个排序数组中找一个数，返回该数出现的任意位置，如果不存在，返回-1</p>
</blockquote>
<p>给出数组 [1, 2, 2, 4, 5, 5]</p>
<ul>
<li>对于 target =]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
</feed>
