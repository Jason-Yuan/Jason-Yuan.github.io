<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Chemistry]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-07-10T01:03:12.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Jason Yuan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[133 Clone Graph]]></title>
    <link href="http://yoursite.com/2016/07/09/133-Clone-Graph/"/>
    <id>http://yoursite.com/2016/07/09/133-Clone-Graph/</id>
    <published>2016-07-09T18:02:08.000Z</published>
    <updated>2016-07-10T01:03:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>克隆一张无向图，图中的每个节点包含一个 label 和一个表 neighbors。<br>你的程序需要返回一个经过深度拷贝的新图。这个新图和原图具有同样的结构，并且对新图的任何改动不会对原图造成任何影响。</p>
</blockquote>
<p><strong>样例</strong><br>比如，序列化图 {0,1,2#1,2#2,2} 共有三个节点, 因此包含两个个分隔符#。<br>第一个节点label为0，存在边从节点0链接到节点1和节点2<br>第二个节点label为1，存在边从节点1连接到节点2<br>第三个节点label为2，存在边从节点2连接到节点2(本身),从而形成自环。</p>
<p>我们能看到如下的图：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span></span><br><span class="line">  / \</span><br><span class="line"> /   \</span><br><span class="line"><span class="number">0</span> --- <span class="number">2</span></span><br><span class="line">     / \</span><br><span class="line">     \_/</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>首先，要遍历无向图，需要使用Hash Map来当作visited数组，防止重复访问而造成程序中的死循环</li>
<li>遍历图有两种方式 - BFS &amp; DFS，本题均可采用<ul>
<li>BFS - 使用Queue (prefer)</li>
<li>DFS - 递归或者使用Stack，对于DFS，每次clone一个node的时候，就要把它所有的neighbor加入到新clone的node的neighbor中，此时recursivly调用dfs，如果没有visited过 - 新建一个node，否则直接从map中找到返回</li>
</ul>
</li>
<li>在visited数组中，key值为原来的node，value为新clone的node，如果一个node不存在于map中，说明这个node还未被clone，将它clone后放入queue中继续处理neighbors</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Method 1: BFS</span></span><br><span class="line"><span class="comment"># Definition for a undirected graph node</span></span><br><span class="line"><span class="comment"># class UndirectedGraphNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.neighbors = []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.visited = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type node: UndirectedGraphNode</span><br><span class="line">        :rtype: UndirectedGraphNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            </span><br><span class="line">        newHead = UndirectedGraphNode(node.label)</span><br><span class="line">        self.visited[node] = newHead</span><br><span class="line">        </span><br><span class="line">        myQueue = Queue.Queue()</span><br><span class="line">        myQueue.put(node)</span><br><span class="line">        <span class="keyword">while</span> myQueue.qsize():</span><br><span class="line">            current = myQueue.get()</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> current.neighbors:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> self.visited:</span><br><span class="line">                    newNode = UndirectedGraphNode(neighbor.label)</span><br><span class="line">                    self.visited[current].neighbors.append(newNode)</span><br><span class="line">                    self.visited[neighbor] = newNode</span><br><span class="line">                    myQueue.put(neighbor)</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># turn directed graph to undirected graph</span></span><br><span class="line">                    self.visited[current].neighbors.append(self.visited[neighbor])</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> newHead</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2: DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type node: UndirectedGraphNode</span><br><span class="line">        :rtype: UndirectedGraphNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> self.dfs(node, &#123;&#125;)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, node, map)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">in</span> map:</span><br><span class="line">            <span class="keyword">return</span> map[node]</span><br><span class="line">        newNode = UndirectedGraphNode(node.label)</span><br><span class="line">        map[node] = newNode</span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:</span><br><span class="line">            newNode.neighbors.append(self.dfs(neighbor, map))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> newNode</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>克隆一张无向图，图中的每个节点包含一个 label 和一个表 neighbors。<br>你的程序需要返回一个经过深度拷贝的新图。这个新图和原图具有同样的结构，并且对新图的任何改动不会对原图造成任何影响。</p]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[230 Animal Shelter]]></title>
    <link href="http://yoursite.com/2016/07/09/230-Animal-Shelter/"/>
    <id>http://yoursite.com/2016/07/09/230-Animal-Shelter/</id>
    <published>2016-07-09T15:53:58.000Z</published>
    <updated>2016-07-09T22:54:24.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个宠物避难所里，仅有狗和猫两种动物可供领养，且领养时严格执行“先进先出”的规则。如果有人想要从避难所领养动物，他只有两种选择：要么选择领养所有动物中最资深的一只（根据到达避难所的时间，越早到的越资深），要么选择领养猫或狗（同样，也只能领养最资深的一只）。也就是说，领养者不能随意选择某一指定动物。请建立一个数据结构，使得它可以运行以上规则，并可实 enqueue, dequeueAny, dequeueDog, 和 dequeueCat 操作。<br>建议使用 LinkedList 作为数据结构实现。</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int DOG = <span class="number">1</span></span><br><span class="line">int CAT = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">enqueue(<span class="string">"james"</span>, DOG);</span><br><span class="line">enqueue(<span class="string">"tom"</span>, DOG);</span><br><span class="line">enqueue(<span class="string">"mimi"</span>, CAT);</span><br><span class="line">dequeueAny();  <span class="comment"># should return "james"</span></span><br><span class="line">dequeueCat();  <span class="comment"># should return "mimi"</span></span><br><span class="line">dequeueDog();  <span class="comment"># should return "tom"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>使用两个数组分别记录加入的猫和狗，用0和1表示</li>
<li>存储时，在python中可以使用set来同时记录名字和先后顺序(使用数字记录age)，初始tot = 0，之后每次tot += 1，在dequeueAny的时候只需要比较Dog[0]和Cat[0]的tot，值越小表明age越大，pop谁</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalShelter</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># do some intialize if necessary</span></span><br><span class="line">        self.cats = []</span><br><span class="line">        self.dogs = []</span><br><span class="line">        self.tot = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param &#123;string&#125; name</span><br><span class="line">    @param &#123;int&#125; type, 1 if Animal is dog or 0</span><br><span class="line">    @return nothing</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, name, type)</span>:</span></span><br><span class="line">        <span class="comment"># Write yout code here</span></span><br><span class="line">        self.tot += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> type == <span class="number">1</span>:</span><br><span class="line">            self.dogs.append((name, self.tot))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.cats.append((name, self.tot))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeueAny</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(self.dogs) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.dequeueCat()</span><br><span class="line">        <span class="keyword">elif</span> len(self.cats) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.dequeueDog()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.dogs[<span class="number">0</span>][<span class="number">1</span>] &lt; self.cats[<span class="number">0</span>][<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> self.dequeueDog()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> self.dequeueCat()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeueDog</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        name = self.dogs[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">del</span> self.dogs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return a string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeueCat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        name = self.cats[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">del</span> self.cats[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个宠物避难所里，仅有狗和猫两种动物可供领养，且领养时严格执行“先进先出”的规则。如果有人想要从避难所领养动物，他只有两种选择：要么选择领养所有动物中最资深的一只（根据到达避难所的时间，越早到的越资深），要么]]>
    </summary>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[543 Kth Largest in N Arrays]]></title>
    <link href="http://yoursite.com/2016/07/08/543-Kth-Largest-in-N-Arrays/"/>
    <id>http://yoursite.com/2016/07/08/543-Kth-Largest-in-N-Arrays/</id>
    <published>2016-07-08T22:22:06.000Z</published>
    <updated>2016-07-09T05:23:01.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在N个数组中找到第K大元素</p>
</blockquote>
<p><strong>样例</strong><br>n = 2 数组 [[9,3,2,4,7],[1,2,3,4,8]], 第三大元素是 7.<br>n = 2 数组 [[9,3,2,4,8],[1,2,3,4,2]], 最大数是 9, 次大数是 8, 第三大数是 7</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>维护一个大小为k的Min Heap，扫面N个数组的每一个数<ul>
<li>若小于等于堆顶，跳过</li>
<li>若大于堆顶，则剔除堆顶元素，加入该元素</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[][]&#125; arrays a list of array</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; k an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer, K-th largest element in N arrays</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">KthInArrays</span><span class="params">(self, arrays, k)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        minHeap = Queue.PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> arrays:</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> minHeap.qsize() &lt; k:</span><br><span class="line">                    minHeap.put(num)</span><br><span class="line">                <span class="keyword">elif</span> num &gt; minHeap.queue[<span class="number">0</span>]:</span><br><span class="line">                    minHeap.get()</span><br><span class="line">                    minHeap.put(num)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minHeap.queue[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在N个数组中找到第K大元素</p>
</blockquote>
<p><strong>样例</strong><br>n = 2 数组 [[9,3,2,4,7],[1,2,3,4,8]], 第三大元素是 7.<b]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="MinHeap" scheme="http://yoursite.com/tags/MinHeap/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[242 Valid Anagram]]></title>
    <link href="http://yoursite.com/2016/07/07/242-Valid-Anagram/"/>
    <id>http://yoursite.com/2016/07/07/242-Valid-Anagram/</id>
    <published>2016-07-08T02:27:30.000Z</published>
    <updated>2016-07-08T09:28:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>写出一个函数 anagram(s, t)<br> 判断两个字符串是否可以通过改变字母的顺序变成一样的字符串。</p>
</blockquote>
<p><strong>样例</strong><br>给出 s = “abcd”，t=”dcab”，返回 true.<br>给出 s = “ab”, t = “ab”, 返回 true.<br>给出 s = “ab”, t = “ac”, 返回 false.</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>扫描s，通过哈希表存贮s中每个字母出现的次数</li>
<li>扫描t，每次在哈希表中寻找相应的key，对于次数-1，如果最后哈希表中所有的value都变成0，则表明s和t是anagram</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type t: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) != len(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        map = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">256</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            map[ord(s[i])] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(t)):</span><br><span class="line">            map[ord(t[i])] -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> flag <span class="keyword">in</span> map:</span><br><span class="line">            <span class="keyword">if</span> flag != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>写出一个函数 anagram(s, t)<br> 判断两个字符串是否可以通过改变字母的顺序变成一样的字符串。</p>
</blockquote>
<p><strong>样例</strong><br>给出 s =]]>
    </summary>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[131 Palindrome Partitioning]]></title>
    <link href="http://yoursite.com/2016/07/06/131-Palindrome-Partitioning/"/>
    <id>http://yoursite.com/2016/07/06/131-Palindrome-Partitioning/</id>
    <published>2016-07-07T01:35:57.000Z</published>
    <updated>2016-07-07T08:36:54.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个字符串s，将s分割成一些子串，使每个子串都是回文串。<br>返回s所有可能的回文串分割方案。</p>
</blockquote>
<p><strong>样例</strong><br>给出 s = “aab”，返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;  [&#34;aa&#34;, &#34;b&#34;],&#10;  [&#34;a&#34;, &#34;a&#34;, &#34;b&#34;]&#10;]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>求所有答案，首先排除动态规划，应该是DFS (Palindrome Partitioning II 求个数才是动归）</li>
<li>遇到要求所有组合、可能、排列等解集的题目，一般都是DFS + backtracking</li>
<li>首先传入s=”aab” path=[] res = [], 首先切割出”a”（然后是”aa” “aab” …），然后判读它是不是回文串：<ul>
<li>如果不是，直接跳过</li>
<li>如果是，则此时剩余的 s=”ab”， path += [“a”]</li>
<li>写入res的判断是，当s=””时，记录结果</li>
</ul>
</li>
<li>优化：可以通过用DP来计算任意s[i:j]是否是回文，并保存结果，再执行DFS，如果发现某条string不是回文，就可以直接退出，从而减少计算量</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> [[]]</span><br><span class="line">        path = []</span><br><span class="line">        result = []</span><br><span class="line">        self.helper(s, path, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, str, path, result)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> str:</span><br><span class="line">            result.append(path)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(str) + <span class="number">1</span>):</span><br><span class="line">            prefix = str[:i]</span><br><span class="line">            <span class="keyword">if</span> self.isPalindrome(prefix):</span><br><span class="line">                self.helper(str[i:], path + [prefix], result)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str)):</span><br><span class="line">            <span class="keyword">if</span> str[i] != str[len(str) - i - <span class="number">1</span>]: <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个字符串s，将s分割成一些子串，使每个子串都是回文串。<br>返回s所有可能的回文串分割方案。</p>
</blockquote>
<p><strong>样例</strong><br>给出 s = “aa]]>
    </summary>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Palindrome" scheme="http://yoursite.com/tags/Palindrome/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[229 Stack Sorting]]></title>
    <link href="http://yoursite.com/2016/07/06/229-Stack-Sorting/"/>
    <id>http://yoursite.com/2016/07/06/229-Stack-Sorting/</id>
    <published>2016-07-07T00:50:00.000Z</published>
    <updated>2016-07-07T07:50:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>请设计一种方法将一个栈进行升序排列 （最大的数在最上面）。</p>
</blockquote>
<p>你可以使用另外一个栈来辅助操作，但不可将这些数复制到另外一个数据结构中 （如，数组）。</p>
<p><strong>样例</strong><br>给一个栈：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| |&#10;|3|&#10;|1|&#10;|2|&#10;|4|&#10; -</span><br></pre></td></tr></table></figure></p>
<p>排序之后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| |&#10;|4|&#10;|3|&#10;|2|&#10;|1|&#10; -</span><br></pre></td></tr></table></figure></p>
<p>栈会被序列化为[4,2,1,3]，也就是说最右边是栈顶。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>首先，把所有元素从原stack倒进临时stack，然后每次从临时stack拿出一个元素放入current中：<ul>
<li>若该current大于原stack中最上面的元素，则直接加入原stack</li>
<li>若该current小于原stack中的元素，就把原stack中的元素放回临时stack，直到原stack顶上的元素小于current或者原stack为空，则将current放入原stack</li>
</ul>
</li>
<li>从而，保证了原stack中的元素从底到上是按有小到大排序的</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Your can use Stack class in your solution.</span></span><br><span class="line"><span class="comment">#class Stack:</span></span><br><span class="line"><span class="comment">#  def __init__(self, stk=[])</span></span><br><span class="line"><span class="comment">#    # use stk to initialize the stack</span></span><br><span class="line"><span class="comment">#  def isEmpty(self)</span></span><br><span class="line"><span class="comment">#    # return true is stack is empty or false/</span></span><br><span class="line"><span class="comment">#  def push(self, item)</span></span><br><span class="line"><span class="comment">#    # push a element into stack and return nothing</span></span><br><span class="line"><span class="comment">#  def pop(self)</span></span><br><span class="line"><span class="comment">#    # pop a element from stack</span></span><br><span class="line"><span class="comment">#  def peek(self):</span></span><br><span class="line"><span class="comment">#    # return the top element if stack is not empty or nothing</span></span><br><span class="line"><span class="comment">#  def size(self):</span></span><br><span class="line"><span class="comment">#    # return the size of stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;Stack&#125; stk an integer Stack</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; void</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stackSorting</span><span class="params">(self, stk)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        tempStk = Stack()</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> stk.isEmpty():</span><br><span class="line">            tempStk.push(stk.pop())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> tempStk.isEmpty():</span><br><span class="line">            current = tempStk.pop()</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> stk.isEmpty() <span class="keyword">and</span> stk.peek() &gt; current:</span><br><span class="line">                tempStk.push(stk.peek())</span><br><span class="line">                stk.pop()</span><br><span class="line">            stk.push(current)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>请设计一种方法将一个栈进行升序排列 （最大的数在最上面）。</p>
</blockquote>
<p>你可以使用另外一个栈来辅助操作，但不可将这些数复制到另外一个数据结构中 （如，数组）。</p>
<p><st]]>
    </summary>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[531 Six Degrees]]></title>
    <link href="http://yoursite.com/2016/07/06/531-Six-Degrees/"/>
    <id>http://yoursite.com/2016/07/06/531-Six-Degrees/</id>
    <published>2016-07-06T22:11:28.000Z</published>
    <updated>2016-07-09T23:04:54.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>六度分离是一个哲学问题，说的是每个人每个东西可以通过六步或者更少的步数建立联系。<br>现在给你一个友谊关系，查询两个人可以通过几步相连，如果不相连返回 -1</p>
</blockquote>
<p><strong>样例</strong><br>给出图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>------<span class="number">2</span>-----<span class="number">4</span></span><br><span class="line"> \          /</span><br><span class="line">  \        /</span><br><span class="line">   \--<span class="number">3</span>--/</span><br></pre></td></tr></table></figure></p>
<p>{1,2,3#2,1,4#3,1,4#4,2,3} s = 1, t = 4 返回 2</p>
<p>给出图二<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>      <span class="number">2</span>-----<span class="number">4</span></span><br><span class="line">             /</span><br><span class="line">           /</span><br><span class="line">          <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>{1#2,4#3,4#4,2,3} s = 1, t = 4 返回 -1</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>本题相当于求图中两点的最短路径，BFS -&gt; 用Queue来实现</li>
<li>加入hash map去重，并且巧妙的将step当作值存入每一个节点为key的hash map中，这样通过节点A找到的相邻节点的步数即map[A] + 1</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for Undirected graph node</span></span><br><span class="line"><span class="comment"># class UndirectedGraphNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.neighbors = []</span></span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">'''</span><br><span class="line">    @param &#123;UndirectedGraphNode[]&#125; graph a list of Undirected graph node</span><br><span class="line">    @param &#123;UndirectedGraphNode&#125; s, t two Undirected graph nodes</span><br><span class="line">    @return &#123;int&#125; an integer</span><br><span class="line">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sixDegrees</span><span class="params">(self, graph, s, t)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        members = &#123;&#125;</span><br><span class="line">        q = Queue.Queue(maxsize = len(graph))</span><br><span class="line"></span><br><span class="line">        q.put(s)</span><br><span class="line">        members[s] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            x = q.get()</span><br><span class="line">            <span class="keyword">if</span> x == t:</span><br><span class="line">                <span class="keyword">return</span> members[x]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> x.neighbors:</span><br><span class="line">                <span class="keyword">if</span> y <span class="keyword">not</span> <span class="keyword">in</span> members:</span><br><span class="line">                    members[y] = members[x] + <span class="number">1</span></span><br><span class="line">                    q.put(y)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>六度分离是一个哲学问题，说的是每个人每个东西可以通过六步或者更少的步数建立联系。<br>现在给你一个友谊关系，查询两个人可以通过几步相连，如果不相连返回 -1</p>
</blockquote>
<p><str]]>
    </summary>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[347 Top K Frequent Elements]]></title>
    <link href="http://yoursite.com/2016/07/03/347-Top-K-Frequent-Elements/"/>
    <id>http://yoursite.com/2016/07/03/347-Top-K-Frequent-Elements/</id>
    <published>2016-07-03T19:31:15.000Z</published>
    <updated>2016-07-04T02:32:18.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个数组，返回其出现次数最多的k个元素，时间复杂度优于O(nlogn)</p>
</blockquote>
<p><strong>样例</strong><br>给出[1,1,1,2,2,3] 和 k = 2, 返回 [1,2]</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>首先使用hash table统计元素的频率</li>
<li>建立一个长度为k的最小堆，因为堆顶最小，每次和堆顶元素作比较，大于堆顶就踢出堆顶元素并把当前元素加入堆中</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: List[int]</span><br><span class="line">        """</span></span><br><span class="line">        map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> map:</span><br><span class="line">                map[num] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                map[num] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        minHeap = Queue.PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> key, count <span class="keyword">in</span> map.items():</span><br><span class="line">            <span class="keyword">if</span> minHeap.qsize() &lt; k:</span><br><span class="line">                minHeap.put((count, key))</span><br><span class="line">            <span class="keyword">elif</span> minHeap.queue[<span class="number">0</span>] &lt; (count, key):</span><br><span class="line">                minHeap.get()</span><br><span class="line">                minHeap.put((count, key))</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> [x[<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> minHeap.queue]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个数组，返回其出现次数最多的k个元素，时间复杂度优于O(nlogn)</p>
</blockquote>
<p><strong>样例</strong><br>给出[1,1,1,2,2,3] 和 k = 2]]>
    </summary>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Priority Queue" scheme="http://yoursite.com/tags/Priority-Queue/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[493 [Implement Queue by Linked List II]]></title>
    <link href="http://yoursite.com/2016/06/28/493-Implement-Queue-by-Linked-List-II/"/>
    <id>http://yoursite.com/2016/06/28/493-Implement-Queue-by-Linked-List-II/</id>
    <published>2016-06-28T23:16:43.000Z</published>
    <updated>2016-06-29T06:17:23.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个双端队列</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push_front(1)&#10;push_back(2)&#10;pop_back() // return 2&#10;pop_back() // return 1&#10;push_back(3)&#10;push_back(4)&#10;pop_front() // return 3&#10;pop_front() // return 4</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>自己构建一个双向链表</li>
<li>需要注意从前面pop出最后一个元素和从后面pop出最后一个元素的情况</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _val)</span>:</span></span><br><span class="line">        self.next = self.prev = <span class="keyword">None</span></span><br><span class="line">        self.val = _val</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dequeue</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># do some intialize if necessary</span></span><br><span class="line">        self.first, self.last = <span class="keyword">None</span>, <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; item an integer</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_front</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># Write yout code here</span></span><br><span class="line">        <span class="keyword">if</span> self.first <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.first = Node(item)</span><br><span class="line">            self.last = self.first</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = Node(item)</span><br><span class="line">            self.first.prev = tmp</span><br><span class="line">            tmp.next = self.first</span><br><span class="line">            self.first = tmp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; item an integer</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push_back</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># Write yout code here</span></span><br><span class="line">        <span class="keyword">if</span> self.last <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.first = Node(item)</span><br><span class="line">            self.last = self.first</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp = Node(item)</span><br><span class="line">            self.last.next = tmp</span><br><span class="line">            tmp.prev = self.last</span><br><span class="line">            self.last = tmp</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> self.first <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            item = self.first.val</span><br><span class="line">            self.first = self.first.next</span><br><span class="line">            <span class="keyword">if</span> self.first <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                self.first.prev = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.last = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_back</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> self.last <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            item = self.last.val</span><br><span class="line">            self.last = self.last.prev</span><br><span class="line">            <span class="keyword">if</span> self.last <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                self.last.next = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.first = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">12</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个双端队列</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><tr><td class]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[492 Implement Queue by Linked List]]></title>
    <link href="http://yoursite.com/2016/06/28/492-Implement-Queue-by-Linked-List/"/>
    <id>http://yoursite.com/2016/06/28/492-Implement-Queue-by-Linked-List/</id>
    <published>2016-06-28T22:52:11.000Z</published>
    <updated>2016-06-29T05:52:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个队列的操作</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enqueue(<span class="number">1</span>)</span><br><span class="line">enqueue(<span class="number">2</span>)</span><br><span class="line">enqueue(<span class="number">3</span>)</span><br><span class="line">dequeue() <span class="comment"># return 1</span></span><br><span class="line">enqueue(<span class="number">4</span>)</span><br><span class="line">dequeue() <span class="comment"># return 2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>简单基础的一道题，用链表实现列队</li>
<li>注意，dequeue的时候如果是下面这种情况，head指向dummyNode，tail指向5。把5删除之后要记得将tail重新指向head所指向的node<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DummyNode -&gt; 5 -&gt; Null</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, _val)</span>:</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line">        self.val = _val</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># do some intialize if necessary</span></span><br><span class="line">        self.head = Node(<span class="number">0</span>)</span><br><span class="line">        self.tail = self.head</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; item an integer</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># Write yout code here</span></span><br><span class="line">        self.tail.next = Node(item)</span><br><span class="line">        self.tail = self.tail.next</span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        res = self.head.next.val</span><br><span class="line">        self.head.next = self.head.next.next</span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.size == <span class="number">0</span>:</span><br><span class="line">            self.tail = self.head</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个队列的操作</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight python"><table><tr><td cla]]>
    </summary>
    
      <category term="Linked List" scheme="http://yoursite.com/tags/Linked-List/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[225 Implement Stack by Two Queues]]></title>
    <link href="http://yoursite.com/2016/06/27/225-Implement-Stack-by-Two-Queues/"/>
    <id>http://yoursite.com/2016/06/27/225-Implement-Stack-by-Two-Queues/</id>
    <published>2016-06-28T01:06:49.000Z</published>
    <updated>2016-06-28T08:07:35.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>利用两个队列来实现一个栈的功能</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push(1)&#10;pop()&#10;push(2)&#10;isEmpty() // return false&#10;top() // return 2&#10;pop()&#10;isEmpty() // return true</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>使用两个queue<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q1 = []       q2 = []&#10;push 1&#10;q1 = [1]      q2 = []&#10;q1 = []       q2 = [1] &#10;push 2&#10;q1 = [2]      q2 = [1]&#10;q1 = [2, 1]   q2 = []&#10;q1 = []       q2 = [2, 1]&#10;push 3&#10;q1 = [3]       q2 = [2, 1]&#10;q1 = [3, 2, 1] q2 = []&#10;q1 = []        q2 = [3, 2, 1]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        initialize your data structure here.</span><br><span class="line">        """</span></span><br><span class="line">        self.q1 = Queue.Queue()</span><br><span class="line">        self.q2 = Queue.Queue()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        self.q1.put(x)</span><br><span class="line">        <span class="keyword">while</span> self.q2.qsize() != <span class="number">0</span>:</span><br><span class="line">            self.q1.put(self.q2.get())</span><br><span class="line">        <span class="keyword">while</span> self.q1.qsize() != <span class="number">0</span>:</span><br><span class="line">            self.q2.put(self.q1.get())</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        self.q2.get()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.q2.queue[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.q2.qsize() == <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>利用两个队列来实现一个栈的功能</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><tr><t]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[495 Implement Stack]]></title>
    <link href="http://yoursite.com/2016/06/27/495-Implement-Stack/"/>
    <id>http://yoursite.com/2016/06/27/495-Implement-Stack/</id>
    <published>2016-06-28T00:41:06.000Z</published>
    <updated>2016-06-28T07:41:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个栈，可以使用除了栈之外的数据结构</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">push(1)&#10;pop()&#10;push(2)&#10;top()  // return 2&#10;pop()&#10;isEmpty() // return true&#10;push(3)&#10;isEmpty() // return false</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>使用python list实现stack数据结构</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>:</span></span><br><span class="line">    <span class="comment"># initialize your data structure here.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.items = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param x, an integer, push a new item into the stack</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        self.items.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return nothing, pop the top of the stack</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        self.items.pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return an integer, return the top of the stack</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">return</span> self.items[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return a boolean, check the stack is empty or not.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">return</span> len(self.items) == <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个栈，可以使用除了栈之外的数据结构</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><]]>
    </summary>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[263 Ugly Number]]></title>
    <link href="http://yoursite.com/2016/06/26/263-Ugly-Number/"/>
    <id>http://yoursite.com/2016/06/26/263-Ugly-Number/</id>
    <published>2016-06-26T23:09:58.000Z</published>
    <updated>2016-06-27T06:10:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>写一个程序来检测一个整数是不是丑数。<br>丑数的定义是，只包含质因子 2, 3, 5的正整数。比如 6, 8 就是丑数，但是 14 不是丑数以为他包含了质因子 7。<br><strong>注意事项</strong><br>可以认为 1 是一个特殊的丑数。</p>
</blockquote>
<p><strong>样例</strong><br>给出 num = 8，返回 true。<br>给出 num = 14，返回 false。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>由于本题只需要判断num是不是丑数，根据丑数的定义：<ul>
<li>如果num对2取模等于0，则num除以2</li>
<li>如果num对3取模等于0，则num除以3</li>
<li>如果num对5取模等于0，则num除以5</li>
</ul>
</li>
<li>如果最后num等于1则是丑数，否则不是</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isUgly</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type num: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                num /= <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">                num /= <span class="number">3</span></span><br><span class="line">            <span class="keyword">while</span> num % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                num /= <span class="number">5</span></span><br><span class="line">            <span class="keyword">return</span> num == <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>写一个程序来检测一个整数是不是丑数。<br>丑数的定义是，只包含质因子 2, 3, 5的正整数。比如 6, 8 就是丑数，但是 14 不是丑数以为他包含了质因子 7。<br><strong>注意事项</stro]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Math" scheme="http://yoursite.com/tags/Math/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[232 Implement Queue using Stacks]]></title>
    <link href="http://yoursite.com/2016/06/26/232-Implement-Queue-using-Stacks/"/>
    <id>http://yoursite.com/2016/06/26/232-Implement-Queue-using-Stacks/</id>
    <published>2016-06-26T17:12:41.000Z</published>
    <updated>2016-06-27T00:13:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>正如标题所述，你需要使用两个栈来实现队列的一些操作。<br>队列应支持push(element)，pop() 和 top()，其中pop是弹出队列中的第一个(最前面的)元素。<br>pop和top方法都应该返回第一个元素的值。</p>
</blockquote>
<p><strong>样例</strong><br>比如push(1), pop(), push(2), push(3), top(), pop()，<br>你应该返回1，2和2</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>使用两个stack就可以实现queue的API</li>
<li>每次push就push到stack1</li>
<li>每次pop或者top，则看stack2是否为空，若为空，则将stack1中的元素pop出来并push到stack2<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">pop <span class="number">3</span></span><br><span class="line">stack2 = [<span class="number">3</span>]</span><br><span class="line">pop <span class="number">2</span></span><br><span class="line">stack2 = [<span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">pop <span class="number">1</span></span><br><span class="line">stack2 = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>] <span class="comment">#真正的pop/top操作在stack2上执行</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        initialize your data structure here.</span><br><span class="line">        """</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type x: int</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        self.stack1.append(x)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: nothing</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2[-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.stack1) == <span class="number">0</span> <span class="keyword">and</span> len(self.stack2) == <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>正如标题所述，你需要使用两个栈来实现队列的一些操作。<br>队列应支持push(element)，pop() 和 top()，其中pop是弹出队列中的第一个(最前面的)元素。<br>pop和top方法都应该返回]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[486 Merge k Sorted Arrays]]></title>
    <link href="http://yoursite.com/2016/06/26/486-Merge-k-Sorted-Arrays/"/>
    <id>http://yoursite.com/2016/06/26/486-Merge-k-Sorted-Arrays/</id>
    <published>2016-06-26T16:58:02.000Z</published>
    <updated>2016-06-26T23:58:46.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>将 k 个排序数组合并为一个大的排序数组。</p>
</blockquote>
<p><strong>样例</strong><br>给出下面的 3 个排序数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &#10; [1, 3, 5, 7], &#10; [2, 4, 6], &#10; [0, 8, 9, 10, 11]&#10;]</span><br></pre></td></tr></table></figure></p>
<p>合并后的大数组应为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>本题类似于Merge k Sorted Lists。与之不同的是，arrays不能直接通过一个值找到相邻的下一个值，所以需要建立一个set(数值，数组编号，index)</li>
<li>这样，我们就拥有了当前数组是Arrays中的哪一个数组，并且知道了是这个数组的第几个数字</li>
<li>首先创建一个最小堆，把每一个array的第一个数字放入堆中，然后取最小，把最小值放入res中，并把最小值所在数组中的相邻的数放入堆中</li>
</ul>
<p><strong>注意</strong><br>使用heapq性能优于封装的Queue.PriorityQueue，本题使用Queue.PriorityQueue会TLE</p>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[][]&#125; arrays k sorted integer arrays</span></span><br><span class="line">    <span class="comment"># @return &#123;int[]&#125; a sorted array</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergekSortedArrays</span><span class="params">(self, arrays)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        result = []</span><br><span class="line">        heap = []</span><br><span class="line">        <span class="keyword">for</span> index, array <span class="keyword">in</span> enumerate(arrays):</span><br><span class="line">            <span class="keyword">if</span> len(array) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            heapq.heappush(heap, (array[<span class="number">0</span>], index, <span class="number">0</span>))</span><br><span class="line">             </span><br><span class="line">        <span class="keyword">while</span> len(heap):</span><br><span class="line">            val, arrayNum, index = heapq.heappop(heap)</span><br><span class="line">            result.append(val)</span><br><span class="line">            <span class="keyword">if</span> index + <span class="number">1</span> &lt; len(arrays[arrayNum]):</span><br><span class="line">                heapq.heappush(heap, (arrays[arrayNum][index + <span class="number">1</span>], arrayNum, index + <span class="number">1</span>))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>将 k 个排序数组合并为一个大的排序数组。</p>
</blockquote>
<p><strong>样例</strong><br>给出下面的 3 个排序数组：<br><figure class="highli]]>
    </summary>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Priority Queue" scheme="http://yoursite.com/tags/Priority-Queue/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[545 Top k Largest Number II]]></title>
    <link href="http://yoursite.com/2016/06/26/545-Top-k-Largest-Number-II/"/>
    <id>http://yoursite.com/2016/06/26/545-Top-k-Largest-Number-II/</id>
    <published>2016-06-26T16:22:37.000Z</published>
    <updated>2016-06-26T23:23:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个数据结构，提供下面两个接口<br>1.add(number) 添加一个元素<br>2.topk() 返回前K大的数</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = new Solution(3);&#10;&#62;&#62; create a new data structure.&#10;s.add(3)&#10;s.add(10)&#10;s.topk()&#10;&#62;&#62; return [10, 3]&#10;s.add(1000)&#10;s.add(-99)&#10;s.topk()&#10;&#62;&#62; return [1000, 10, 3]&#10;s.add(4)&#10;s.topk()&#10;&#62;&#62; return [1000, 10, 4]&#10;s.add(100)&#10;s.topk()&#10;&#62;&#62; return [1000, 100, 10]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>内部维护一个大小为k的最小堆</li>
<li>如果size &lt; k则直接将num加入到minHeap</li>
<li>如果size &gt;= k, 则比较num与minHeap中的最小值，若小于最小值则忽略，大于最小值则删除最小值，并把num加入到minHeap</li>
<li>每次返回minHeap数组，返回时先反向排序<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sorted(nums, reverse=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; k an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="comment"># initialize your data structure here.</span></span><br><span class="line">        self.size = k</span><br><span class="line">        self.minHeap = Queue.PriorityQueue()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># @param &#123;int&#125; num an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> self.minHeap.qsize() &lt; self.size:</span><br><span class="line">            self.minHeap.put(num)</span><br><span class="line">        <span class="keyword">elif</span> num &gt; self.minHeap.queue[<span class="number">0</span>]:</span><br><span class="line">            self.minHeap.get()</span><br><span class="line">            self.minHeap.put(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @return &#123;int[]&#125; the top k largest numbers</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">return</span> sorted(self.minHeap.queue, reverse=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>实现一个数据结构，提供下面两个接口<br>1.add(number) 添加一个元素<br>2.topk() 返回前K大的数</p>
</blockquote>
<p><strong>样例</strong><br]]>
    </summary>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Priority Queue" scheme="http://yoursite.com/tags/Priority-Queue/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[544 Top k Largest Numbers]]></title>
    <link href="http://yoursite.com/2016/06/26/544-Top-k-Largest-Numbers/"/>
    <id>http://yoursite.com/2016/06/26/544-Top-k-Largest-Numbers/</id>
    <published>2016-06-26T15:59:50.000Z</published>
    <updated>2016-06-26T23:00:29.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个数组中找到前K大的数</p>
</blockquote>
<p><strong>样例</strong><br>给出 [3,10,1000,-99,4,100], k = 3.<br>返回 [1000, 100, 10]</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>方法一：快速排序，然后取出前k大的数。时间复杂度O(n*logn + k)</li>
<li><p>方法二：维护一个大小为k的最大堆/最小堆，代码如下。时间复杂度为O(n * logk)</p>
</li>
<li><p>关于Heap</p>
<ul>
<li>在python中有两个接口：<strong>heapq</strong>和<strong>Queue.PriorityQueue</strong>。其中PriorityQueue module is using the <strong>heapq</strong> module which is slower because it adds locks, encapsulation, and a nice object oriented API.</li>
<li>heapq的使用：<ul>
<li>heapq.<strong>heappush</strong>: Push the value <em>item</em> onto the <em>heap</em>, maintaining the heap invariant.</li>
<li>heapq.<strong>heappop</strong>: Pop and return the smallest item from the <em>heap</em>, maintaining the heap invariant.</li>
<li>heapq.<strong>heapify</strong>: Transform list <em>x</em> into a heap, in-place, in linear time.</li>
</ul>
</li>
<li>Queue.PriorityQueue的使用 (myqueue = Queue.PriorityQueue)<ul>
<li>myqueue.put()</li>
<li>myqueue.get()</li>
<li>myqueue.qsize()</li>
<li>myqueue.empty()</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">'''</span><br><span class="line">    @param &#123;int[]&#125; nums an integer array</span><br><span class="line">    @param &#123;int&#125; k an integer</span><br><span class="line">    @return &#123;int[]&#125; the top k largest numbers in array</span><br><span class="line">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topk</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">            </span><br><span class="line">        MaxHeap = Queue.PriorityQueue()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            MaxHeap.put(-num)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            res.append(-MaxHeap.get())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个数组中找到前K大的数</p>
</blockquote>
<p><strong>样例</strong><br>给出 [3,10,1000,-99,4,100], k = 3.<br>返回 [1000, 1]]>
    </summary>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Priority Queue" scheme="http://yoursite.com/tags/Priority-Queue/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[128 Hash Function]]></title>
    <link href="http://yoursite.com/2016/06/25/128-Hash-Function/"/>
    <id>http://yoursite.com/2016/06/25/128-Hash-Function/</id>
    <published>2016-06-25T23:15:32.000Z</published>
    <updated>2016-06-26T06:16:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在数据结构中，哈希函数是用来将一个字符串（或任何其他类型）转化为小于哈希表大小且大于等于零的整数。一个好的哈希函数可以尽可能少地产生冲突。一种广泛使用的哈希函数算法是使用数值33，假设任何字符串都是基于33的一个大整数。给出一个字符串作为key和一个哈希表的大小，返回这个字符串的哈希值。</p>
</blockquote>
<p>对于key=”abcd” 并且 size=100， 返回 78</p>
<h3 id="解题思路：">解题思路：</h3><ul>
<li><p>关于哈希表：</p>
<ul>
<li>哈希表在内存中是一个事先开辟好的数组，通过hash function把一个key转化为某一个index，来实现O(1)的查找</li>
<li>理想状态下，每次算出的index都是唯一的，而实际上会有Collision</li>
<li>hash function设计标准是越乱越没有规则越好，以避免Collision，一般是通过某种方式将key转化为一个integer然后对hash table size取模</li>
<li>哈希表的size最好要是所要存的数字数量的10倍，当size不够时，需要rehashing。</li>
</ul>
</li>
<li><p>如何处理冲突 - Collision</p>
<ul>
<li>Open hashing - 冲突的话，index下面采用linked list</li>
<li>Closed hashing - 如果有冲突，则向前或者向后位移。致命缺点，不支持删除，所以几乎没人采用</li>
</ul>
</li>
<li><p>将key转化为整数的方式有：</p>
<ul>
<li>MD5, 但是耗费较大</li>
<li>APR hash function - magic number 33(只是经验值)</li>
</ul>
</li>
<li><p>Python中char和integer之间的转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#62;&#62;&#62;ord(&#34;a&#34;)&#10;97&#10;&#62;&#62;&#62;chr(97)&#10;&#39;a&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>小技巧，如何计算a * 33^3 + b * 33^2 + c * 33 + d</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = a * 33&#10;sum = (a * 33 + b) * 33&#10;sum = (a * 33^2 + b * 33 + c) * 33&#10;sum = (a * 33^3 + b * 33^2 + c * 33 + d) * 33&#10;...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param key: A String you should hash</span><br><span class="line">    @param HASH_SIZE: An integer</span><br><span class="line">    @return an integer</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span><span class="params">(self, key, HASH_SIZE)</span>:</span></span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> key:</span><br><span class="line">            sum = sum * <span class="number">33</span> + ord(char)</span><br><span class="line">            sum = sum % HASH_SIZE</span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在数据结构中，哈希函数是用来将一个字符串（或任何其他类型）转化为小于哈希表大小且大于等于零的整数。一个好的哈希函数可以尽可能少地产生冲突。一种广泛使用的哈希函数算法是使用数值33，假设任何字符串都是基于33的一]]>
    </summary>
    
      <category term="Hash" scheme="http://yoursite.com/tags/Hash/"/>
    
      <category term="Hash Function" scheme="http://yoursite.com/tags/Hash-Function/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[49 Sort Letters by Case]]></title>
    <link href="http://yoursite.com/2016/06/19/49-Sort-Letters-by-Case/"/>
    <id>http://yoursite.com/2016/06/19/49-Sort-Letters-by-Case/</id>
    <published>2016-06-20T02:09:04.000Z</published>
    <updated>2016-06-20T09:09:56.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个只包含字母的字符串，按照先小写字母后大写字母的顺序进行排序。</p>
</blockquote>
<p>给出<strong>“abAcD”</strong>，一个可能的答案为<strong>“acbAD”</strong></p>
<p>小写字母或者大写字母他们之间不一定要保持在原始字符串中的相对位置。<br>在原地扫描一遍完成</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>Two Pointers  - 对撞型指针问题</li>
<li>做指针和右指针指向的字母，可能出现四种情况需要考虑：<ul>
<li>左：小写 | 右：小写 ====&gt; 左指针左移</li>
<li>左：大写 | 右：小写 ====&gt; 交换字母</li>
<li>左：大写 | 右：大写 ====&gt; 右指针右移</li>
<li>左：小写 | 右：小写 ====&gt; 左指针左移，右指针右移</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param chars: The letters array you should sort.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortLetters</span><span class="params">(self, chars)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> chars <span class="keyword">or</span> len(chars) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> chars</span><br><span class="line">            </span><br><span class="line">        left, right = <span class="number">0</span>, len(chars) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> ord(chars[left]) &lt; <span class="number">96</span> <span class="keyword">and</span> ord(chars[right]) &gt; <span class="number">96</span>:</span><br><span class="line">                chars[left], chars[right] = chars[right], chars[left]</span><br><span class="line">            <span class="keyword">elif</span> ord(chars[left]) &lt; <span class="number">96</span> <span class="keyword">and</span> ord(chars[right]) &lt; <span class="number">96</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> ord(chars[left]) &gt; <span class="number">96</span> <span class="keyword">and</span> ord(chars[right]) &gt; <span class="number">96</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span> </span><br><span class="line">                right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个只包含字母的字符串，按照先小写字母后大写字母的顺序进行排序。</p>
</blockquote>
<p>给出<strong>“abAcD”</strong>，一个可能的答案为<strong>“acbAD]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[4 Median of two Sorted Arrays]]></title>
    <link href="http://yoursite.com/2016/06/19/4-Median-of-two-Sorted-Arrays/"/>
    <id>http://yoursite.com/2016/06/19/4-Median-of-two-Sorted-Arrays/</id>
    <published>2016-06-20T01:27:04.000Z</published>
    <updated>2016-06-20T08:27:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>两个排序的数组A和B分别含有m和n个数，找到两个排序数组的中位数，要求时间复杂度应为O(log (m+n))。</p>
</blockquote>
<p><strong>样例</strong><br>给出数组A =<strong> [1,2,3,4,5,6]</strong> B = <strong>[2,3,4,5]</strong>，中位数3.5<br>给出数组A = <strong>[1,2,3]</strong> B = <strong>[4,5]</strong>，中位数 3</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>根据题目要求的时间复杂度是O(log(m+n))可知，必须要有个类似于binary search一样，每次操作可以扔一半。</li>
<li>如果数组A和B一个含有n个元素，那么,<ul>
<li>如果n是奇数，则中位数是合并数组的第n/2+1个数</li>
<li>如果n是偶数，则中位数是合并数组的第n/2个数和n/2+1个数的平均数</li>
</ul>
</li>
<li>最后为题转化为如何求两个排序数组的第k大的数，时间复杂度为O(log(m+n))</li>
<li>思路：每次找A的k/2的位置和B的k/2的位置的数与相比较<ul>
<li>如果A[k/2] &lt; B[k/2]，则扔掉A的前k/2个数，因为第k大的数一定不在其中。找第k大的数转化为，在剩下的A数组和B数组中找第k/2大的数</li>
<li>如果A[k/2] &gt;= B[k/2]，则扔掉B的前k/2个数，因为第k大的数一定不在其中。找第k大的数转化为，在剩下的B数组和A数组中找第k/2大的数</li>
</ul>
</li>
<li><strong>注意</strong>：如果要求返回float类型，要<code>/ 2.0</code>而不是<code>/ 2</code></li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums1: List[int]</span><br><span class="line">        :type nums2: List[int]</span><br><span class="line">        :rtype: float</span><br><span class="line">        """</span></span><br><span class="line">        n = len(nums1) + len(nums2)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findKthNum(nums1, nums2, n / <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (self.findKthNum(nums1, nums2, n / <span class="number">2</span>) + self.findKthNum(nums1, nums2, n / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthNum</span><span class="params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums1) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums2[k - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> len(nums2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums1[k -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min(nums1[<span class="number">0</span>], nums2[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        a = nums1[k / <span class="number">2</span> - <span class="number">1</span>] <span class="keyword">if</span> k / <span class="number">2</span> &lt;= len(nums1) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">        b = nums2[k / <span class="number">2</span> - <span class="number">1</span>] <span class="keyword">if</span> k / <span class="number">2</span> &lt;= len(nums2) <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> b <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> (a <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> a &lt; b):</span><br><span class="line">            <span class="keyword">return</span> self.findKthNum(nums1[k / <span class="number">2</span>:], nums2, k - k / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findKthNum(nums1, nums2[k / <span class="number">2</span>:], k - k / <span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>两个排序的数组A和B分别含有m和n个数，找到两个排序数组的中位数，要求时间复杂度应为O(log (m+n))。</p>
</blockquote>
<p><strong>样例</strong><br>给出数组A]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
</feed>
