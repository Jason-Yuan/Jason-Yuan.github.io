<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Chemistry]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2015-11-20T07:23:33.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Jason Yuan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[475 Binary Tree Maximum Path Sum II]]></title>
    <link href="http://yoursite.com/2015/11/19/475-Binary-Tree-Maximum-Path-Sum-II/"/>
    <id>http://yoursite.com/2015/11/19/475-Binary-Tree-Maximum-Path-Sum-II/</id>
    <published>2015-11-19T23:22:19.000Z</published>
    <updated>2015-11-20T07:23:33.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>已知一颗二叉树，找到从根节点到任意节点的最大路径和</p>
</blockquote>
<p>已知下面一颗二叉树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; 1&#10;&#160;/ \&#10;2 &#160; 3</span><br></pre></td></tr></table></figure></p>
<p>返回4. (1-&gt;3)</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>Divide and Conquer</li>
<li>借助一个helper函数，从根节点向下分裂，每一层返回左右儿子中的最大值与当前节点的值，层层递归</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        this.val = val</span><br><span class="line">        this.left, this.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root the root of binary tree.</span><br><span class="line">    @return an integer</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum2</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(left, right) + root.val</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>已知一颗二叉树，找到从根节点到任意节点的最大路径和</p>
</blockquote>
<p>已知下面一颗二叉树<br><figure class="highlight plain"><table><tr><t]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[471 Top K Frequent Words]]></title>
    <link href="http://yoursite.com/2015/11/12/471-Top-K-Frequent-Words/"/>
    <id>http://yoursite.com/2015/11/12/471-Top-K-Frequent-Words/</id>
    <published>2015-11-13T00:08:22.000Z</published>
    <updated>2016-04-10T00:29:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>Given a list of words and an integer k, return the top k frequent words in the list.</p>
</blockquote>
<p>给出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ </span><br><span class="line"><span class="string">"yes"</span>, <span class="string">"lint"</span>, <span class="string">"code"</span>, </span><br><span class="line"><span class="string">"yes"</span>, <span class="string">"code"</span>, <span class="string">"baby"</span>, </span><br><span class="line"><span class="string">"you"</span>, <span class="string">"baby"</span>, <span class="string">"chrome"</span>, </span><br><span class="line"><span class="string">"safari"</span>, <span class="string">"lint"</span>, <span class="string">"code"</span>, </span><br><span class="line"><span class="string">"body"</span>, <span class="string">"lint"</span>, <span class="string">"code"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>当k=3时，返回[“code”, “lint”, “baby”]<br>当k=4时，返回[“code”, “lint”, “baby”, “yes”]</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>首先使用hash table统计词频，建立一个存有<strong>（单词，词频）结构</strong>的数组</li>
<li>自定义<strong>（单词，词频）结构</strong>的比较方式</li>
<li>快速排序，然后取出前K个，得到结果</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;string[]&#125; words a list of string</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; k an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;string[]&#125; a list of string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequentWords</span><span class="params">(self, words, k)</span>:</span></span><br><span class="line">        map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> map:</span><br><span class="line">                map[word] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                map[word] += <span class="number">1</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> map.items():</span><br><span class="line">            temp.append((value, key))</span><br><span class="line">        temp.sort(cmp=self.cmp)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            result.append(temp[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmp</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] <span class="keyword">or</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] <span class="keyword">and</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] <span class="keyword">and</span> a[<span class="number">1</span>] == b[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>Given a list of words and an integer k, return the top k frequent words in the list.</p>
</blockquote>
<p]]>
    </summary>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Quick Sort" scheme="http://yoursite.com/tags/Quick-Sort/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[264 Ugly Number II]]></title>
    <link href="http://yoursite.com/2015/11/12/264-Ugly-Number-II/"/>
    <id>http://yoursite.com/2015/11/12/264-Ugly-Number-II/</id>
    <published>2015-11-13T00:03:37.000Z</published>
    <updated>2015-11-13T08:04:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>设计一个算法，找出只含素因子2，3，5 的第 k 大的数。<br>符合条件的数如：1, 2, 3, 4, 5, 6, 8, 9, 10, 12……</p>
</blockquote>
<p>如果k=4， 返回 4<br>挑战<br>要求时间复杂度为O(nlogn)或者O(n)</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>动态规划</li>
<li>每一个丑数都是由某一个比它小得丑数乘以2，3或者5得到的</li>
<li>res数组记录前k个丑数</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        i2 = i3 = i5 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            nextUglyNumber = min(min(res[i2] * <span class="number">2</span>, res[i3] * <span class="number">3</span>), res[i5] * <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> nextUglyNumber == res[i2] * <span class="number">2</span>:</span><br><span class="line">                i2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nextUglyNumber == res[i3] * <span class="number">3</span>:</span><br><span class="line">                i3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nextUglyNumber == res[i5] * <span class="number">5</span>:</span><br><span class="line">                i5 += <span class="number">1</span></span><br><span class="line">            res[i] = nextUglyNumber</span><br><span class="line">        <span class="keyword">return</span> res[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>设计一个算法，找出只含素因子2，3，5 的第 k 大的数。<br>符合条件的数如：1, 2, 3, 4, 5, 6, 8, 9, 10, 12……</p>
</blockquote>
<p>如果k=4， 返回 ]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[215 Kth Largest Element in an Array]]></title>
    <link href="http://yoursite.com/2015/11/12/215-Kth-Largest-Element-in-an-Array/"/>
    <id>http://yoursite.com/2015/11/12/215-Kth-Largest-Element-in-an-Array/</id>
    <published>2015-11-12T23:59:40.000Z</published>
    <updated>2015-11-13T08:00:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>在数组中找到第k大的元素</p>
</blockquote>
<p>给出数组<strong>[9,3,2,4,8]</strong>，第三大的元素是4<br>给出数组<strong>[1,2,3,4,5]</strong>第一大的元素是5，第二大的元素是4，第三大的元素是3，以此类推</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>寻找第<code>k</code>大的数字可以转化为寻找第<code>n+1-k</code>小的数字，进而想到<strong>Quick Select</strong></li>
<li>Quick Select算法的基本思路与Quick Sort类似，重点是<strong>partition</strong></li>
<li>基本思想，随机选取一个pivot，小于的放左边，大于等于的放右边，返回pivot的位置<ul>
<li>如果<code>pivot == k</code>，则正好找到了第k小的元素</li>
<li>如果<code>pivot &gt; k</code>，则第k小的元素存在于pivot左边</li>
<li>如果<code>pivot &lt; k</code>，则第k小的元素存在于pivot右边</li>
</ul>
</li>
<li>时间复杂度：O(<em>n</em> logn) (in quicksort), O(n) (in quickselect)</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># convert the kth largest to smallest</span></span><br><span class="line">        <span class="keyword">return</span> self.findKthSmallest(nums, len(nums)+<span class="number">1</span>-k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthSmallest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> nums:</span><br><span class="line">            pos = self.partition(nums, <span class="number">0</span>, len(nums)-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> k &gt; pos+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> self.findKthSmallest(nums[pos+<span class="number">1</span>:], k-pos-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> k &lt; pos+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> self.findKthSmallest(nums[:pos], k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[pos]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># choose the right-most element as pivot   </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, nums, l, r)</span>:</span></span><br><span class="line">        low = l</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> nums[l] &lt; nums[r]:</span><br><span class="line">                nums[l], nums[low] = nums[low], nums[l]</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        nums[low], nums[r] = nums[r], nums[low]</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>在数组中找到第k大的元素</p>
</blockquote>
<p>给出数组<strong>[9,3,2,4,8]</strong>，第三大的元素是4<br>给出数组<strong>[1,2,3,4,5]</s]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Quick Sort" scheme="http://yoursite.com/tags/Quick-Sort/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[77 Longest Common Subsequence]]></title>
    <link href="http://yoursite.com/2015/11/02/77-Longest-Common-Subsequence/"/>
    <id>http://yoursite.com/2015/11/02/77-Longest-Common-Subsequence/</id>
    <published>2015-11-02T17:45:53.000Z</published>
    <updated>2015-11-03T01:47:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p>
</blockquote>
<p>给出<strong>“ABCD”</strong> 和 <strong>“EDCA”</strong>，这个LCS是 <strong>“A”</strong> (或 D或C)，返回1<br>给出<strong> “ABCD”</strong> 和 <strong>“EACB”</strong>，这个LCS是<strong>“AC”</strong>返回 2</p>
<h1 id="解题思路">解题思路</h1><ul>
<li><strong>双序列型动态规划</strong> - Two Sequence DP</li>
<li><code>cache[i][j]</code>表示第一个字符串的前i个字符和第二个字符串的前j个字符的最长公共子序列的长度</li>
<li>状态转移方程：<ul>
<li>如果<code>str1[i] != str2[j]</code><br>cache[i][j] = max(cache[i][j - 1], cache[i - 1][j])</li>
<li>如果<code>str1[i] != str2[j]</code><br>cache[i - 1][j - 1] + 1</li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param A, B: Two strings.</span><br><span class="line">    @return: The length of longest common subsequence of A and B.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A) + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(B) + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(B) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(A) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> A[j - <span class="number">1</span>] == B[i - <span class="number">1</span>]:</span><br><span class="line">                    cache[i][j] = cache[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cache[i][j] = max(cache[i][j - <span class="number">1</span>], cache[i - <span class="number">1</span>][j])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cache[len(B)][len(A)]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p>
</blockquote>
<p>给出<strong>“ABCD”</strong> 和 <strong>“EDCA”</strong>]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Two Sequence DP" scheme="http://yoursite.com/tags/Two-Sequence-DP/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[105 Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <link href="http://yoursite.com/2015/11/02/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
    <id>http://yoursite.com/2015/11/02/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</id>
    <published>2015-11-02T16:15:56.000Z</published>
    <updated>2015-11-03T00:17:13.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>根据前序遍历和中序遍历树构造二叉树.</p>
</blockquote>
<p>给出中序遍历：[1,2,3]和前序遍历：[2,1,3]. 返回如下的树:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; 2&#10;&#160;/ \&#10;1 &#160; 3</span><br></pre></td></tr></table></figure></p>
<p>你可以假设树中不存在相同数值的节点</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>本题与通过中序和后序遍历构造二叉树类似，同样是递归解决</li>
<li>前序遍历数组的第一个值为根节点，根据这个值可以将中序遍历数组分成左右两部分，分别为左子树和右子树</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type preorder: List[int]</span><br><span class="line">        :type inorder: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> inorder:</span><br><span class="line">            index = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> preorder[<span class="number">0</span>]</span><br><span class="line">            root = TreeNode(inorder[index])</span><br><span class="line">            root.left = self.buildTree(preorder, inorder[:index])</span><br><span class="line">            root.right = self.buildTree(preorder, inorder[index + <span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>根据前序遍历和中序遍历树构造二叉树.</p>
</blockquote>
<p>给出中序遍历：[1,2,3]和前序遍历：[2,1,3]. 返回如下的树:<br><figure class="highlight ]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[106 Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <link href="http://yoursite.com/2015/11/02/106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/"/>
    <id>http://yoursite.com/2015/11/02/106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</id>
    <published>2015-11-02T16:04:27.000Z</published>
    <updated>2015-11-03T00:18:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>中序遍历和后序遍历树构造二叉树</p>
</blockquote>
<p>给出树的中序遍历： [1,2,3] 和后序遍历： [1,3,2]<br>返回如下的树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#160; 2&#10;&#160;/ &#160;\&#10;1 &#160; &#160;3</span><br></pre></td></tr></table></figure></p>
<p>你可以假设树中不存在相同数值的节点</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>首先明确，前序+后序遍历的组合不能还原一棵二叉树</li>
<li>后序遍历的最后一个点是根节点，参照此根节点可以将中序遍历数组分成左右两部分，分别为左子树和右子树</li>
<li>依据以上思路递归重建二叉树 </li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type inorder: List[int]</span><br><span class="line">        :type postorder: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> inorder:</span><br><span class="line">            index = inorder.index(postorder.pop())</span><br><span class="line">            root = TreeNode(inorder[index])</span><br><span class="line">            root.right = self.buildTree(inorder[index+<span class="number">1</span>:], postorder)</span><br><span class="line">            root.left = self.buildTree(inorder[:index], postorder)</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>中序遍历和后序遍历树构造二叉树</p>
</blockquote>
<p>给出树的中序遍历： [1,2,3] 和后序遍历： [1,3,2]<br>返回如下的树：<br><figure class="highli]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[132 Palindrome Partitioning II]]></title>
    <link href="http://yoursite.com/2015/11/01/132-Palindrome-Partitioning-II/"/>
    <id>http://yoursite.com/2015/11/01/132-Palindrome-Partitioning-II/</id>
    <published>2015-11-02T02:37:44.000Z</published>
    <updated>2015-11-02T10:39:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个字符串s，将s分割成一些子串，使每个子串都是回文。<br>返回s符合要求的的最少分割次数。</p>
</blockquote>
<p>比如，给出字符串s =<strong> “aab”</strong>，<br>返回 1， 因为进行一次分割可以将字符串s分割成[“aa”,”b”]这样两个回文子串</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>序列型动态规划 - Sequence DP</li>
<li>cache[i]表示前i个字符组成的字符串需要最少cut几次保证子串都是回文串(或能被分割成多少个回文串 - 1)</li>
<li>初始化cache[i] = i -1</li>
<li>cache[0] = -1 (因为前0个字符串被分割成0个回文串，0 - 1 = -1)</li>
<li>状态转移方程：cache[i] = min(cache[j] + 1)<br>满足条件的j应该是<ul>
<li>j &lt; i</li>
<li>j+1 ~ i 这一段是回文串</li>
</ul>
</li>
<li>对于判断某一段是否是回文串，使用<strong>区间型动态规划</strong>可以将时间复杂度从O(n)优化到O(1)</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        IsPalindrome = self.getIsPalindrome(s)</span><br><span class="line">        cache = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(s) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) + <span class="number">1</span>):</span><br><span class="line">            cache[i] = i - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> IsPalindrome[j][i - <span class="number">1</span>]:</span><br><span class="line">                    cache[i] = min(cache[i], cache[j] + <span class="number">1</span>)</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> cache[len(s)]</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIsPalindrome</span><span class="params">(self, str)</span>:</span></span><br><span class="line">        IsPalindrome = [[<span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str))] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str))]</span><br><span class="line">        <span class="string">"""</span><br><span class="line">        initialize (0, 0), (1, 1)......</span><br><span class="line">        and (0, 1), (1, 2)......</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str)):</span><br><span class="line">            IsPalindrome[i][i] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> str[i] == str[i + <span class="number">1</span>]:</span><br><span class="line">                IsPalindrome[i][i + <span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span> length <span class="keyword">in</span> range(<span class="number">2</span>, len(str)):</span><br><span class="line">            <span class="keyword">for</span> start <span class="keyword">in</span> range(<span class="number">0</span>, len(str) - length):</span><br><span class="line">                IsPalindrome[start][start + length] = \</span><br><span class="line">                IsPalindrome[start + <span class="number">1</span>][start + length - <span class="number">1</span>] <span class="keyword">and</span> str[start] == str[start + length]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> IsPalindrome</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个字符串s，将s分割成一些子串，使每个子串都是回文。<br>返回s符合要求的的最少分割次数。</p>
</blockquote>
<p>比如，给出字符串s =<strong> “aab”</strong>]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sequence DP" scheme="http://yoursite.com/tags/Sequence-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[125 Valid Palidrome]]></title>
    <link href="http://yoursite.com/2015/11/01/125-Valid-Palidrome/"/>
    <id>http://yoursite.com/2015/11/01/125-Valid-Palidrome/</id>
    <published>2015-11-02T01:11:30.000Z</published>
    <updated>2015-11-02T09:13:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个字符串，判断其是否为一个回文串。只包含字母和数字，忽略大小写。</p>
</blockquote>
<p>“A man, a plan, a canal: Panama” 是一个回文。<br>“race a car” 不是一个回文。<br>在这个题目中，我们将空字符串判定为有效回文。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>两个指针的问题，<strong>对撞型指针</strong></li>
<li>一个从前往后，一个从后往前，判断如果不是数字或者字母则跳过<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果是数字或者字母返回 true</span></span><br><span class="line"><span class="string">"test"</span>.isalnum()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> <span class="keyword">not</span> s[l].isalnum():</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> <span class="keyword">not</span> s[r].isalnum():</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[l].lower() != s[r].lower():</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个字符串，判断其是否为一个回文串。只包含字母和数字，忽略大小写。</p>
</blockquote>
<p>“A man, a plan, a canal: Panama” 是一个回文。<br>“race]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[139 Word Break]]></title>
    <link href="http://yoursite.com/2015/11/01/139-Word-Break/"/>
    <id>http://yoursite.com/2015/11/01/139-Word-Break/</id>
    <published>2015-11-02T00:51:09.000Z</published>
    <updated>2015-11-02T08:52:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个字符串s和一个词典，判断字符串s是否可以被空格切分成一个或多个出现在字典中的单词。</p>
</blockquote>
<p>给出<br>s = <strong>“leetcode”</strong><br>dict = <strong>[“leet”,”code”]</strong><br>返回 true 因为<strong>“leetcode”</strong>可以被空格切分成<strong>“leet code”</strong></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>动态规划是一种解决问题的思想 - 大规模问题的结果，是由小规模问题的结果运算得来的</li>
<li><strong>动态规划不等同于递归，动态规划思想可以由递归来实现</strong></li>
<li>DP初始化时一般要有个<code>1</code>或者<code>true</code></li>
<li>本题属于序列型动态规划 - Sequence DP</li>
<li><code>cache[i]</code>表示前<code>i</code>个字符能不能被<code>dict</code>完美划分</li>
<li>判断<code>cache[i]</code>，则需要遍历<code>0~i</code>中是否存在一个<code>j</code>，使得<code>cache[j]=true</code>而且<code>j+1~i</code>存在于<code>dict</code>中</li>
<li>本题还有一个值得注意的地方，<strong>一定要考虑到单词长度是有上限的！</strong>，所以每次不需要遍历<code>0~i</code>而是<code>x~i</code>(i-x为单词最大长度)</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s, wordDict)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type wordDict: Set[str]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> wordDict:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        maxLength = self.getMaxLength(wordDict)</span><br><span class="line">        cache = [<span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s) + <span class="number">1</span>)]</span><br><span class="line">        cache[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(s) + <span class="number">1</span>):</span><br><span class="line">            j = <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= maxLength <span class="keyword">and</span> j &lt;= i:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cache[i - j]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> s[i - j:i] <span class="keyword">in</span> wordDict:</span><br><span class="line">                    cache[i] = <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> cache[len(s)]</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMaxLength</span><span class="params">(self, dict)</span>:</span></span><br><span class="line">        maxLength = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> dict:</span><br><span class="line">            maxLength = max(len(word), maxLength)</span><br><span class="line">        <span class="keyword">return</span> maxLength</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个字符串s和一个词典，判断字符串s是否可以被空格切分成一个或多个出现在字典中的单词。</p>
</blockquote>
<p>给出<br>s = <strong>“leetcode”</strong><]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sequence DP" scheme="http://yoursite.com/tags/Sequence-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[76 Longest Increasing Subsequence]]></title>
    <link href="http://yoursite.com/2015/10/31/76-Longest-Increasing-Subsequence/"/>
    <id>http://yoursite.com/2015/10/31/76-Longest-Increasing-Subsequence/</id>
    <published>2015-10-31T20:14:09.000Z</published>
    <updated>2015-11-01T03:15:10.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。</p>
</blockquote>
<p>给出<strong>[5,4,1,2,3]</strong>，这个LIS是<strong>[1,2,3]</strong>，返回 3<br>给出<strong>[4,2,4,5,3,7]</strong>，这个LIS是<strong>[4,4,5,7]</strong>，返回 4</p>
<p>最长上升子序列问题是在一个无序的给定序列中找到一个尽可能长的由低到高排列的子序列，这种子序列不一定是连续的或者唯一的。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>序列型动态规划 - Sequence DP</li>
<li>判定条件：序列非集合，求最长</li>
<li><code>cache[i]</code>表示以i结尾的最长子序列的长度</li>
<li>每次遍历<code>0 ~ i-1</code>如果存在<code>nums[x] &lt; nums[i]</code>并且<code>cache[x] + 1 &gt; cache[i]</code>则更新</li>
<li>for循环中维护一个<code>res</code>，即最大值</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param nums: The integer array</span><br><span class="line">    @return: The length of LIS (longest increasing subsequence)</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingSubsequence</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        cache = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt;= nums[i]:</span><br><span class="line">                    <span class="keyword">if</span> cache[j] + <span class="number">1</span> &gt; cache[i]:</span><br><span class="line">                        cache[i] = cache[j] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cache[i] &gt; res:</span><br><span class="line">                res = cache[i]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个整数序列，找到最长上升子序列（LIS），返回LIS的长度。</p>
</blockquote>
<p>给出<strong>[5,4,1,2,3]</strong>，这个LIS是<strong>[1,2,]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Sequence DP" scheme="http://yoursite.com/tags/Sequence-DP/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[45 Jump Game II]]></title>
    <link href="http://yoursite.com/2015/10/31/45-Jump-Game-II/"/>
    <id>http://yoursite.com/2015/10/31/45-Jump-Game-II/</id>
    <published>2015-10-31T19:37:41.000Z</published>
    <updated>2015-11-01T02:39:04.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个非负整数数组，你最初定位在数组的第一个位置。<br>数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
</blockquote>
<p>给出数组A =<strong> [2,3,1,1,4]</strong>，最少到达数组最后一个位置的跳跃次数是2(从数组下标0跳一步到数组下标1，然后跳3步到数组的最后一个位置，一共跳跃2次)</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>方法一：贪心(Greedy)<ul>
<li>维护一个<code>farthest</code>变量，每次在遍历<code>start</code>到<code>end</code>之间的元素，尝试更新<code>farthest</code>变量</li>
<li><code>start = end + 1</code></li>
<li><code>end = farthest</code></li>
<li>比较<code>end</code>时候大于数组长度，大于返回结果，否则<code>steps += 1</code></li>
</ul>
</li>
<li>方法二：动态规划(领会思路，OJ会超时)<ul>
<li>开辟一个<code>steps</code>数组长度与<code>input</code>数组相同，初始值为<code>maxint</code></li>
<li><code>steps[0] = 0</code></li>
<li><code>steps[i]</code>等于遍历<code>steps[0]</code> ~ <code>steps[i-1]</code>，如果存在<code>nums[x] + x &gt; i</code>，则更新<code>steps[i] = steps[x] + 1</code></li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：贪心</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        start, end, steps = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end &lt; len(nums) - <span class="number">1</span>:</span><br><span class="line">            steps += <span class="number">1</span></span><br><span class="line">            farthest = end</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + i &gt; farthest:</span><br><span class="line">                    farthest = nums[i] + i</span><br><span class="line">            start = end + <span class="number">1</span></span><br><span class="line">            end = farthest</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> steps</span><br><span class="line"><span class="comment"># 方法二：动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        steps = [sys.maxint <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        </span><br><span class="line">        steps[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> steps[j] != sys.maxint <span class="keyword">and</span> j + nums[j] &gt;= i:</span><br><span class="line">                    steps[i] = steps[j] + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> steps[len(nums) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个非负整数数组，你最初定位在数组的第一个位置。<br>数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
</blockquot]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[183 Wood Cut]]></title>
    <link href="http://yoursite.com/2015/10/31/183-Wood-Cut/"/>
    <id>http://yoursite.com/2015/10/31/183-Wood-Cut/</id>
    <published>2015-10-31T18:38:50.000Z</published>
    <updated>2015-11-01T01:39:30.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>有一些原木，现在想把这些木头切割成一些长度相同的小段木头，需要得到的小段的数目至少为 k。当然，我们希望得到的小段越长越好，你需要计算能够得到的小段木头的最大长度。</p>
</blockquote>
<p>有3根木头[232, 124, 456], k=7, 最大长度为114.</p>
<p>木头长度的单位是厘米。原木的长度都是正整数，我们要求切割得到的小段木头的长度也要求是整数。无法切出要求至少 k 段的,则返回 0 即可。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>思路：<strong>Binary Search</strong></li>
<li>问题又可以转化成在1和给的所有原木中最长的长度中间找一个合适的长度，使得把每段原木按此分段后得到的小段木头数目至少为k</li>
<li>扩展，<strong>除法转化为二分法</strong>，求100除以5，相当于在0到100之间找一个数使得x<em>5小于等于100，(x+1)\</em>5大于100</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param L: Given n pieces of wood with length L[i]</span><br><span class="line">    @param k: An integer</span><br><span class="line">    return: The maximum length of the small pieces.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">woodCut</span><span class="params">(self, L, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sum(L) &lt; k:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        start, end = <span class="number">1</span>, max(L)</span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            pieces = sum([l / mid <span class="keyword">for</span> l <span class="keyword">in</span> L])</span><br><span class="line">            <span class="keyword">if</span> pieces &gt;= k:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> sum([l / end <span class="keyword">for</span> l <span class="keyword">in</span> L]) &gt; k:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> start</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>有一些原木，现在想把这些木头切割成一些长度相同的小段木头，需要得到的小段的数目至少为 k。当然，我们希望得到的小段越长越好，你需要计算能够得到的小段木头的最大长度。</p>
</blockquote>
<p>有]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[41 First Missing Positive]]></title>
    <link href="http://yoursite.com/2015/10/31/41-First-Missing-Positive/"/>
    <id>http://yoursite.com/2015/10/31/41-First-Missing-Positive/</id>
    <published>2015-10-31T18:18:29.000Z</published>
    <updated>2015-11-01T01:19:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个无序的正数数组，找出其中没有出现的最小正整数。</p>
</blockquote>
<p>如果给出 [1,2,0], return 3 如果给出 [3,4,-1,1], return 2<br>只允许时间复杂度O(n)的算法，并且只能使用常数级别的空间。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>类似于<strong>桶排序的思路</strong>，对于每一个整数，我们按照一定的规则放到相应的位置上，最后再去检查如果指定位置的数不存在，即为没有出现的最小正整数</li>
<li>规则：1放在array[0]，2放在array[1]，以此类推<br>对于[3, 4, -1, 1]，运行最终结果为[1, -1, 3, 4]所以检查到array[1]时，2不存在，2即为没有出现的最小正整数</li>
<li>注意，遍历数组是，对于每一位要while循环至该位置的数字放到正确的位置为止<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> nums[i] &lt;= len(nums) <span class="keyword">and</span> nums[i] &gt; <span class="number">0</span> <span class="keyword">and</span> nums[nums[i] - <span class="number">1</span>] != nums[i]:</span><br><span class="line">    nums[nums[i] - <span class="number">1</span>], nums[i] = nums[i], nums[nums[i] - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">while</span> nums[i] &lt;= len(nums) <span class="keyword">and</span> nums[i] &gt; <span class="number">0</span> <span class="keyword">and</span> nums[nums[i] - <span class="number">1</span>] != nums[i]:</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>], nums[i] = nums[i], nums[nums[i] - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> len(nums) + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个无序的正数数组，找出其中没有出现的最小正整数。</p>
</blockquote>
<p>如果给出 [1,2,0], return 3 如果给出 [3,4,-1,1], return 2<br>只允许时]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[49 Group Anagrams]]></title>
    <link href="http://yoursite.com/2015/10/31/49-Group-Anagrams/"/>
    <id>http://yoursite.com/2015/10/31/49-Group-Anagrams/</id>
    <published>2015-10-31T17:43:31.000Z</published>
    <updated>2015-11-01T00:46:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个字符串数组S，找到其中所有的乱序字符串(Anagram)。如果一个字符串是乱序字符串，那么他存在一个字母集合相同，但顺序不同的字符串也在S中。</p>
</blockquote>
<p>对于字符串数组 [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]<br>返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;&#160; [&#34;ate&#34;, &#34;eat&#34;,&#34;tea&#34;],&#10;&#160; [&#34;nat&#34;,&#34;tan&#34;],&#10;&#160; [&#34;bat&#34;]&#10;]</span><br></pre></td></tr></table></figure></p>
<h1 id="解题思路">解题思路</h1><ul>
<li>首先，注意返回结果中，子字符串数组内要保持有序，所以第一步先把strs排序</li>
<li>本题考察使用hashtable，与直接判断两个字符串是否是anagram不同，遍历一遍字符串数组，将<strong>排序的字符串作为key</strong>，把原始字符串作为value</li>
<li>最后遍历hashtable生成结果</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type strs: List[str]</span><br><span class="line">        :rtype: List[List[str]]</span><br><span class="line">        """</span></span><br><span class="line">        strs.sort()</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> str <span class="keyword">in</span> strs:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">""</span>.join(sorted(str)) <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                d[<span class="string">""</span>.join(sorted(str))] = [str]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d[<span class="string">""</span>.join(sorted(str))].append(str)</span><br><span class="line">                </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">            res.append(value)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个字符串数组S，找到其中所有的乱序字符串(Anagram)。如果一个字符串是乱序字符串，那么他存在一个字母集合相同，但顺序不同的字符串也在S中。</p>
</blockquote>
<p>对于字符串数组 ]]>
    </summary>
    
      <category term="Hash" scheme="http://yoursite.com/tags/Hash/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[55 Jump Game]]></title>
    <link href="http://yoursite.com/2015/10/25/55-Jump-Game/"/>
    <id>http://yoursite.com/2015/10/25/55-Jump-Game/</id>
    <published>2015-10-26T03:34:39.000Z</published>
    <updated>2015-10-26T10:35:25.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个非负整数数组，你最初定位在数组的第一个位置。　　　<br>数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　　<br>判断你是否能到达数组的最后一个位置。</p>
</blockquote>
<p>A =<strong> [2,3,1,1,4]</strong>，返回 true.<br>A =<strong> [3,2,1,0,4]</strong>，返回 false.</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>方法一：贪心法 greedy</li>
<li>方法二：单序列型动态规划 - Sequence DP (因为题目中给的是序列而不是数组，注意两者的区别)，本题动归的方法不能过OJ</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一，贪心</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">        farest = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &lt;= farest <span class="keyword">and</span> nums[i] + i &gt; farest:</span><br><span class="line">                farest = nums[i] + i</span><br><span class="line">            <span class="keyword">if</span> farest &gt;= len(nums) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二，动态规划</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        cache = [<span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        cache[<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">                <span class="keyword">if</span> cache[j] <span class="keyword">is</span> <span class="keyword">True</span> <span class="keyword">and</span> j + nums[j] &gt;= i:</span><br><span class="line">                    cache[i] == <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> cache[len(nums) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出一个非负整数数组，你最初定位在数组的第一个位置。　　　<br>数组中的每个元素代表你在那个位置可以跳跃的最大长度。　　　　<br>判断你是否能到达数组的最后一个位置。</p>
</blockquote>
<]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="Greedy" scheme="http://yoursite.com/tags/Greedy/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sequence DP" scheme="http://yoursite.com/tags/Sequence-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[120 Triangle]]></title>
    <link href="http://yoursite.com/2015/10/25/120-Triangle/"/>
    <id>http://yoursite.com/2015/10/25/120-Triangle/</id>
    <published>2015-10-26T03:02:53.000Z</published>
    <updated>2015-10-26T10:03:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。</p>
</blockquote>
<p>比如，给出下列数字三角形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;&#160; &#160; &#160;[2],&#10;  &#160; [3,4],&#10;&#160; &#160;[6,5,7],&#10;&#160; [4,1,8,3]&#10;]</span><br></pre></td></tr></table></figure></p>
<p>从顶到底部的最小路径和为11 (<strong> 2 + 3 + 5 + 1 = 11</strong>)。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>矩阵型动态规划问题 - Matrix DP</li>
<li>有两种解决方案，自顶向下或者自底向上</li>
<li>下面代码采用自底向上的方法，cache[i][j]表明从最底层到i,j所用的最短距离是多少</li>
<li><code>cache[i][j]</code>就等于<code>cache[i+1][j]</code>(左下角)与<code>cache[i+1][j+1]</code>(右下角)中最小的加上<code>triangle[i][j]</code>的值</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type triangle: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> triangle:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        m = len(triangle)</span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            cache[m - <span class="number">1</span>][i] = triangle[m - <span class="number">1</span>][i]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m - i):</span><br><span class="line">                cache[m - <span class="number">1</span> - i][j] = min(cache[m - i][j], cache[m - i][j + <span class="number">1</span>]) + triangle[m - <span class="number">1</span> - i][j]</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> cache[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个数字三角形，找到从顶部到底部的最小路径和。每一步可以移动到下面一行的相邻数字上。</p>
</blockquote>
<p>比如，给出下列数字三角形：<br><figure class="highlig]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Matrix DP" scheme="http://yoursite.com/tags/Matrix-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[64 Minimum Path Sum]]></title>
    <link href="http://yoursite.com/2015/10/24/64-Minimum-Path-Sum/"/>
    <id>http://yoursite.com/2015/10/24/64-Minimum-Path-Sum/</id>
    <published>2015-10-25T03:32:25.000Z</published>
    <updated>2015-10-25T10:33:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。</p>
</blockquote>
<p>你在同一时间只能向下或者向右移动一步</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>矩阵型动态规划 - Matrix DP</li>
<li>与Unique Paths I/II非常类似，不同的是每次要找最小value</li>
<li>cache[i][j]表示从左上角到达i,j的数字和最小路径，它等于cache[i][j - 1]与cache[i - 1][j]的最小值，加上grid[i][j]的值</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type grid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid <span class="keyword">or</span> <span class="keyword">not</span> grid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(grid)</span><br><span class="line">        n = len(grid[<span class="number">0</span>])</span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">        sum1 = sum2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            sum1 += grid[<span class="number">0</span>][i]</span><br><span class="line">            cache[<span class="number">0</span>][i] = sum1</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            sum2 += grid[j][<span class="number">0</span>]</span><br><span class="line">            cache[j][<span class="number">0</span>] = sum2</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">                cache[j][i] = min(cache[j - <span class="number">1</span>][i], cache[j][i - <span class="number">1</span>]) + grid[j][i]</span><br><span class="line">        <span class="keyword">return</span> cache[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给定一个只含非负整数的m*n网格，找到一条从左上角到右下角的可以使数字和最小的路径。</p>
</blockquote>
<p>你在同一时间只能向下或者向右移动一步</p>
<h1 id="解题思路">解题思路]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Matrix DP" scheme="http://yoursite.com/tags/Matrix-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[70 Climbing Stairs]]></title>
    <link href="http://yoursite.com/2015/10/24/70-Climbing-Stairs/"/>
    <id>http://yoursite.com/2015/10/24/70-Climbing-Stairs/</id>
    <published>2015-10-25T03:20:40.000Z</published>
    <updated>2015-10-25T10:21:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？</p>
</blockquote>
<p>比如n=3，1+1+1=1+2=2+1=3，共有3中不同的方法<br>返回 3</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>本题本质和菲波那切数列问题非常相似</li>
<li>单序列型动态规划问题 - Sequence DP</li>
<li>cache[i]表示有i个台阶，能跳到第i个台阶的方案个数</li>
<li>因为每次可以跳一步或者跳两步，所以cache[i]就等于下面的和<ul>
<li>可以跳的i - 1的方案个数即cache[i - 1]</li>
<li>可以跳到i - 2的方案个数即cache[i - 2]</li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        cache = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        cache[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        cache[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            cache[i] = cache[i - <span class="number">1</span>] + cache[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> cache[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>假设你正在爬楼梯，需要n步你才能到达顶部。但每次你只能爬一步或者两步，你能有多少种不同的方法爬到楼顶部？</p>
</blockquote>
<p>比如n=3，1+1+1=1+2=2+1=3，共有3中不同的方法]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sequence DP" scheme="http://yoursite.com/tags/Sequence-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[63 Unique Paths II]]></title>
    <link href="http://yoursite.com/2015/10/24/63-Unique-Paths-II/"/>
    <id>http://yoursite.com/2015/10/24/63-Unique-Paths-II/</id>
    <published>2015-10-25T02:18:09.000Z</published>
    <updated>2015-10-25T09:18:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>现在考虑网格中有障碍物，那样将会有多少条不同的路径？<br>网格中的障碍和空位置分别用<strong>1</strong>和<strong>0</strong>来表示。</p>
</blockquote>
<p>如下所示在3x3的网格中有一个障碍物：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;&#160; [0,0,0],&#10;&#160; [0,1,0],&#10;&#160; [0,0,0]&#10;]</span><br></pre></td></tr></table></figure></p>
<p>一共有2条不同的路径从左上角到右下角。</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>同样是矩阵型动态规划 - Matrix DP</li>
<li>对于有障碍物的地图来说，只需要把<strong>障碍物的坐标设为0即可</strong></li>
<li>要注意对第一行和第一列的初始化，如果遇到障碍物第一行后面和第一列下面都是0</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type obstacleGrid: List[List[int]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obstacleGrid <span class="keyword">or</span> <span class="keyword">not</span> obstacleGrid[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m = len(obstacleGrid)</span><br><span class="line">        n = len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)] <span class="keyword">for</span> j <span class="keyword">in</span> range(m)]</span><br><span class="line">        flag1 = flag2 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m): </span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[j][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">                flag1 = <span class="number">0</span></span><br><span class="line">            cache[j][<span class="number">0</span>] = flag1</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>:</span><br><span class="line">                flag2 = <span class="number">0</span></span><br><span class="line">            cache[<span class="number">0</span>][i] = flag2</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                cache[j][i] = (cache[j - <span class="number">1</span>][i] + cache[j][i - <span class="number">1</span>]) <span class="keyword">if</span> obstacleGrid[j][i] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> cache[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>现在考虑网格中有障碍物，那样将会有多少条不同的路径？<br>网格中的障碍和空位置分别用<strong>1</strong>和<strong>0</strong>来表示。</p>
</blockquote>
<p]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Matrix DP" scheme="http://yoursite.com/tags/Matrix-DP/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
</feed>
