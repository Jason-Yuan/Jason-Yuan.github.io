<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Chemistry]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-09-15T08:45:53.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Jason Yuan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[277 Find the Celebrity]]></title>
    <link href="http://yoursite.com/2016/09/14/277-Find-the-Celebrity/"/>
    <id>http://yoursite.com/2016/09/14/277-Find-the-Celebrity/</id>
    <published>2016-09-15T01:43:58.000Z</published>
    <updated>2016-09-15T08:45:53.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>Suppose you are at a party with n people (labeled from 0 ton - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the othern - 1 people know him/her but he/she does not know any of them.<br>Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: “Hi, A. Do you know B?” to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).<br>You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a functionint findCelebrity(n), your function should minimize the number of calls toknows.<br><strong>Note</strong>: There will be exactly one celebrity if he/she is in the party. Return the celebrity’s label if there is a celebrity in the party. If there is no celebrity, return-1.</p>
</blockquote>
<h3 id="解题思路">解题思路</h3><ul>
<li>第一个for循环，从第0个人开始，如果k是第0个人认识的第一个人，说明1到k-1这些人0不认识，所以排除了名人的可能。按照此规则进行下去，最后candidate停在某一个位置，这个位置后面一定也没有名人，因为有的话，candidate会update等于它</li>
<li>最后检查candidate对不对</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The knows API is already defined for you.  </span></span><br><span class="line"><span class="comment"># @param a, person a  </span></span><br><span class="line"><span class="comment"># @param b, person b  </span></span><br><span class="line"><span class="comment"># @return a boolean, whether a knows b  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knows</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">""" </span><br><span class="line">        :type n: int </span><br><span class="line">        :rtype: int </span><br><span class="line">        """</span></span><br><span class="line">        candidate = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> knows(candidate, i):</span><br><span class="line">                candidate = i</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> candidate != i <span class="keyword">and</span> (knows(candidate, i) <span class="keyword">or</span> knows(i, candidate)):</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>Suppose you are at a party with n people (labeled from 0 ton - 1) and among them, there may exist one cel]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[361 Bomb Enemy]]></title>
    <link href="http://yoursite.com/2016/09/11/361-Bomb-Enemy/"/>
    <id>http://yoursite.com/2016/09/11/361-Bomb-Enemy/</id>
    <published>2016-09-11T18:24:15.000Z</published>
    <updated>2016-09-12T01:24:37.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>Given a 2D grid, each cell is either a wall ‘W’, an enemy ‘E’ or empty ‘0’ (the number zero), return the maximum enemies you can kill using one bomb.The bomb kills all the enemies in the same row and column from the planted point until it hits the wall since the wall is too strong to be destroyed.</p>
</blockquote>
<p><strong>样例</strong><br>给出如下矩阵<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> E <span class="number">0</span> <span class="number">0</span></span><br><span class="line">E <span class="number">0</span> W E</span><br><span class="line"><span class="number">0</span> E <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>返回3，把炸弹放在(1, 1)可以炸死3个敌人</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>双重for循环遍历矩阵</li>
<li>如果是第一行或者第一列，就记录一下current到下一个墙中间的敌人数量，知道下一次遇见墙，重新计算这面墙之后到下一面墙中间的敌人数量</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;character[][]&#125; grid Given a 2D grid, each cell is either 'W', 'E' or '0'</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer, the maximum enemies you can kill using one bomb</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxKilledEnemies</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        m, n = len(grid), <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> m:</span><br><span class="line">            n = len(grid[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        res, rows = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        cols = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">or</span> grid[i][j - <span class="number">1</span>] == <span class="string">"W"</span>:</span><br><span class="line">                    rows = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(j, n):</span><br><span class="line">                        <span class="keyword">if</span> grid[i][k] == <span class="string">"W"</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">if</span> grid[i][k] == <span class="string">"E"</span>:</span><br><span class="line">                            rows += <span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> grid[i - <span class="number">1</span>][j] == <span class="string">"W"</span>:</span><br><span class="line">                    cols[j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> range(i, m):</span><br><span class="line">                        <span class="keyword">if</span> grid[k][j] == <span class="string">"W"</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">if</span> grid[k][j] == <span class="string">"E"</span>:</span><br><span class="line">                            cols[j] += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">"0"</span> <span class="keyword">and</span> rows + cols[j] &gt; res:</span><br><span class="line">                    res = rows + cols[j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>Given a 2D grid, each cell is either a wall ‘W’, an enemy ‘E’ or empty ‘0’ (the number zero), return the ]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[298 Binary Tree Longest Consecutive Sequence]]></title>
    <link href="http://yoursite.com/2016/09/07/298-Binary-Tree-Longest-Consecutive-Sequence/"/>
    <id>http://yoursite.com/2016/09/07/298-Binary-Tree-Longest-Consecutive-Sequence/</id>
    <published>2016-09-07T22:59:05.000Z</published>
    <updated>2016-09-08T05:59:37.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一个二叉树，求其中最长连续序列的长度</p>
</blockquote>
<p><strong>样例</strong><br>比如，下面的树，最长序列为3-&gt;4-&gt;5，返回3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#10; \&#10;  3&#10; / \&#10;2   4&#10;     \&#10;      5</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>递归求解，分别向左右子树递归，判断当前值跟左儿子右儿子的值是否连续，连续则+1，否则重置为1</li>
<li>global变量res，不断更新</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        self.result = <span class="number">0</span></span><br><span class="line">        self.helper(root, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, curLen)</span>:</span></span><br><span class="line">        self.result = curLen <span class="keyword">if</span> curLen &gt; self.result <span class="keyword">else</span> self.result</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            <span class="keyword">if</span> root.left.val == root.val + <span class="number">1</span>:</span><br><span class="line">                self.helper(root.left, curLen + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.helper(root.left, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            <span class="keyword">if</span> root.right.val == root.val + <span class="number">1</span>:</span><br><span class="line">                self.helper(root.right, curLen + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.helper(root.right, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一个二叉树，求其中最长连续序列的长度</p>
</blockquote>
<p><strong>样例</strong><br>比如，下面的树，最长序列为3-&gt;4-&gt;5，返回3<br><figure]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[394 Decode String]]></title>
    <link href="http://yoursite.com/2016/09/05/394-Decode-String/"/>
    <id>http://yoursite.com/2016/09/05/394-Decode-String/</id>
    <published>2016-09-05T20:47:00.000Z</published>
    <updated>2016-09-06T03:47:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一段string，解码</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"3[a]2[bc]"</span>, <span class="keyword">return</span> <span class="string">"aaabcbc"</span>.</span><br><span class="line">s = <span class="string">"3[a2[c]]"</span>, <span class="keyword">return</span> <span class="string">"accaccacc"</span>.</span><br><span class="line">s = <span class="string">"2[abc]3[cd]ef"</span>, <span class="keyword">return</span> <span class="string">"abcabccdcdcdef"</span>.</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>一个stack记录倍数</li>
<li>一个stack记录string</li>
<li>遇到”[“添加倍数(因为倍数可能是“123”…), 遇到”]”弹出一段string乘以倍数，再压入栈</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decodeString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">        digit = []</span><br><span class="line">        string = []</span><br><span class="line">        temp_digit = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char.isdigit():</span><br><span class="line">                temp_digit += char</span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">"["</span>:</span><br><span class="line">                digit.append(int(temp_digit))</span><br><span class="line">                string.append(char)</span><br><span class="line">                temp_digit = <span class="string">""</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">"]"</span>:</span><br><span class="line">                cur = []</span><br><span class="line">                temp = string.pop() </span><br><span class="line">                <span class="keyword">while</span> string <span class="keyword">and</span> temp != <span class="string">"["</span>:</span><br><span class="line">                    cur.insert(<span class="number">0</span>, temp)</span><br><span class="line">                    temp = string.pop()</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(digit.pop()):</span><br><span class="line">                    string += cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                string.append(char)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(string)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一段string，解码</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight python"><table><tr><td ]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Stack" scheme="http://yoursite.com/tags/Stack/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[144 Interleaving Positive and Negative Numbers]]></title>
    <link href="http://yoursite.com/2016/09/05/144-Interleaving-Positive-and-Negative-Numbers/"/>
    <id>http://yoursite.com/2016/09/05/144-Interleaving-Positive-and-Negative-Numbers/</id>
    <published>2016-09-05T19:17:11.000Z</published>
    <updated>2016-09-06T02:18:18.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个含有正整数和负整数的数组，重新排列成一个正负数交错的数组。</p>
</blockquote>
<p><strong>样例</strong><br>给出数组[-1, -2, -3, 4, 5, 6]，重新排序之后，变成[-1, 5, -2, 4, -3, 6]<br>或者其他任何满足要求的答案</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>扫第一遍，确定正数多还是负数多，多的放在0位</li>
<li>partition数组，前面都是正数后面都睡负数，或者相反，根据谁多</li>
<li>两步一跳，生成需要的正负间隔的数组</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param A: An integer array.</span><br><span class="line">    @return nothing</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rerange</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        pos, neg = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> A:</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                neg += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> pos &gt; neg:</span><br><span class="line">            left, right = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">while</span> A[left] &gt; <span class="number">0</span> <span class="keyword">and</span> left &lt; right:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> A[right] &lt; <span class="number">0</span> <span class="keyword">and</span> left &lt; right:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                    A[left], A[right] = A[right], A[left]</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">            left, right = <span class="number">1</span>, len(A) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                A[left], A[right] = A[right], A[left]</span><br><span class="line">                left += <span class="number">2</span></span><br><span class="line">                right -= <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left, right = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">while</span> A[left] &lt; <span class="number">0</span> <span class="keyword">and</span> left &lt; right:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> A[right] &gt; <span class="number">0</span> <span class="keyword">and</span> left &lt; right:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> left &lt;= right:</span><br><span class="line">                    A[left], A[right] = A[right], A[left]</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pos == neg:</span><br><span class="line">                left, right = <span class="number">1</span>, len(A) - <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left, right = <span class="number">1</span>, len(A) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                A[left], A[right] = A[right], A[left]</span><br><span class="line">                left += <span class="number">2</span></span><br><span class="line">                right -= <span class="number">2</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个含有正整数和负整数的数组，重新排列成一个正负数交错的数组。</p>
</blockquote>
<p><strong>样例</strong><br>给出数组[-1, -2, -3, 4, 5, 6]，重]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[389 Find the Difference]]></title>
    <link href="http://yoursite.com/2016/09/05/389-Find-the-Difference/"/>
    <id>http://yoursite.com/2016/09/05/389-Find-the-Difference/</id>
    <published>2016-09-05T18:25:28.000Z</published>
    <updated>2016-09-06T01:26:54.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出两个字符串，只有一处不同，一个字符串比两一个多一个字符，找出这个字符</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = <span class="string">"abcd"</span></span><br><span class="line">t = <span class="string">"abcde"</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">e</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"><span class="string">'e'</span> <span class="keyword">is</span> the letter that was added.</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>合并两个字符串，题目转化为寻找单身狗</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTheDifference</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type s: str</span><br><span class="line">        :type t: str</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        temp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s + t:</span><br><span class="line">            temp = temp ^ ord(char)</span><br><span class="line">        <span class="keyword">return</span> chr(temp)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出两个字符串，只有一处不同，一个字符串比两一个多一个字符，找出这个字符</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[38 Count and Say]]></title>
    <link href="http://yoursite.com/2016/09/05/38-Count-and-Say/"/>
    <id>http://yoursite.com/2016/09/05/38-Count-and-Say/</id>
    <published>2016-09-05T18:12:33.000Z</published>
    <updated>2016-09-06T01:13:31.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>报数指的是，按照其中的整数的顺序进行报数，然后得到下一个数。如下所示：<br>1, 11, 21, 1211, 111221, …<br>1 读作 “one 1” -&gt; 11.<br>11 读作 “two 1s” -&gt; 21.<br>21 读作 “one 2, then one 1” -&gt; 1211.<br>给定一个整数 n, 返回 第 n 个顺序。</p>
</blockquote>
<p><strong>样例</strong><br>给定 n = 5, 返回 “111221”.</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>内层for循环负责每次更新newS，比如把“1”更新为“11”</li>
<li>外层循环n次，表示n次更新，返回结果</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: str</span><br><span class="line">        """</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">        newS = <span class="string">"1"</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> i &lt; n:</span><br><span class="line">            s = newS</span><br><span class="line">            newS = <span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s)):</span><br><span class="line">                <span class="keyword">if</span> j+<span class="number">1</span> &lt; len(s) <span class="keyword">and</span> s[j] == s[j+<span class="number">1</span>]:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    newS += str(count) + s[j]</span><br><span class="line">                    count = <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> newS</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>报数指的是，按照其中的整数的顺序进行报数，然后得到下一个数。如下所示：<br>1, 11, 21, 1211, 111221, …<br>1 读作 “one 1” -&gt; 11.<br>11 读作 “two]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[387 The Smallest Difference]]></title>
    <link href="http://yoursite.com/2016/09/05/387-The-Smallest-Difference/"/>
    <id>http://yoursite.com/2016/09/05/387-The-Smallest-Difference/</id>
    <published>2016-09-05T17:46:56.000Z</published>
    <updated>2016-09-06T00:47:55.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定两个整数数组（第一个是数组 A，第二个是数组 B），在数组 A 中取 A[i]，数组 B 中取 B[j]，A[i] 和 B[j]两者的差越小越好(|A[i] - B[j]|)。返回最小差。</p>
</blockquote>
<p><strong>样例</strong><br>给定数组 A = [3,4,6,7]， B = [2,3,8,9]，返回 0。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>Two Pointers</li>
<li>首先给两个数组排序</li>
<li>两个指针分别指向两个数组的起始点，每次计算difference，谁小向前移动谁</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param A, B: Two lists of integer</span></span><br><span class="line">    <span class="comment"># @return: An integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestDifference</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        A = sorted(A)</span><br><span class="line">        B = sorted(B)</span><br><span class="line">        res = sys.maxint</span><br><span class="line">        p1, p2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; len(A) <span class="keyword">and</span> p2 &lt; len(B):</span><br><span class="line">            <span class="keyword">if</span> A[p1] &gt; B[p2]:</span><br><span class="line">                res = min(res, A[p1] - B[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = min(res, B[p2] - A[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定两个整数数组（第一个是数组 A，第二个是数组 B），在数组 A 中取 A[i]，数组 B 中取 B[j]，A[i] 和 B[j]两者的差越小越好(|A[i] - B[j]|)。返回最小差。</p>
</bl]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[22 Generate Parentheses]]></title>
    <link href="http://yoursite.com/2016/09/04/22-Generate-Parentheses/"/>
    <id>http://yoursite.com/2016/09/04/22-Generate-Parentheses/</id>
    <published>2016-09-05T01:23:58.000Z</published>
    <updated>2016-09-05T08:24:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定 n 对括号，请写一个函数以将其生成新的括号组合，并返回所有组合结果。</p>
</blockquote>
<p><strong>样例</strong><br>给定 n = 3, 可生成的组合如下:<br>“((()))”, “(()())”, “(())()”, “()(())”, “()()()”</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>求所有的组合，递归， backtracking</li>
<li>left，right分别代表左括号和右括号还剩几个 - 规则就是：任何时候剩余的右括号都要大于等于左括号</li>
<li>当left和right都等于零的时候，向result中添加一个可行解</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: List[str]</span><br><span class="line">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        self.helper(n, n, <span class="string">""</span>, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, left, right, path, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">            res.append(path)</span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="number">0</span>:</span><br><span class="line">            self.helper(left - <span class="number">1</span>, right, path + <span class="string">"("</span>, res)</span><br><span class="line">        <span class="keyword">if</span> right &gt; <span class="number">0</span>:</span><br><span class="line">            self.helper(left, right - <span class="number">1</span>, path + <span class="string">")"</span>, res)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定 n 对括号，请写一个函数以将其生成新的括号组合，并返回所有组合结果。</p>
</blockquote>
<p><strong>样例</strong><br>给定 n = 3, 可生成的组合如下:<br>]]>
    </summary>
    
      <category term="Backtracking" scheme="http://yoursite.com/tags/Backtracking/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[221 Maximal Square]]></title>
    <link href="http://yoursite.com/2016/09/04/221-Maximal-Square/"/>
    <id>http://yoursite.com/2016/09/04/221-Maximal-Square/</id>
    <published>2016-09-04T20:04:50.000Z</published>
    <updated>2016-09-05T03:05:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个二维01矩阵中找到全为1的最大正方形</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>返回 4</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>动态规划</li>
<li>dp[i][j]跟左上，左，上三个位置最大能延伸的正方形边长相关，如果dp[i][j]不等于0，则是三个中的最小值+1</li>
<li>初始化第一行，第一列，然后双层for循环更新</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type matrix: List[List[str]]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        width = len(matrix[<span class="number">0</span>])</span><br><span class="line">        height = len(matrix)</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(width)] <span class="keyword">for</span> j <span class="keyword">in</span> range(height)]</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(width):</span><br><span class="line">            dp[<span class="number">0</span>][i] = int(matrix[<span class="number">0</span>][i])</span><br><span class="line">            ans = max(ans, dp[<span class="number">0</span>][i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(height):</span><br><span class="line">            dp[j][<span class="number">0</span>] = int(matrix[j][<span class="number">0</span>])</span><br><span class="line">            ans = max(ans, dp[j][<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, height):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, width):</span><br><span class="line">                <span class="keyword">if</span> matrix[j][i] != <span class="string">"0"</span>:</span><br><span class="line">                    dp[j][i] = min(dp[j-<span class="number">1</span>][i-<span class="number">1</span>], min(dp[j-<span class="number">1</span>][i], dp[j][i-<span class="number">1</span>])) + <span class="number">1</span></span><br><span class="line">                    ans = max(ans, dp[j][i])</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans * ans</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个二维01矩阵中找到全为1的最大正方形</p>
</blockquote>
<p><strong>样例</strong><br><figure class="highlight python"><table]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[398 Longest Increasing Continuous Subsequence II]]></title>
    <link href="http://yoursite.com/2016/09/04/398-Longest-Increasing-Continuous-Subsequence-II/"/>
    <id>http://yoursite.com/2016/09/04/398-Longest-Increasing-Continuous-Subsequence-II/</id>
    <published>2016-09-04T19:13:05.000Z</published>
    <updated>2016-09-05T02:13:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个整数矩阵（其中，有 n 行， m 列），请找出矩阵中的最长上升连续子序列。（最长上升连续子序列可从任意行或任意列开始，向上/下/左/右任意方向移动）。</p>
</blockquote>
<p><strong>样例</strong><br>给定一个矩阵<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span> ,<span class="number">2</span> ,<span class="number">3</span> ,<span class="number">4</span> ,<span class="number">5</span>],</span><br><span class="line">  [<span class="number">16</span>,<span class="number">17</span>,<span class="number">24</span>,<span class="number">23</span>,<span class="number">6</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">18</span>,<span class="number">25</span>,<span class="number">22</span>,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">14</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">13</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>返回 25</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>类似于滑雪问题</li>
<li>记忆化搜索 - 因为对于某一个点，可以从上下左右更新，所以很难写出for循环那种DP</li>
<li>所谓记忆化所有，就是当我想更新matrix[x][y]的时候，我需要知道以matrix[x-1][y], matrix[x][y-1], matrix[x+1][y], matrix[x][y+1]这四个点结尾的最大长度，每次求出以matrix某个点结尾的连续的最大长度之后，都记录下来，下一次先去记忆的matrix中找，没有再算，有的话直接返回值</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[][]&#125; A an integer matrix</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125;  an integer</span></span><br><span class="line">    DIRECTIONS = [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, -<span class="number">1</span>), (-<span class="number">1</span>, <span class="number">0</span>)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingContinuousSubsequenceII</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">0</span> <span class="keyword">or</span> len(A[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        self.width = len(A[<span class="number">0</span>])</span><br><span class="line">        self.height = len(A)</span><br><span class="line">        self.matrix = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(self.width)] <span class="keyword">for</span> j <span class="keyword">in</span> range(self.height)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.height):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.width):</span><br><span class="line">                self.search(A, i, j)</span><br><span class="line">        <span class="keyword">return</span> max(max(row) <span class="keyword">for</span> row <span class="keyword">in</span> self.matrix)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, A, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.matrix[x][y] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.matrix[x][y]</span><br><span class="line">        </span><br><span class="line">        longest = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> dx, dy <span class="keyword">in</span> self.DIRECTIONS:</span><br><span class="line">            <span class="keyword">if</span> x + dx &lt; <span class="number">0</span> <span class="keyword">or</span> x + dx &gt;= self.height:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> y + dy &lt; <span class="number">0</span> <span class="keyword">or</span> y + dy &gt;= self.width:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> A[x][y] &gt;= A[x + dx][y + dy]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            longest = max(longest, self.search(A, x + dx, y + dy) + <span class="number">1</span>)</span><br><span class="line">        self.matrix[x][y] = longest</span><br><span class="line">        <span class="keyword">return</span> self.matrix[x][y]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个整数矩阵（其中，有 n 行， m 列），请找出矩阵中的最长上升连续子序列。（最长上升连续子序列可从任意行或任意列开始，向上/下/左/右任意方向移动）。</p>
</blockquote>
<p><str]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[397 Longest Increasing Continuous Subsequence]]></title>
    <link href="http://yoursite.com/2016/09/04/397-Longest-Increasing-Continuous-Subsequence/"/>
    <id>http://yoursite.com/2016/09/04/397-Longest-Increasing-Continuous-Subsequence/</id>
    <published>2016-09-04T18:52:15.000Z</published>
    <updated>2016-09-05T01:53:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）</p>
</blockquote>
<p><strong>样例</strong><br>给定 [5, 4, 2, 1, 3], 其最长上升连续子序列（LICS）为[5, 4, 2, 1], 返回 4.<br>给定 [5, 1, 2, 3, 4], 其最长上升连续子序列（LICS）为[1, 2, 3, 4], 返回 4.</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>正序逆序各求一个最长序列的值，取最大</li>
<li>一个全局变量res记录最长的长度，一个局部变量temp<ul>
<li>当nums[i] &gt; nums[i - 1]时，temp加1</li>
<li>当nums[i] &lt;= nums[i - 1]时，temp重置为1</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; A an array of Integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125;  an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestIncreasingContinuousSubsequence</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">return</span> max(self.helper(A), self.helper(A[::-<span class="number">1</span>]))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        res, temp = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i - <span class="number">1</span>] <span class="keyword">or</span> i == <span class="number">0</span>:</span><br><span class="line">                temp += <span class="number">1</span></span><br><span class="line">                res = max(res, temp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个整数数组（下标从 0 到 n-1， n 表示整个数组的规模），请找出该数组中的最长上升连续子序列。（最长上升连续子序列可以定义为从右到左或从左到右的序列。）</p>
</blockquote>
<p><]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[213 House Robber II]]></title>
    <link href="http://yoursite.com/2016/09/04/213-House-Robber-II/"/>
    <id>http://yoursite.com/2016/09/04/213-House-Robber-II/</id>
    <published>2016-09-04T18:05:23.000Z</published>
    <updated>2016-09-05T01:07:03.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在上次打劫完一条街道之后，窃贼又发现了一个新的可以打劫的地方，<strong>但这次所有的房子围成了一个圈，这就意味着第一间房子和最后一间房子是挨着的</strong>。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：<strong>相邻的房子装着相互联系的防盗系统，且 当相邻的两个房子同一天被打劫时，该系统会自动报警</strong>。<br>给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，你最多可以得到多少钱 在不触动报警装置的情况下。</p>
</blockquote>
<p><strong>样例</strong><br>给出nums = [3,6,4], 返回　6，　你不能打劫3和4所在的房间，因为它们围成一个圈，是相邻的．</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>状态转移方程和【House Robber I】是一样的，唯一的区别是房子看成环状的，所以首位只能二选一</li>
<li>不包括头求一个最大值，不包括尾再求一个最大值。最后返回较大的</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = <span class="number">0</span>, nums[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">        ans = dp[len(nums) - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> max(dp[len(nums) - <span class="number">2</span>], ans)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在上次打劫完一条街道之后，窃贼又发现了一个新的可以打劫的地方，<strong>但这次所有的房子围成了一个圈，这就意味着第一间房子和最后一间房子是挨着的</strong>。每个房子都存放着特定金额的钱。你面临的唯]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[198 House Robber]]></title>
    <link href="http://yoursite.com/2016/09/04/198-House-Robber/"/>
    <id>http://yoursite.com/2016/09/04/198-House-Robber/</id>
    <published>2016-09-04T18:00:18.000Z</published>
    <updated>2016-09-05T01:01:11.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 <strong>当相邻的两个房子同一天被打劫时，该系统会自动报警</strong>。<br>给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，你最多可以得到多少钱 <strong>在不触动报警装置的情况下</strong>。</p>
</blockquote>
<p><strong>样例</strong><br>给定 [3, 8, 4], 返回 8.</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>单序列型动态规划</li>
<li>dp[i]代表前i个房子能获得的最大价值，所以<code>dp[i] = max(dp[i-1], dp[i-2] + nums[i])</code></li>
<li>可以使用滚动数组优化</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = nums[<span class="number">0</span>], max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, len(nums)):</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[len(nums) - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 <strong>当相邻的两个房子同一天被打劫时，该系统会自动报警</s]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[57 Insert Interval]]></title>
    <link href="http://yoursite.com/2016/09/04/57-Insert-Interval/"/>
    <id>http://yoursite.com/2016/09/04/57-Insert-Interval/</id>
    <published>2016-09-04T17:04:36.000Z</published>
    <updated>2016-09-05T00:05:14.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个<strong>无重叠的</strong>按照区间起始端点排序的区间列表。<br>在列表中插入一个新的区间，你要确保列表中的区间仍然有序且<strong>不重叠</strong>（如果有必要的话，可以合并区间）。</p>
</blockquote>
<p><strong>样例</strong><br>插入区间<strong>[2, 5]</strong> 到 <strong>[[1,2], [5,9]]</strong>，我们得到 <strong>[[1,9]]
</strong>。<br>插入区间<strong>[3, 4]</strong> 到 <strong>[[1,2], [5,9]]</strong>，我们得到<strong> [[1,2], [3,4], [5,9]]</strong>。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>遍历每一个区间，进行更新，对区间和给定新区间进行判断，是否交叉<ul>
<li>interval.end &lt; newInterval.start，一定不交叉，该interval可以直接加入到result数组，但是insertPos要加一</li>
<li>interval.start &gt; newInterval.end，也一定不交叉，直接把该interval加入到result数组</li>
<li>剩下的情况，则表示两个interval交叉了，要更新newInterval的边界<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newInterval.start = min(interval.start, newInterval.start)</span><br><span class="line">newInterval.end = max(interval.end, newInterval.end)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals, newInterval)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type intervals: List[Interval]</span><br><span class="line">        :type newInterval: Interval</span><br><span class="line">        :rtype: List[Interval]</span><br><span class="line">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        insertPos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> interval.end &lt; newInterval.start:</span><br><span class="line">                res.append(interval)</span><br><span class="line">                insertPos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> interval.start &gt; newInterval.end:</span><br><span class="line">                res.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                newInterval.start = min(interval.start, newInterval.start)</span><br><span class="line">                newInterval.end = max(interval.end, newInterval.end)</span><br><span class="line">        res.insert(insertPos, newInterval)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个<strong>无重叠的</strong>按照区间起始端点排序的区间列表。<br>在列表中插入一个新的区间，你要确保列表中的区间仍然有序且<strong>不重叠</strong>（如果有必要的话，可以合]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[56 Merge Intervals]]></title>
    <link href="http://yoursite.com/2016/09/04/56-Merge-Intervals/"/>
    <id>http://yoursite.com/2016/09/04/56-Merge-Intervals/</id>
    <published>2016-09-04T16:36:05.000Z</published>
    <updated>2016-09-04T23:36:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出若干闭合区间，合并所有重叠的部分。</p>
</blockquote>
<p><strong>样例</strong><br>给出的区间列表 =&gt; 合并后的区间列表：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[                     [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">3</span>],               [<span class="number">1</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">6</span>],      =&gt;       [<span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">  [<span class="number">8</span>, <span class="number">10</span>],              [<span class="number">15</span>, <span class="number">18</span>]</span><br><span class="line">  [<span class="number">15</span>, <span class="number">18</span>]            ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>首先，把区间按照起始点排序</li>
<li>然后遍历每一个区间<ul>
<li>如果result中的最后一个区间的end小于下一个区间的start，则加入下一个区间</li>
<li>若大于则update这个<code>end = max(res[-1].end, interval.end)</code></li>
</ul>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for an interval.</span></span><br><span class="line"><span class="comment"># class Interval(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, s=0, e=0):</span></span><br><span class="line"><span class="comment">#         self.start = s</span></span><br><span class="line"><span class="comment">#         self.end = e</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type intervals: List[Interval]</span><br><span class="line">        :rtype: List[Interval]</span><br><span class="line">        """</span></span><br><span class="line">        intervals = sorted(intervals, key=<span class="keyword">lambda</span> x:x.start)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> interval <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> res[-<span class="number">1</span>].end &lt; interval.start:</span><br><span class="line">                res.append(interval)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[-<span class="number">1</span>].end = max(res[-<span class="number">1</span>].end, interval.end)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出若干闭合区间，合并所有重叠的部分。</p>
</blockquote>
<p><strong>样例</strong><br>给出的区间列表 =&gt; 合并后的区间列表：<br><figure class=]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Sort" scheme="http://yoursite.com/tags/Sort/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[378 Kth Smallest Sum in Sorted Matrix]]></title>
    <link href="http://yoursite.com/2016/09/04/378-Kth-Smallest-Sum-in-Sorted-Matrix/"/>
    <id>http://yoursite.com/2016/09/04/378-Kth-Smallest-Sum-in-Sorted-Matrix/</id>
    <published>2016-09-04T16:04:46.000Z</published>
    <updated>2016-09-04T23:09:16.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个排序矩阵中找从小到大的第 <em>k</em> 个整数。<br>排序矩阵的定义为：每一行递增，每一列也递增。</p>
</blockquote>
<p><strong>样例</strong><br>给出 <em>k</em> = 4和一个排序矩阵：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span> ,<span class="number">5</span> ,<span class="number">7</span>],</span><br><span class="line">  [<span class="number">3</span> ,<span class="number">7</span> ,<span class="number">8</span>],</span><br><span class="line">  [<span class="number">4</span> ,<span class="number">8</span> ,<span class="number">9</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>返回 5。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>首先把左上角的元素放入minHeap中，进入while循环，每次pop一个最小值，然后把该位置右边和下班的值+坐标放入minHeap中。k减一，当k等于0时，返回当前的值</li>
<li>同时要注意，另外开一个二维数组记录哪些元素已经被访问过，因为同一个元素可能在A的下面和B的右面</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, matrix, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type matrix: List[List[int]]</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        exist = [[<span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>]))] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(matrix))]</span><br><span class="line">        q = Queue.PriorityQueue()</span><br><span class="line">        q.put((matrix[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        exist[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            cur, x, y = q.get()</span><br><span class="line">            <span class="keyword">if</span> x + <span class="number">1</span> &lt; len(matrix) <span class="keyword">and</span> <span class="keyword">not</span> exist[x+<span class="number">1</span>][y]:</span><br><span class="line">                q.put((matrix[x+<span class="number">1</span>][y], x+<span class="number">1</span>, y))</span><br><span class="line">                exist[x+<span class="number">1</span>][y] = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> y + <span class="number">1</span> &lt; len(matrix[<span class="number">0</span>]) <span class="keyword">and</span> <span class="keyword">not</span> exist[x][y+<span class="number">1</span>]:</span><br><span class="line">                q.put((matrix[x][y+<span class="number">1</span>], x, y+<span class="number">1</span>))</span><br><span class="line">                exist[x][y+<span class="number">1</span>] = <span class="keyword">True</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个排序矩阵中找从小到大的第 <em>k</em> 个整数。<br>排序矩阵的定义为：每一行递增，每一列也递增。</p>
</blockquote>
<p><strong>样例</strong><br>给出 ]]>
    </summary>
    
      <category term="Heap" scheme="http://yoursite.com/tags/Heap/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[113 Path Sum II]]></title>
    <link href="http://yoursite.com/2016/08/17/113-Path-Sum-II/"/>
    <id>http://yoursite.com/2016/08/17/113-Path-Sum-II/</id>
    <published>2016-08-18T00:25:34.000Z</published>
    <updated>2016-08-18T07:26:25.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个二叉树和一个sum, 找出所有存在的自根节点到叶节点的路径，如果路径和等于sum</p>
</blockquote>
<p><strong>样例</strong><br>给出如下二叉树和 sum = 22<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">      5&#10;     / \&#10;    4   8&#10;   /   / \&#10;  11  13  4&#10; /  \    / \&#10;7    2  5   1</span><br></pre></td></tr></table></figure></p>
<p>返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#10;   [5,4,11,2],&#10;   [5,8,4,5]&#10;]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>二叉树遍历</li>
<li>helper函数要保存subSum, path，当节点为根节点而且和等于sum时，向res中添加此刻的path</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type sum: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        """</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        self.helper(root, [], <span class="number">0</span>, sum, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, path, subSum, sum, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> subSum + root.val == sum:</span><br><span class="line">                res.append(path + [root.val])</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.helper(root.left, path + [root.val], subSum + root.val, sum, res)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.helper(root.right, path + [root.val], subSum + root.val, sum, res)</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个二叉树和一个sum, 找出所有存在的自根节点到叶节点的路径，如果路径和等于sum</p>
</blockquote>
<p><strong>样例</strong><br>给出如下二叉树和 sum = 2]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[112 Path Sum]]></title>
    <link href="http://yoursite.com/2016/08/17/112-Path-Sum/"/>
    <id>http://yoursite.com/2016/08/17/112-Path-Sum/</id>
    <published>2016-08-18T00:14:54.000Z</published>
    <updated>2016-08-18T07:15:32.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个二叉树和一个sum, 判断是否存在一条自根节点到叶节点路径，使路径和等于sum</p>
</blockquote>
<p><strong>样例</strong><br>给出下面的二叉树 和 sum = 22<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">      5&#10;     / \&#10;    4   8&#10;   /   / \&#10;  11  13  4&#10; /  \      \&#10;7    2      1</span><br></pre></td></tr></table></figure></p>
<p>返回 True 因为5-&gt;4-&gt;11-&gt;2 的和等于22</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>二叉树遍历</li>
<li>如果找到一个根到叶的路径求和，如果等于sum直接返回True</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :type sum: int</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> self.helper(root, <span class="number">0</span>, sum) == <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, subSum, sum)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> subSum + root.val == sum:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> root.left <span class="keyword">and</span> self.helper(root.left, subSum + root.val, sum):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> root.right <span class="keyword">and</span> self.helper(root.right, subSum + root.val, sum):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个二叉树和一个sum, 判断是否存在一条自根节点到叶节点路径，使路径和等于sum</p>
</blockquote>
<p><strong>样例</strong><br>给出下面的二叉树 和 sum = ]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[366 Fibonacci]]></title>
    <link href="http://yoursite.com/2016/08/17/366-Fibonacci/"/>
    <id>http://yoursite.com/2016/08/17/366-Fibonacci/</id>
    <published>2016-08-17T23:12:01.000Z</published>
    <updated>2016-08-18T06:13:33.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>查找斐波纳契数列中第 N 个数。<br>所谓的斐波纳契数列是指：<br>前2个数是 0 和 1 。<br>第 <em>i</em> 个数是第 <em>i</em>-1 个数和第<em>i</em>-2 个数的和。</p>
<p>斐波纳契数列的前10个数字是：<br>0, 1, 1, 2, 3, 5, 8, 13, 21, 34 …</p>
</blockquote>
<p><strong>样例</strong><br>给定 1，返回 0<br>给定 2，返回 1<br>给定 10，返回 34</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>方法一： 递归求解</li>
<li>方法二：动态规划 - 记忆化搜索</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Method 1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n: an integer</span></span><br><span class="line">    <span class="comment"># @return an integer f(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> n == <span class="number">2</span> <span class="keyword">or</span> n == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.fibonacci(n - <span class="number">1</span>) + self.fibonacci(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param n: an integer</span></span><br><span class="line">    <span class="comment"># @return an integer f(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        T = [<span class="keyword">None</span>] * (n+<span class="number">1</span>)   <span class="comment"># T = [None, None, None, None ......]</span></span><br><span class="line">        T[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        T[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            T[i] = T[i-<span class="number">1</span>] + T[i-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> T[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>查找斐波纳契数列中第 N 个数。<br>所谓的斐波纳契数列是指：<br>前2个数是 0 和 1 。<br>第 <em>i</em> 个数是第 <em>i</em>-1 个数和第<em>i</em>-2 个数的和]]>
    </summary>
    
      <category term="Dynamic Programming" scheme="http://yoursite.com/tags/Dynamic-Programming/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
</feed>
