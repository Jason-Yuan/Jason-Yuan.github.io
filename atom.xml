<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Code Chemistry]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-05-28T09:17:45.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Jason Yuan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[101 Symmetric Tree]]></title>
    <link href="http://yoursite.com/2016/05/27/101-Symmetric-Tree/"/>
    <id>http://yoursite.com/2016/05/27/101-Symmetric-Tree/</id>
    <published>2016-05-28T02:05:11.000Z</published>
    <updated>2016-05-28T09:17:45.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个二叉树，检查他是不是自己的镜像(轴对称)</p>
</blockquote>
<p>样例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> / \ / \</span><br><span class="line"><span class="number">3</span>  <span class="number">4</span> <span class="number">4</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>是对称二叉树<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>不是对称二叉树</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>写一个helper函数，递归求解，但注意helper函数的形参left和right不是指的左儿子和右儿子。那上面的例子为例，我们要传入3，3和4，4</li>
<li>Divide and Conquer的思路 - 如果<code>left.left, right.right</code>和<code>left.right, right.left</code>都对称则整棵树对称</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: bool</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            <span class="keyword">return</span> self.helper(root.left, root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right <span class="keyword">and</span> left.val == right.val:</span><br><span class="line">            <span class="keyword">return</span> self.helper(left.left, right.right) <span class="keyword">and</span> \</span><br><span class="line">                    self.helper(left.right, right.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个二叉树，检查他是不是自己的镜像(轴对称)</p>
</blockquote>
<p>样例<br><figure class="highlight python"><table><tr><td class]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[469 Identical Binary Tree]]></title>
    <link href="http://yoursite.com/2016/05/27/469-Identical-Binary-Tree/"/>
    <id>http://yoursite.com/2016/05/27/469-Identical-Binary-Tree/</id>
    <published>2016-05-28T01:34:08.000Z</published>
    <updated>2016-05-28T08:35:02.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>检查两棵二叉树是否等价。等价的意思是说，首先两棵二叉树必须拥有相同的结构，并且每个对应位置上的节点上的数都相等。</p>
</blockquote>
<p>样例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">   / \           / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">2</span>   <span class="keyword">and</span>   <span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> /             /</span><br><span class="line"><span class="number">4</span>             <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>就是两棵等价的二叉树。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">   / \           / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span>   <span class="keyword">and</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> /               \</span><br><span class="line"><span class="number">4</span>                 <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>就不是等价的。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>如果两棵树都是None，认为是等价的</li>
<li>Recursion - 递归求解，分治的思路，如果<code>a.val == b.val</code>，则只需考虑左右子树是不是Identical Binary Tree</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        this.val = val</span><br><span class="line">        this.left, this.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param a, b, the root of binary trees.</span><br><span class="line">    @return true if they are identical, or false.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isIdentical</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> b <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">and</span> b <span class="keyword">and</span> a.val == b.val:</span><br><span class="line">            <span class="keyword">return</span> self.isIdentical(a.left, b.left) <span class="keyword">and</span> self.isIdentical(a.right, b.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>检查两棵二叉树是否等价。等价的意思是说，首先两棵二叉树必须拥有相同的结构，并且每个对应位置上的节点上的数都相等。</p>
</blockquote>
<p>样例<br><figure class="highli]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[470 Tweaked Identical Binary Tree]]></title>
    <link href="http://yoursite.com/2016/05/27/470-Tweaked-Identical-Binary-Tree/"/>
    <id>http://yoursite.com/2016/05/27/470-Tweaked-Identical-Binary-Tree/</id>
    <published>2016-05-28T01:32:42.000Z</published>
    <updated>2016-05-28T08:33:48.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>检查两棵二叉树是否在经过若干次扭转后可以等价。扭转的定义是，交换任意节点的左右子树。等价的定义是，两棵二叉树必须为相同的结构，并且对应位置上的节点的值要相等。<br>注意：你可以假设二叉树中不会有重复的节点值。</p>
</blockquote>
<p>样例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">   / \           / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span>   <span class="keyword">and</span>   <span class="number">3</span>   <span class="number">2</span></span><br><span class="line"> /                   \</span><br><span class="line"><span class="number">4</span>                     <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>是扭转后可等价的二叉树。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span>             <span class="number">1</span></span><br><span class="line">   / \           / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">3</span>   <span class="keyword">and</span>   <span class="number">3</span>   <span class="number">2</span></span><br><span class="line"> /             /</span><br><span class="line"><span class="number">4</span>             <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>就不是扭转后可以等价的二叉树。</p>
<h3 id="解题思路">解题思路</h3><ul>
<li>Recursion - 递归求解，分治的思路。</li>
<li>注意，题目中说的是经过若干次扭转后可以等价，所以不要忘记考虑完全identical的情况，某一个节点的左右子树翻转一次对称，反转两次还原。</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        this.val = val</span><br><span class="line">        this.left, this.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param a, b, the root of binary trees.</span><br><span class="line">    @return true if they are tweaked identical, or false.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isTweakedIdentical</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> b <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> a <span class="keyword">and</span> b <span class="keyword">and</span> a.val == b.val:</span><br><span class="line">            <span class="keyword">return</span> self.isTweakedIdentical(a.left, b.right) <span class="keyword">and</span> \</span><br><span class="line">                    self.isTweakedIdentical(a.right, b.left) <span class="keyword">or</span> \</span><br><span class="line">                    self.isTweakedIdentical(a.left, b.left) <span class="keyword">and</span> \</span><br><span class="line">                    self.isTweakedIdentical(a.right, b.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>检查两棵二叉树是否在经过若干次扭转后可以等价。扭转的定义是，交换任意节点的左右子树。等价的定义是，两棵二叉树必须为相同的结构，并且对应位置上的节点的值要相等。<br>注意：你可以假设二叉树中不会有重复的节点值。]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[376 Binary Tree Path Sum]]></title>
    <link href="http://yoursite.com/2016/05/27/376-Binary-Tree-Path-Sum/"/>
    <id>http://yoursite.com/2016/05/27/376-Binary-Tree-Path-Sum/</id>
    <published>2016-05-27T22:36:31.000Z</published>
    <updated>2016-05-28T05:38:44.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个二叉树，找出所有路径中各节点相加总和等于给定 目标值<br> 的路径。<br>一个有效的路径，指的是从根节点到叶节点的路径。</p>
</blockquote>
<p>给定一个二叉树，和目标值 = 5<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">1</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>返回<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<h3 id="解题思路">解题思路</h3><ul>
<li>DFS - 递归求解 </li>
<li>类似于求subset的思路，维护一个path，从根节点向下分别沿左右子树搜索。在确保当前节点不为空的情况下，求剩余值<code>remaining = target - root.val</code><ul>
<li>如果剩余值为0 - 把当前的path加入到result中</li>
<li>如果剩余值不为0 - 继续向下朝左右子树寻找，target传入remaining的值</li>
</ul>
</li>
<li>注意每次path要加入root.val，但是每次返回上一层要pop出去刚刚加入的值，或者换一种方式<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.helper(root.left, remaining, result, path+[root.val])</span><br><span class="line">    self.helper(root.right, remaining, result, path+[root.val])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left, self.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;TreeNode&#125; root the root of binary tree</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int[][]&#125; all valid paths</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePathSum</span><span class="params">(self, root, target)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        res = []</span><br><span class="line">        self.helper(root, target, res, [])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, target, result, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            remaining = target - root.val</span><br><span class="line">            <span class="keyword">if</span> remaining == <span class="number">0</span>:</span><br><span class="line">                result.append(path+[root.val])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                path.append(root.val)</span><br><span class="line">                self.helper(root.left, remaining, result, path)</span><br><span class="line">                self.helper(root.right, remaining, result, path)</span><br><span class="line">                path.pop()</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给定一个二叉树，找出所有路径中各节点相加总和等于给定 目标值<br> 的路径。<br>一个有效的路径，指的是从根节点到叶节点的路径。</p>
</blockquote>
<p>给定一个二叉树，和目标值 = 5<]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C#中的Indexer索引器]]></title>
    <link href="http://yoursite.com/2016/05/19/C-%E4%B8%AD%E7%9A%84Indexer%E7%B4%A2%E5%BC%95%E5%99%A8/"/>
    <id>http://yoursite.com/2016/05/19/C-中的Indexer索引器/</id>
    <published>2016-05-19T23:54:04.000Z</published>
    <updated>2016-05-20T06:56:03.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>C#的索引器允许我们对一个<strong>实例</strong>像数组一样进行索引。当我们在一个类中定义了索引器之后，我们可以通过数组操作符([ ])像操作数组一样来访问这个类的实例。</p>
<ul>
<li>索引器的好处就是简化的数组和集合成员的存取操作。</li>
<li>索引器可被重载。</li>
<li>索引器可以有多个形参，例如当访问二维数组时。</li>
</ul>
<h1 id="syntax_–_from_MSDN">syntax – from MSDN</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">this</span>[<span class="keyword">int</span> index]    <span class="comment">// Indexer declaration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// get and set accessors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例子">例子</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Example</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Class Student</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> Number &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Sex &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">indexerExample</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">// 注意下面的数组是private，体现encapsulation, OOP原则</span></span><br><span class="line">       <span class="keyword">private</span> List&lt;Student&gt; students= <span class="keyword">new</span> List&lt;Student&gt;();</span><br><span class="line">       students.Add( <span class="keyword">new</span> Student &#123; Number = <span class="number">1</span>,</span><br><span class="line">                                   Name = <span class="string">"Jason"</span>,</span><br><span class="line">                                   Sex = <span class="string">"Male"</span> &#125;);</span><br><span class="line">       students.Add( <span class="keyword">new</span> Student &#123; Number = <span class="number">2</span>,</span><br><span class="line">                                   Name = <span class="string">"Maggie"</span>,</span><br><span class="line">                                   Sex = <span class="string">"Female"</span> &#125;);</span><br><span class="line">       students.Add( <span class="keyword">new</span> Student &#123; Number = <span class="number">3</span>,</span><br><span class="line">                                   Name = <span class="string">"Lucy"</span>,</span><br><span class="line">                                   Sex = <span class="string">"Female "</span>&#125;);</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span>(<span class="params"><span class="keyword">string</span> name</span>)</span><br><span class="line">       </span>&#123;</span><br><span class="line">           <span class="keyword">foreach</span> student <span class="keyword">in</span> students</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (student.Name == name)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> student;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span>(<span class="params"><span class="keyword">int</span> num</span>)</span><br><span class="line">       </span>&#123;</span><br><span class="line">           <span class="keyword">foreach</span> student <span class="keyword">in</span> students</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span> (student.Number == num)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">return</span> student;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//define indexer</span></span><br><span class="line">       <span class="keyword">public</span> student <span class="keyword">this</span>[<span class="keyword">int</span> num]  </span><br><span class="line">       &#123;  </span><br><span class="line">           <span class="keyword">get</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">foreach</span> student <span class="keyword">in</span> students</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (student.Number == num)</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">return</span> student;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// overload indexer</span></span><br><span class="line">       <span class="keyword">public</span> student <span class="keyword">this</span>[<span class="keyword">string</span> name]</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">get</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">foreach</span> student <span class="keyword">in</span> students</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span> (student.Name == name)</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">return</span> student;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)  </span><br><span class="line">        </span>&#123;  </span><br><span class="line">            Student myStudents = <span class="keyword">new</span> indexerExample();  </span><br><span class="line">            </span><br><span class="line">            Console.WriteLine(myStudents.getStudent(<span class="number">1</span>).Sex);</span><br><span class="line">            Console.WriteLine(myStudents[<span class="number">1</span>].Sex);</span><br><span class="line">            Console.WriteLine(myStudent.getStudent(<span class="string">"Maggie"</span>).Sex);</span><br><span class="line">            Console.WriteLine(myStudents[<span class="string">"Maggie"</span>].Sex);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// "Male"</span></span><br><span class="line"><span class="comment">// "Male"</span></span><br><span class="line"><span class="comment">// "Female"</span></span><br><span class="line"><span class="comment">// "Female"</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>C#的索引器允许我们对一个<strong>实例</strong>像数组一样进行索引。当我们在一个类中定义了索引器之后，我们可以通过数组操作符([ ])像操作数组一样来访问这个类的实例。</p>
<ul>
<li>索引器的好处就是简化的数组和集合成员的存取操作。</]]>
    </summary>
    
      <category term="C#学习笔记" scheme="http://yoursite.com/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Indexer" scheme="http://yoursite.com/tags/Indexer/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[460  K Closest Numbers In Sorted Array]]></title>
    <link href="http://yoursite.com/2016/05/18/460-K-Closest-Numbers-In-Sorted-Array/"/>
    <id>http://yoursite.com/2016/05/18/460-K-Closest-Numbers-In-Sorted-Array/</id>
    <published>2016-05-19T01:38:34.000Z</published>
    <updated>2016-05-19T08:39:12.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一个目标数 target, 一个非负整数 k, 一个按照升序排列的数组 A。在A中找与target最接近的k个整数。返回这k个数并按照与target的接近程度从小到大排序，如果接近程度相当，那么小的数排在前面。</p>
</blockquote>
<ul>
<li>如果 A = [1, 2, 3], target = 2 and k = 3, 那么返回 [2, 1, 3]</li>
<li>如果 A = [1, 4, 6, 8], target = 3 and k = 3, 那么返回 [4, 1, 6]</li>
</ul>
<h3 id="解题思路">解题思路</h3><ul>
<li>使用Binary Search找到最接近的数字的位置</li>
<li>双指针从该位置左右移动，每次比较找到最接近的数字，加入到答案中，相应的指针++</li>
<li>中间while循环可以略作简化，通过优先处理特殊情况<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> left &lt; <span class="number">0</span>:</span><br><span class="line">                res.append(A[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> right &gt; len(A) - <span class="number">1</span>:</span><br><span class="line">                res.append(A[left])</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> abs(A[left] - target) &lt;= abs(A[right] - target):</span><br><span class="line">                    res.append(A[left])</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(A[right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; A an integer array</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; k a non-negative integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int[]&#125; an integer array</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosestNumbers</span><span class="params">(self, A, target, k)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">        res = []</span><br><span class="line">        index = self.binarySearch(A, target)</span><br><span class="line">        res.append(A[index])</span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        left, right = index - <span class="number">1</span>, index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt;= len(A) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> abs(A[left] - target) &lt;= abs(A[right] - target):</span><br><span class="line">                    res.append(A[left])</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(A[right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> left &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">while</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> right &lt;= len(A) - <span class="number">1</span>:</span><br><span class="line">                    res.append(A[right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> right &gt; len(A) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">while</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> left &gt;= <span class="number">0</span>:</span><br><span class="line">                    res.append(A[left])</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(self, L, target)</span>:</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(L) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> L[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> L[mid] &gt; target:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> start <span class="keyword">if</span> abs(L[start] - target) &lt;= abs(L[end] - target) <span class="keyword">else</span> end</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给一个目标数 target, 一个非负整数 k, 一个按照升序排列的数组 A。在A中找与target最接近的k个整数。返回这k个数并按照与target的接近程度从小到大排序，如果接近程度相当，那么小的数排在前面]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Two Pointers" scheme="http://yoursite.com/tags/Two-Pointers/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[462 Total Occurrence of Target]]></title>
    <link href="http://yoursite.com/2016/05/18/462-Total-Occurrence-of-Target/"/>
    <id>http://yoursite.com/2016/05/18/462-Total-Occurrence-of-Target/</id>
    <published>2016-05-19T01:00:05.000Z</published>
    <updated>2016-05-19T08:00:53.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个目标数字和一个升序整数数组，返回目标数字在数组中出现的次数。</p>
</blockquote>
<ul>
<li>给出 [1, 3, 3, 4, 5] 并且 target = 3, 返回 2.</li>
<li>给出 [2, 2, 3, 4, 6] 并且 target = 4, 返回 1</li>
<li>给出 [1, 2, 3, 4, 5] 并且 target = 6, 返回 0</li>
</ul>
<h3 id="解题思路">解题思路</h3><ul>
<li>二分法， 分两步：找到第一个出现的位置， 找到最后一个出现的位置。就可以计算出出现频率</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; A an integer array sorted in ascending order</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">totalOccurrence</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] &lt;= target:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> A[end] == target:</span><br><span class="line">            right = end</span><br><span class="line">        <span class="keyword">elif</span> A[start] == target:</span><br><span class="line">            right = start</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] &gt;= target:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> A[start] == target:</span><br><span class="line">            left = start</span><br><span class="line">        <span class="keyword">elif</span> A[end] == target:</span><br><span class="line">            left = end</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个目标数字和一个升序整数数组，返回目标数字在数组中出现的次数。</p>
</blockquote>
<ul>
<li>给出 [1, 3, 3, 4, 5] 并且 target = 3, 返回 2.</li]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[459 Closest Number in Sorted Array]]></title>
    <link href="http://yoursite.com/2016/05/18/459-Closest-Number-in-Sorted-Array/"/>
    <id>http://yoursite.com/2016/05/18/459-Closest-Number-in-Sorted-Array/</id>
    <published>2016-05-19T00:47:02.000Z</published>
    <updated>2016-05-19T07:47:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个目标数字和一个整数升序数组，找到一个i使得A[i]与目标数字最为接近。</p>
</blockquote>
<ul>
<li>给出 [1, 2, 3] 并且 target = 2, 返回 1</li>
<li>给出 [1, 4, 6] 并且 target = 3, 返回 1</li>
<li>给出 [1, 4, 6] 并且 target = 5, 返回 1 or 2</li>
<li>给出 [1, 3, 3, 4] 并且 target = 2, 返回 0 or 1 or 2</li>
</ul>
<h3 id="解题思路">解题思路</h3><ul>
<li>二分法，直接找target，找到返回index，如果没有找到则target在<strong>A[start]和A[end]之间</strong>，比较之后，返回正确的index</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; A an integer array sorted in ascending order</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestNumber</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> A[mid] &gt; target:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> start <span class="keyword">if</span> abs(A[start] - target) &lt; abs(A[end] - target) <span class="keyword">else</span> end</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>给出一个目标数字和一个整数升序数组，找到一个i使得A[i]与目标数字最为接近。</p>
</blockquote>
<ul>
<li>给出 [1, 2, 3] 并且 target = 2, 返回 1</li>
]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[458 Last Position of Target]]></title>
    <link href="http://yoursite.com/2016/05/18/458-Last-Position-of-Target/"/>
    <id>http://yoursite.com/2016/05/18/458-Last-Position-of-Target/</id>
    <published>2016-05-19T00:21:55.000Z</published>
    <updated>2016-05-19T07:23:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个排序数组中找一个数，返回该数出现的最后一个位置，如果不存在，返回-1</p>
</blockquote>
<p>给出数组 [1, 2, 2, 4, 5, 5]</p>
<ul>
<li>对于 target = 2, 返回 2.</li>
<li>对于 target = 5, 返回 5.</li>
<li>对于 target = 6, 返回 -1.</li>
</ul>
<h3 id="解题思路">解题思路</h3><ul>
<li>二分法，对于找最后一个位置的要求：<strong>只有target大于A[end]才会<code>end = mid</code></strong></li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; A an integer array sorted in ascending order</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastPosition</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] &lt;= target:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> A[end] == target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">if</span> A[start] == target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个排序数组中找一个数，返回该数出现的最后一个位置，如果不存在，返回-1</p>
</blockquote>
<p>给出数组 [1, 2, 2, 4, 5, 5]</p>
<ul>
<li>对于 target]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[457 Classical Binary Search]]></title>
    <link href="http://yoursite.com/2016/05/18/457-Classical-Binary-Search/"/>
    <id>http://yoursite.com/2016/05/18/457-Classical-Binary-Search/</id>
    <published>2016-05-19T00:09:36.000Z</published>
    <updated>2016-05-19T07:10:50.000Z</updated>
    <content type="html"><![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个排序数组中找一个数，返回该数出现的任意位置，如果不存在，返回-1</p>
</blockquote>
<p>给出数组 [1, 2, 2, 4, 5, 5]</p>
<ul>
<li>对于 target = 2, 返回 1 或者 2.</li>
<li>对于 target = 5, 返回 4 或者 5.</li>
<li>对于 target = 6, 返回 -1.</li>
</ul>
<h3 id="解题思路">解题思路</h3><ul>
<li>标准的二分法解决 - Binary Search 模板程序</li>
</ul>
<h3 id="完整代码">完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;int[]&#125; A an integer array sorted in ascending order</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; target an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;int&#125; an integer</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPosition</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        <span class="keyword">if</span> A <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> A == []:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> A[mid] &gt; target:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> A[start] == target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> A[end] == target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="原题">原题</h3><blockquote>
<p>在一个排序数组中找一个数，返回该数出现的任意位置，如果不存在，返回-1</p>
</blockquote>
<p>给出数组 [1, 2, 2, 4, 5, 5]</p>
<ul>
<li>对于 target =]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Binary Search" scheme="http://yoursite.com/tags/Binary-Search/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C#中的?和??]]></title>
    <link href="http://yoursite.com/2016/05/13/C-%E4%B8%AD%E7%9A%84-%E5%92%8C/"/>
    <id>http://yoursite.com/2016/05/13/C-中的-和/</id>
    <published>2016-05-13T23:40:38.000Z</published>
    <updated>2016-05-20T06:56:05.000Z</updated>
    <content type="html"><![CDATA[<hr>
<blockquote>
<p>单问号—用于给变量设初值的时候,给变量(int类型)赋值为null,而不是0!<br>双问号—用于判断并赋值,先判断当前变量是否为null,如果是就可以赋一个新值,否则跳过!</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>? para;</span><br><span class="line"><span class="comment">//public int para;如果不注释掉此行,而把上一行注释掉的话,下面会报错!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">par</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.para ?? <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值类型后面加问号表示可为空null(Nullable 结构) </p>
<p>Nullable是.NET 2.0中新提供的一种用于标明一个值类型是否可以为空的技术。</p>
<ul>
<li>例：<code>public int? age;</code> 等同 <code>Nullable&lt;int&gt;</code></li>
</ul>
<p>对于一个类型，如果既可以给它分配一个值，也可以给它分配空引用null（表示没有任何值），我们就说这个类型是可空的。  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>? num = <span class="keyword">null</span>;   <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="keyword">null</span>;    <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>Nullable 结构支持 将值类型 扩展为可以为null，但不支持 在引用类型 上使用，因为引用类型本身就是可空的。</p>
<p>设置值的写法 Arg = value;</p>
<p>获取值的写法 Arg.Value;</p>
<p>判断非空的写法 Arg.HasValue </p>
<p>语法 <strong>T?</strong> 是Nullable<t>的简写，此处的 <strong>T</strong> 为值类型。</t></p>
<h1 id="概念">概念</h1><p><strong>GUID</strong>： 即Globally Unique Identifier（全球唯一标识符） 也称作 UUID(Universally Unique IDentifier) 。 GUID是一个通过特定算法产生的二进制长度为128位的数字标识符，用于指示产品的唯一性。GUID 主要用于在拥有多个节点、多台计算机的网络或系统中，分配必须具有唯一性的标识符。<br>在 Windows 平台上，GUID 广泛应用于微软的产品中，用于标识如如注册表项、类及接口标识、数据库、系统目录等对象。<br><strong>格式</strong><br>GUID 的格式为“xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx”，其中每个 x 是 0-9 或 a-f 范围内的一个32位十六进制数。例如：6F9619FF-8B86-D011-B42D-00C04FC964FF 即为有效的 GUID 值。</p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<blockquote>
<p>单问号—用于给变量设初值的时候,给变量(int类型)赋值为null,而不是0!<br>双问号—用于判断并赋值,先判断当前变量是否为null,如果是就可以赋一个新值,否则跳过!</p>
</blockquote>
<figure class]]>
    </summary>
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="C#学习笔记" scheme="http://yoursite.com/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C#" scheme="http://yoursite.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用C#中BackgroundWorker]]></title>
    <link href="http://yoursite.com/2016/05/13/%E4%BD%BF%E7%94%A8C-%E4%B8%ADBackgroundWorker/"/>
    <id>http://yoursite.com/2016/05/13/使用C-中BackgroundWorker/</id>
    <published>2016-05-13T23:34:36.000Z</published>
    <updated>2016-05-20T06:56:02.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h1 id="使用前提">使用前提</h1><p>在WPF程序中，有一些比较耗时的后台操作时，比如向远程服务器请求数据，或者通过TCP/IP为某台设备提供升级固件服务等等。为了防止这类操作freeze用户界面，造成用户体验下降，即程序假死的状况出现。一种常见的，更user friendly的方式是，提供一个进度条窗口，提示用户该操作的完成进度。并提供取消操作的选项。</p>
<p>C#中的<a href="https://msdn.microsoft.com/en-us/library/system.componentmodel.backgroundworker(v=vs.110" target="_blank" rel="external"> BackgroundWorker Class </a>.aspx)则是执行该任务的最佳选择。</p>
<blockquote>
<p>The BackgroundWorker class allows you to run an operation on a separate, dedicated thread. Time-consuming operations like downloads and database transactions can cause your user interface (UI) to seem as though it has stopped responding while they are running. When you want a responsive UI and you are faced with long delays associated with such operations, theBackgroundWorker class provides a convenient solution.<br><strong>-MSDN</strong></p>
</blockquote>
<h1 id="关于_BackgroundWorker_类">关于 BackgroundWorker 类</h1><p><strong>主要属性</strong></p>
<ul>
<li><code>CancellationPending</code> - 只读属性，default值为false，执行CancelAsync方法后，值为true。表明应用程序请求了取消后台操作。</li>
<li><code>IsBusy</code> - 如果后台异步操作开始执行，值为true，否则为false</li>
<li><code>WorkerReportProgress</code> - 如果BackgroundWorker支持后台操作进程更新，设置值为true，default值为false</li>
</ul>
<p><strong>主要事件</strong></p>
<ul>
<li><code>DoWork</code></li>
<li><code>ProgressChanged</code></li>
<li><code>RunWorkerCompleted</code><br>不要再DoWork事件处理程序中对UI线程中的对象进行操作，操作应该放在ProgressChanged和RunWorkerCompleted的事件处理程序中。</li>
</ul>
<p><strong>主要方法</strong> </p>
<ul>
<li><code>RunWorkerAsync()</code> - 执行后台操作，激发DoWork事件</li>
<li><code>ReportProgress()</code>- 激发ProgressChanged事件</li>
<li><code>CancelAsync()</code> - 提交终止后台操作的请求，并将CancellationPending属性值设为true。在程序其他地方要定时检查CancellationPending属性的值，作出相应操作，比如<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (worker.CancellationPending)</span><br><span class="line">&#123;</span><br><span class="line">    e.Cancel = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="示例程序">示例程序</h1><p>XAML<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Window</span> <span class="attribute">x:Class</span>=<span class="value">"BackgroundWorkerExample.MainWindow"</span>  </span><br><span class="line">        <span class="attribute">xmlns</span>=<span class="value">"http://schemas.microsoft.com/winfx/2006/xaml/presentation"</span>  </span><br><span class="line">        <span class="attribute">xmlns:x</span>=<span class="value">"http://schemas.microsoft.com/winfx/2006/xaml"</span>  </span><br><span class="line">        <span class="attribute">Title</span>=<span class="value">"MainWindow"</span> <span class="attribute">Height</span>=<span class="value">"150"</span> <span class="attribute">Width</span>=<span class="value">"300"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">StackPanel</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">ProgressBar</span> <span class="attribute">Name</span>=<span class="value">"progressBar"</span> <span class="attribute">Height</span>=<span class="value">"20"</span> <span class="attribute">Width</span>=<span class="value">"250"</span> <span class="attribute">Margin</span>=<span class="value">"10"</span>&gt;</span><span class="tag">&lt;/<span class="title">ProgressBar</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">TextBox</span> <span class="attribute">Name</span>=<span class="value">"textBox"</span> <span class="attribute">Width</span>=<span class="value">"50"</span> <span class="attribute">Height</span>=<span class="value">"20"</span> <span class="attribute">HorizontalAlignment</span>=<span class="value">"Center"</span>&gt;</span><span class="tag">&lt;/<span class="title">TextBox</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">Button</span> <span class="attribute">Name</span>=<span class="value">"btnProcess"</span> <span class="attribute">Width</span>=<span class="value">"100"</span> <span class="attribute">Click</span>=<span class="value">"btnProcess_Click"</span> <span class="attribute">Margin</span>=<span class="value">"5"</span>&gt;</span>Start<span class="tag">&lt;/<span class="title">Button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">Button</span> <span class="attribute">Name</span>=<span class="value">"btnCancel"</span> <span class="attribute">Width</span>=<span class="value">"100"</span> <span class="attribute">Click</span>=<span class="value">"btnCancel_Click"</span> <span class="attribute">Margin</span>=<span class="value">"5"</span>&gt;</span>Cancel<span class="tag">&lt;/<span class="title">Button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">StackPanel</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">Window</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>C#<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">BackgroundWorkerExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> Interaction logic for MainWindow.xaml</span></span><br><span class="line">    <span class="comment"><span class="xmlDocTag">///</span> <span class="xmlDocTag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">MainWindow</span> : <span class="title">Window</span></span><br><span class="line">    &#123;</span><br><span class="line">        BackgroundWorker bgworker = <span class="keyword">new</span> BackgroundWorker();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MainWindow</span>(<span class="params"></span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            InitializeComponent();</span><br><span class="line"></span><br><span class="line">            bgworker.WorkerReportsProgress = <span class="keyword">true</span>;</span><br><span class="line">            bgworker.WorkerSupportsCancellation = <span class="keyword">true</span>;</span><br><span class="line">            bgworker.DoWork += bgworker_DoWork;</span><br><span class="line">            bgworker.ProgressChanged += bgworker_ProgressChanged;</span><br><span class="line">            bgworker.RunWorkerCompleted += bgworker_RunWorkerCompleted;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">bgworker_DoWork</span>(<span class="params"><span class="keyword">object</span> sender, DoWorkEventArgs e</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            BackgroundWorker worker = sender <span class="keyword">as</span> BackgroundWorker;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (worker.CancellationPending)</span><br><span class="line">                &#123;</span><br><span class="line">                    e.Cancel = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    worker.ReportProgress(i);</span><br><span class="line">                    Thread.Sleep(<span class="number">100</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">bgworker_ProgressChanged</span>(<span class="params"><span class="keyword">object</span> sender, ProgressChangedEventArgs e</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            progressBar.Value = e.ProgressPercentage;</span><br><span class="line">            textBox.Text = e.ProgressPercentage.ToString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">bgworker_RunWorkerCompleted</span>(<span class="params"><span class="keyword">object</span> sender, RunWorkerCompletedEventArgs e</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            progressBar.Value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (e.Cancelled)</span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox.Show(<span class="string">"Background task has been canceled"</span>, <span class="string">"info"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                MessageBox.Show(<span class="string">"Background task finished"</span>, <span class="string">"info"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnProcess_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!bgworker.IsBusy)</span><br><span class="line">            &#123;</span><br><span class="line">                bgworker.RunWorkerAsync();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">btnCancel_Click</span>(<span class="params"><span class="keyword">object</span> sender, RoutedEventArgs e</span>)</span><br><span class="line">        </span>&#123;</span><br><span class="line">            bgworker.CancelAsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="演示">演示</h1><p><img src="http://i781.photobucket.com/albums/yy93/Jason__Yuan/424375-443b315fdb50853d_zpsfha7r8iw.gif" alt="BackgroundWorkerExample.gif"></p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h1 id="使用前提">使用前提</h1><p>在WPF程序中，有一些比较耗时的后台操作时，比如向远程服务器请求数据，或者通过TCP/IP为某台设备提供升级固件服务等等。为了防止这类操作freeze用户界面，造成用户体验下降，即程序假死的状况出现。一种常见的，更us]]>
    </summary>
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="C#学习笔记" scheme="http://yoursite.com/tags/C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Multi-threading" scheme="http://yoursite.com/tags/Multi-threading/"/>
    
      <category term="WPF" scheme="http://yoursite.com/tags/WPF/"/>
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
      <category term="C#" scheme="http://yoursite.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Virtualenv搭建python虚拟环境]]></title>
    <link href="http://yoursite.com/2016/05/01/Virtualenv%E6%90%AD%E5%BB%BApython%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2016/05/01/Virtualenv搭建python虚拟环境/</id>
    <published>2016-05-01T20:08:39.000Z</published>
    <updated>2016-05-02T03:15:56.000Z</updated>
    <content type="html"><![CDATA[<p>来自<strong>Virtualenv</strong>官方的定义</p>
<blockquote>
<p>Virtualenv是一个可以为我们创建独立的python运行环境的工具</p>
</blockquote>
<h1 id="安装_Virtualenv">安装 Virtualenv</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 安装</span><br><span class="line">pip install virtualenv</span><br><span class="line">// 升级版本</span><br><span class="line">pip install --upgrade virtualenv</span><br></pre></td></tr></table></figure>
<h1 id="创建一个虚拟环境">创建一个虚拟环境</h1><p>假定虚拟环境的名字是<code>newEnv</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boyuan: ~ $ virtualenv newEnv</span><br><span class="line">New python executable <span class="keyword">in</span> /Users/boyuan/newEnv/bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br></pre></td></tr></table></figure></p>
<p>若想要指定Python3<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boyuan: ~ $ virtualenv -p python3 newEnv</span><br></pre></td></tr></table></figure></p>
<p>查看newEnv文件夹中的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boyuan: ~ $ <span class="built_in">cd</span> newEnv</span><br><span class="line">boyuan: ~ $ ls</span><br><span class="line">bin                include            lib                pip-selfcheck.json</span><br></pre></td></tr></table></figure></p>
<h1 id="激活虚拟环境">激活虚拟环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boyuan: ~ $ <span class="built_in">source</span> newEnv/bin/activate</span><br></pre></td></tr></table></figure>
<p>激活后会发现最左边显示当前环境名称<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(newEnv) boyuan: ~ $</span><br></pre></td></tr></table></figure></p>
<p>查看当前环境中的依赖包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(newEnv) boyuan: ~ $ pip list</span><br><span class="line">pip (<span class="number">8.1</span>.<span class="number">1</span>)</span><br><span class="line">setuptools (<span class="number">20.10</span>.<span class="number">1</span>)</span><br><span class="line">wheel (<span class="number">0.29</span>.<span class="number">0</span>)</span><br><span class="line">(newEnv) boyuan: ~ $</span><br></pre></td></tr></table></figure></p>
<p>依据当前环境中的依赖包生成requirements.txt文档<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(newEnv) boyuan: ~ $: pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure></p>
<p>依据requirements.txt文档重建环境<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(newEnv) boyuan: ~ $: pip install -r &lt; requirements.txt</span><br></pre></td></tr></table></figure></p>
<h1 id="关闭虚拟环境">关闭虚拟环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(newEnv) boyuan: ~ $ deactivate</span><br><span class="line">boyuan: ~ $</span><br></pre></td></tr></table></figure>
<h1 id="删除虚拟环境">删除虚拟环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boyuan: ~ $ rm -rf newEnv</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p>来自<strong>Virtualenv</strong>官方的定义</p>
<blockquote>
<p>Virtualenv是一个可以为我们创建独立的python运行环境的工具</p>
</blockquote>
<h1 id="安装_Virtualenv">安装 V]]>
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Virtual Environment" scheme="http://yoursite.com/tags/Virtual-Environment/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python中的模块(Module)]]></title>
    <link href="http://yoursite.com/2016/04/10/Python%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97-Module/"/>
    <id>http://yoursite.com/2016/04/10/Python中的模块-Module/</id>
    <published>2016-04-10T20:50:56.000Z</published>
    <updated>2016-04-11T03:52:46.000Z</updated>
    <content type="html"><![CDATA[<p>与在控制台输入python程序，执行命令相比。当我们的程序变得越来越长的时候，我们希望可以在文本编辑器(如sublime text, notepad++)中编写python程序，因为这样的话，我们的程序可以保存为python脚本。但是随着程序的复杂度不断上升，我们希望可以把一个python脚本根据一定的功能分割成多个不同的python module。这样做的好处主要有两个：</p>
<ul>
<li>程序看起来结构更加清晰，易于维护，因为不同的文件可以同时由不同的程序员同时维护，分工合作。</li>
<li>如果某个module或者整个package具有较强的复用性，其他的脚本甚至其他的project可以直接引用，避免了重复造轮子。</li>
</ul>
<p>这样，我们就引出了python中module和package的概念，可以说python当今十分流行的原因之一就是极为丰富的第三方模块，可以让我在完成很多任务的时候，避免了一切从零开始。当然，python本身也提供了十分强大全面的标准库 - <a href="https://docs.python.org/2/library/" target="_blank" rel="external">Python Standard Library</a></p>
<p>类似于c++中的<code>include</code>, PHP中的<code>require</code>。在python中导入模块有两种方式<code>import</code>和<code>from ... import ...</code>，下面我们通过<code>test.py</code>和<code>example.py</code>来举例说明。</p>
<p>test.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"Hello"</span></span><br><span class="line">b = <span class="string">"World"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello, World"</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="当两个文件在同一个子目录下">当两个文件在同一个子目录下</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- project</span><br><span class="line">  |-- test.py</span><br><span class="line">  `-- example.py</span><br></pre></td></tr></table></figure>
<p>如果我想要在example.py中使用test模块，有下面三种方法：</p>
<ul>
<li>第一种方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test</span><br><span class="line"></span><br><span class="line">test.Hello()  <span class="comment"># "Hello, World"</span></span><br><span class="line">print(test.a) <span class="comment"># "Hello"</span></span><br></pre></td></tr></table></figure>
<p>使用时必须遵守<code>module_name.xxx</code>的格式，此方法将整个文件都包括进来</p>
<ul>
<li>第二种方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">Hello()  <span class="comment"># "Hello, World"</span></span><br><span class="line">print(a) <span class="comment"># "Hello"</span></span><br></pre></td></tr></table></figure>
<p>使用第二种方法时，不再需要遵守第一种的格式，<code>*</code>表示import everything（但这种方式不会导入以下划线开头的名称），通常导致代码非常难读，不赞成使用。相应的应对方法就是通过使用<code>__all__</code>变量来限制。比如更改 <code>test.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__all__ = [<span class="string">"a"</span>, <span class="string">"b"</span>]</span><br><span class="line">a = <span class="string">"Hello"</span></span><br><span class="line">b = <span class="string">"World"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello, World"</span>)</span><br></pre></td></tr></table></figure>
<p>这样的话，<code>import *</code>将<strong>不能</strong>引入<code>Hello</code>方法</p>
<ul>
<li>第三种方法<br>在import的时候就声明具体要引入的内容</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> Hello</span><br><span class="line"></span><br><span class="line">Hello()  <span class="comment"># "Hello, World"</span></span><br></pre></td></tr></table></figure>
<h2 id="当主程序所在目录是模块所在目录的父(或祖辈)目录">当主程序所在目录是模块所在目录的父(或祖辈)目录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- project</span><br><span class="line">  |-- module</span><br><span class="line">  |  `--test.py</span><br><span class="line">  `-- example.py</span><br></pre></td></tr></table></figure>
<p>如果要在<code>example.py</code>中使用<code>test</code>模块<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module.test <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module.test</span><br></pre></td></tr></table></figure></p>
<p>但要注意必须在module文件夹中添加<code>__init__.py</code>文件，文件可以为空。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>与在控制台输入python程序，执行命令相比。当我们的程序变得越来越长的时候，我们希望可以在文本编辑器(如sublime text, notepad++)中编写python程序，因为这样的话，我们的程序可以保存为python脚本。但是随着程序的复杂度不断上升，我们希望可以把]]>
    </summary>
    
      <category term="Module" scheme="http://yoursite.com/tags/Module/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[475 Binary Tree Maximum Path Sum II]]></title>
    <link href="http://yoursite.com/2015/11/19/475-Binary-Tree-Maximum-Path-Sum-II/"/>
    <id>http://yoursite.com/2015/11/19/475-Binary-Tree-Maximum-Path-Sum-II/</id>
    <published>2015-11-19T23:22:19.000Z</published>
    <updated>2016-04-10T01:29:43.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>已知一颗二叉树，找到从根节点到任意节点的最大路径和</p>
</blockquote>
<p>已知下面一颗二叉树<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>返回4. (1-&gt;3)</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>Divide and Conquer</li>
<li>借助一个helper函数，从根节点向下分裂，每一层返回左右儿子中的最大值与当前节点的值，层层递归</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span><br><span class="line">Definition of TreeNode:</span><br><span class="line">class TreeNode:</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        this.val = val</span><br><span class="line">        this.left, this.right = None, None</span><br><span class="line">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param root the root of binary tree.</span><br><span class="line">    @return an integer</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum2</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(left, right) + root.val</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>已知一颗二叉树，找到从根节点到任意节点的最大路径和</p>
</blockquote>
<p>已知下面一颗二叉树<br><figure class="highlight python"><table><tr><]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[471 Top K Frequent Words]]></title>
    <link href="http://yoursite.com/2015/11/12/471-Top-K-Frequent-Words/"/>
    <id>http://yoursite.com/2015/11/12/471-Top-K-Frequent-Words/</id>
    <published>2015-11-13T00:08:22.000Z</published>
    <updated>2016-04-10T00:29:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>Given a list of words and an integer k, return the top k frequent words in the list.</p>
</blockquote>
<p>给出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ </span><br><span class="line"><span class="string">"yes"</span>, <span class="string">"lint"</span>, <span class="string">"code"</span>, </span><br><span class="line"><span class="string">"yes"</span>, <span class="string">"code"</span>, <span class="string">"baby"</span>, </span><br><span class="line"><span class="string">"you"</span>, <span class="string">"baby"</span>, <span class="string">"chrome"</span>, </span><br><span class="line"><span class="string">"safari"</span>, <span class="string">"lint"</span>, <span class="string">"code"</span>, </span><br><span class="line"><span class="string">"body"</span>, <span class="string">"lint"</span>, <span class="string">"code"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>当k=3时，返回[“code”, “lint”, “baby”]<br>当k=4时，返回[“code”, “lint”, “baby”, “yes”]</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>首先使用hash table统计词频，建立一个存有<strong>（单词，词频）结构</strong>的数组</li>
<li>自定义<strong>（单词，词频）结构</strong>的比较方式</li>
<li>快速排序，然后取出前K个，得到结果</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;string[]&#125; words a list of string</span></span><br><span class="line">    <span class="comment"># @param &#123;int&#125; k an integer</span></span><br><span class="line">    <span class="comment"># @return &#123;string[]&#125; a list of string</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequentWords</span><span class="params">(self, words, k)</span>:</span></span><br><span class="line">        map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> map:</span><br><span class="line">                map[word] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                map[word] += <span class="number">1</span></span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> map.items():</span><br><span class="line">            temp.append((value, key))</span><br><span class="line">        temp.sort(cmp=self.cmp)</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            result.append(temp[i][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmp</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] <span class="keyword">or</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] <span class="keyword">and</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] <span class="keyword">and</span> a[<span class="number">1</span>] == b[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>Given a list of words and an integer k, return the top k frequent words in the list.</p>
</blockquote>
<p]]>
    </summary>
    
      <category term="Hash Table" scheme="http://yoursite.com/tags/Hash-Table/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Quick Sort" scheme="http://yoursite.com/tags/Quick-Sort/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[264 Ugly Number II]]></title>
    <link href="http://yoursite.com/2015/11/12/264-Ugly-Number-II/"/>
    <id>http://yoursite.com/2015/11/12/264-Ugly-Number-II/</id>
    <published>2015-11-13T00:03:37.000Z</published>
    <updated>2015-11-13T08:04:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>设计一个算法，找出只含素因子2，3，5 的第 k 大的数。<br>符合条件的数如：1, 2, 3, 4, 5, 6, 8, 9, 10, 12……</p>
</blockquote>
<p>如果k=4， 返回 4<br>挑战<br>要求时间复杂度为O(nlogn)或者O(n)</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>动态规划</li>
<li>每一个丑数都是由某一个比它小得丑数乘以2，3或者5得到的</li>
<li>res数组记录前k个丑数</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        i2 = i3 = i5 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            nextUglyNumber = min(min(res[i2] * <span class="number">2</span>, res[i3] * <span class="number">3</span>), res[i5] * <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> nextUglyNumber == res[i2] * <span class="number">2</span>:</span><br><span class="line">                i2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nextUglyNumber == res[i3] * <span class="number">3</span>:</span><br><span class="line">                i3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nextUglyNumber == res[i5] * <span class="number">5</span>:</span><br><span class="line">                i5 += <span class="number">1</span></span><br><span class="line">            res[i] = nextUglyNumber</span><br><span class="line">        <span class="keyword">return</span> res[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>设计一个算法，找出只含素因子2，3，5 的第 k 大的数。<br>符合条件的数如：1, 2, 3, 4, 5, 6, 8, 9, 10, 12……</p>
</blockquote>
<p>如果k=4， 返回 ]]>
    </summary>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[215 Kth Largest Element in an Array]]></title>
    <link href="http://yoursite.com/2015/11/12/215-Kth-Largest-Element-in-an-Array/"/>
    <id>http://yoursite.com/2015/11/12/215-Kth-Largest-Element-in-an-Array/</id>
    <published>2015-11-12T23:59:40.000Z</published>
    <updated>2015-11-13T08:00:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>在数组中找到第k大的元素</p>
</blockquote>
<p>给出数组<strong>[9,3,2,4,8]</strong>，第三大的元素是4<br>给出数组<strong>[1,2,3,4,5]</strong>第一大的元素是5，第二大的元素是4，第三大的元素是3，以此类推</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>寻找第<code>k</code>大的数字可以转化为寻找第<code>n+1-k</code>小的数字，进而想到<strong>Quick Select</strong></li>
<li>Quick Select算法的基本思路与Quick Sort类似，重点是<strong>partition</strong></li>
<li>基本思想，随机选取一个pivot，小于的放左边，大于等于的放右边，返回pivot的位置<ul>
<li>如果<code>pivot == k</code>，则正好找到了第k小的元素</li>
<li>如果<code>pivot &gt; k</code>，则第k小的元素存在于pivot左边</li>
<li>如果<code>pivot &lt; k</code>，则第k小的元素存在于pivot右边</li>
</ul>
</li>
<li>时间复杂度：O(<em>n</em> logn) (in quicksort), O(n) (in quickselect)</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type k: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        """</span></span><br><span class="line">        <span class="comment"># convert the kth largest to smallest</span></span><br><span class="line">        <span class="keyword">return</span> self.findKthSmallest(nums, len(nums)+<span class="number">1</span>-k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthSmallest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> nums:</span><br><span class="line">            pos = self.partition(nums, <span class="number">0</span>, len(nums)-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> k &gt; pos+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> self.findKthSmallest(nums[pos+<span class="number">1</span>:], k-pos-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> k &lt; pos+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> self.findKthSmallest(nums[:pos], k)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[pos]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># choose the right-most element as pivot   </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, nums, l, r)</span>:</span></span><br><span class="line">        low = l</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> nums[l] &lt; nums[r]:</span><br><span class="line">                nums[l], nums[low] = nums[low], nums[l]</span><br><span class="line">                low += <span class="number">1</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        nums[low], nums[r] = nums[r], nums[low]</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>在数组中找到第k大的元素</p>
</blockquote>
<p>给出数组<strong>[9,3,2,4,8]</strong>，第三大的元素是4<br>给出数组<strong>[1,2,3,4,5]</s]]>
    </summary>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Quick Sort" scheme="http://yoursite.com/tags/Quick-Sort/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[77 Longest Common Subsequence]]></title>
    <link href="http://yoursite.com/2015/11/02/77-Longest-Common-Subsequence/"/>
    <id>http://yoursite.com/2015/11/02/77-Longest-Common-Subsequence/</id>
    <published>2015-11-02T17:45:53.000Z</published>
    <updated>2015-11-03T01:47:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p>
</blockquote>
<p>给出<strong>“ABCD”</strong> 和 <strong>“EDCA”</strong>，这个LCS是 <strong>“A”</strong> (或 D或C)，返回1<br>给出<strong> “ABCD”</strong> 和 <strong>“EACB”</strong>，这个LCS是<strong>“AC”</strong>返回 2</p>
<h1 id="解题思路">解题思路</h1><ul>
<li><strong>双序列型动态规划</strong> - Two Sequence DP</li>
<li><code>cache[i][j]</code>表示第一个字符串的前i个字符和第二个字符串的前j个字符的最长公共子序列的长度</li>
<li>状态转移方程：<ul>
<li>如果<code>str1[i] != str2[j]</code><br>cache[i][j] = max(cache[i][j - 1], cache[i - 1][j])</li>
<li>如果<code>str1[i] != str2[j]</code><br>cache[i - 1][j - 1] + 1</li>
</ul>
</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span><br><span class="line">    @param A, B: Two strings.</span><br><span class="line">    @return: The length of longest common subsequence of A and B.</span><br><span class="line">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonSubsequence</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A <span class="keyword">or</span> <span class="keyword">not</span> B:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A) + <span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(B) + <span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(B) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(A) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> A[j - <span class="number">1</span>] == B[i - <span class="number">1</span>]:</span><br><span class="line">                    cache[i][j] = cache[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cache[i][j] = max(cache[i][j - <span class="number">1</span>], cache[i - <span class="number">1</span>][j])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cache[len(B)][len(A)]</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>给出两个字符串，找到最长公共子序列(LCS)，返回LCS的长度。</p>
</blockquote>
<p>给出<strong>“ABCD”</strong> 和 <strong>“EDCA”</strong>]]>
    </summary>
    
      <category term="Array" scheme="http://yoursite.com/tags/Array/"/>
    
      <category term="Dynamic Programing" scheme="http://yoursite.com/tags/Dynamic-Programing/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/tags/LintCode/"/>
    
      <category term="Two Sequence DP" scheme="http://yoursite.com/tags/Two-Sequence-DP/"/>
    
      <category term="LintCode" scheme="http://yoursite.com/categories/LintCode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[105 Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <link href="http://yoursite.com/2015/11/02/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/"/>
    <id>http://yoursite.com/2015/11/02/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</id>
    <published>2015-11-02T16:15:56.000Z</published>
    <updated>2016-04-10T01:22:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>根据前序遍历和中序遍历树构造二叉树.</p>
</blockquote>
<p>给出中序遍历：[1,2,3]和前序遍历：[2,1,3]. 返回如下的树:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">2</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">1</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>你可以假设树中不存在相同数值的节点</p>
<h1 id="解题思路">解题思路</h1><ul>
<li>本题与通过中序和后序遍历构造二叉树类似，同样是递归解决</li>
<li>前序遍历数组的第一个值为根节点，根据这个值可以将中序遍历数组分成左右两部分，分别为左子树和右子树</li>
</ul>
<h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span><br><span class="line">        :type preorder: List[int]</span><br><span class="line">        :type inorder: List[int]</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        """</span></span><br><span class="line">        <span class="keyword">if</span> inorder:</span><br><span class="line">            index = inorder.index(preorder[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> preorder[<span class="number">0</span>]</span><br><span class="line">            root = TreeNode(inorder[index])</span><br><span class="line">            root.left = self.buildTree(preorder, inorder[:index])</span><br><span class="line">            root.right = self.buildTree(preorder, inorder[index + <span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="原题">原题</h1><blockquote>
<p>根据前序遍历和中序遍历树构造二叉树.</p>
</blockquote>
<p>给出中序遍历：[1,2,3]和前序遍历：[2,1,3]. 返回如下的树:<br><figure class="highlight ]]>
    </summary>
    
      <category term="Binary Tree" scheme="http://yoursite.com/tags/Binary-Tree/"/>
    
      <category term="Divide and Conquer" scheme="http://yoursite.com/tags/Divide-and-Conquer/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/tags/LeetCode/"/>
    
      <category term="Recursion" scheme="http://yoursite.com/tags/Recursion/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/LeetCode/"/>
    
  </entry>
  
</feed>
